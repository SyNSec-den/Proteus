diff --git a/.clang-format b/.clang-format
old mode 100644
new mode 100755
diff --git a/.clang-tidy b/.clang-tidy
old mode 100644
new mode 100755
diff --git a/.gdbinit b/.gdbinit
old mode 100644
new mode 100755
diff --git a/.github/ISSUE_TEMPLATE.md b/.github/ISSUE_TEMPLATE.md
old mode 100644
new mode 100755
diff --git a/.github/workflows/ccpp.yml b/.github/workflows/ccpp.yml
old mode 100644
new mode 100755
diff --git a/.github/workflows/codeql.yml b/.github/workflows/codeql.yml
old mode 100644
new mode 100755
diff --git a/.gitignore b/.gitignore
new file mode 100755
index 000000000..42afabfd2
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1 @@
+/build
\ No newline at end of file
diff --git a/.idea/.gitignore b/.idea/.gitignore
new file mode 100644
index 000000000..13566b81b
--- /dev/null
+++ b/.idea/.gitignore
@@ -0,0 +1,8 @@
+# Default ignored files
+/shelf/
+/workspace.xml
+# Editor-based HTTP Client requests
+/httpRequests/
+# Datasource local storage ignored files
+/dataSources/
+/dataSources.local.xml
diff --git a/.idea/.name b/.idea/.name
new file mode 100644
index 000000000..88a907992
--- /dev/null
+++ b/.idea/.name
@@ -0,0 +1 @@
+SRSRAN
\ No newline at end of file
diff --git a/.idea/codeStyles/Project.xml b/.idea/codeStyles/Project.xml
new file mode 100644
index 000000000..f60388162
--- /dev/null
+++ b/.idea/codeStyles/Project.xml
@@ -0,0 +1,7 @@
+<component name="ProjectCodeStyleConfiguration">
+  <code_scheme name="Project" version="173">
+    <clangFormatSettings>
+      <option name="ENABLED" value="true" />
+    </clangFormatSettings>
+  </code_scheme>
+</component>
\ No newline at end of file
diff --git a/.idea/codeStyles/codeStyleConfig.xml b/.idea/codeStyles/codeStyleConfig.xml
new file mode 100644
index 000000000..79ee123c2
--- /dev/null
+++ b/.idea/codeStyles/codeStyleConfig.xml
@@ -0,0 +1,5 @@
+<component name="ProjectCodeStyleConfiguration">
+  <state>
+    <option name="USE_PER_PROJECT_SETTINGS" value="true" />
+  </state>
+</component>
\ No newline at end of file
diff --git a/.idea/misc.xml b/.idea/misc.xml
new file mode 100644
index 000000000..79b3c9483
--- /dev/null
+++ b/.idea/misc.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="CMakeWorkspace" PROJECT_DIR="$PROJECT_DIR$" />
+</project>
\ No newline at end of file
diff --git a/.idea/modules.xml b/.idea/modules.xml
new file mode 100644
index 000000000..7222a675f
--- /dev/null
+++ b/.idea/modules.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectModuleManager">
+    <modules>
+      <module fileurl="file://$PROJECT_DIR$/.idea/srsran_4g_attacker.iml" filepath="$PROJECT_DIR$/.idea/srsran_4g_attacker.iml" />
+    </modules>
+  </component>
+</project>
\ No newline at end of file
diff --git a/.idea/srsran_4g_attacker.iml b/.idea/srsran_4g_attacker.iml
new file mode 100644
index 000000000..f08604bb6
--- /dev/null
+++ b/.idea/srsran_4g_attacker.iml
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module classpath="CMake" type="CPP_MODULE" version="4" />
\ No newline at end of file
diff --git a/.idea/vcs.xml b/.idea/vcs.xml
new file mode 100644
index 000000000..35eb1ddfb
--- /dev/null
+++ b/.idea/vcs.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="VcsDirectoryMappings">
+    <mapping directory="" vcs="Git" />
+  </component>
+</project>
\ No newline at end of file
diff --git a/.vscode/settings.json b/.vscode/settings.json
new file mode 100755
index 000000000..88b3ea05b
--- /dev/null
+++ b/.vscode/settings.json
@@ -0,0 +1,73 @@
+{
+    "files.associations": {
+        "string_help.h": "c",
+        "ctype.h": "c",
+        "string.h": "c",
+        "stdlib.h": "c",
+        "thread": "cpp",
+        "memory_resource": "cpp",
+        "cctype": "cpp",
+        "clocale": "cpp",
+        "cmath": "cpp",
+        "csignal": "cpp",
+        "cstdarg": "cpp",
+        "cstddef": "cpp",
+        "cstdio": "cpp",
+        "cstdlib": "cpp",
+        "cstring": "cpp",
+        "ctime": "cpp",
+        "cwchar": "cpp",
+        "cwctype": "cpp",
+        "array": "cpp",
+        "atomic": "cpp",
+        "strstream": "cpp",
+        "bit": "cpp",
+        "*.tcc": "cpp",
+        "bitset": "cpp",
+        "chrono": "cpp",
+        "cinttypes": "cpp",
+        "complex": "cpp",
+        "condition_variable": "cpp",
+        "cstdint": "cpp",
+        "deque": "cpp",
+        "list": "cpp",
+        "map": "cpp",
+        "set": "cpp",
+        "unordered_map": "cpp",
+        "unordered_set": "cpp",
+        "vector": "cpp",
+        "exception": "cpp",
+        "algorithm": "cpp",
+        "functional": "cpp",
+        "iterator": "cpp",
+        "memory": "cpp",
+        "numeric": "cpp",
+        "optional": "cpp",
+        "random": "cpp",
+        "ratio": "cpp",
+        "string": "cpp",
+        "string_view": "cpp",
+        "system_error": "cpp",
+        "tuple": "cpp",
+        "type_traits": "cpp",
+        "utility": "cpp",
+        "fstream": "cpp",
+        "initializer_list": "cpp",
+        "iomanip": "cpp",
+        "iosfwd": "cpp",
+        "iostream": "cpp",
+        "istream": "cpp",
+        "limits": "cpp",
+        "mutex": "cpp",
+        "new": "cpp",
+        "ostream": "cpp",
+        "sstream": "cpp",
+        "stdexcept": "cpp",
+        "streambuf": "cpp",
+        "cfenv": "cpp",
+        "typeindex": "cpp",
+        "typeinfo": "cpp",
+        "variant": "cpp",
+        "*.ipp": "cpp"
+    }
+}
\ No newline at end of file
diff --git a/CHANGELOG b/CHANGELOG
old mode 100644
new mode 100755
diff --git a/CMakeLists.txt b/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/COPYRIGHT b/COPYRIGHT
old mode 100644
new mode 100755
diff --git a/CTestConfig.cmake b/CTestConfig.cmake
old mode 100644
new mode 100755
diff --git a/CTestCustom.cmake.in b/CTestCustom.cmake.in
old mode 100644
new mode 100755
diff --git a/LICENSE b/LICENSE
old mode 100644
new mode 100755
diff --git a/README.md b/README.md
old mode 100644
new mode 100755
diff --git a/cmake/modules/CheckAtomic.cmake b/cmake/modules/CheckAtomic.cmake
old mode 100644
new mode 100755
diff --git a/cmake/modules/CheckCSourceRuns.cmake b/cmake/modules/CheckCSourceRuns.cmake
old mode 100644
new mode 100755
diff --git a/cmake/modules/CheckFunctionExists.c b/cmake/modules/CheckFunctionExists.c
old mode 100644
new mode 100755
diff --git a/cmake/modules/CheckFunctionExistsMath.cmake b/cmake/modules/CheckFunctionExistsMath.cmake
old mode 100644
new mode 100755
diff --git a/cmake/modules/FindBackward.cmake b/cmake/modules/FindBackward.cmake
old mode 100644
new mode 100755
diff --git a/cmake/modules/FindFFTW3F.cmake b/cmake/modules/FindFFTW3F.cmake
old mode 100644
new mode 100755
diff --git a/cmake/modules/FindLibConfig.cmake b/cmake/modules/FindLibConfig.cmake
old mode 100644
new mode 100755
diff --git a/cmake/modules/FindLimeSDR.cmake b/cmake/modules/FindLimeSDR.cmake
old mode 100644
new mode 100755
diff --git a/cmake/modules/FindMKL.cmake b/cmake/modules/FindMKL.cmake
old mode 100644
new mode 100755
diff --git a/cmake/modules/FindMbedTLS.cmake b/cmake/modules/FindMbedTLS.cmake
old mode 100644
new mode 100755
diff --git a/cmake/modules/FindPCSCLite.cmake b/cmake/modules/FindPCSCLite.cmake
old mode 100644
new mode 100755
diff --git a/cmake/modules/FindRapidJSON.cmake b/cmake/modules/FindRapidJSON.cmake
old mode 100644
new mode 100755
diff --git a/cmake/modules/FindSCTP.cmake b/cmake/modules/FindSCTP.cmake
old mode 100644
new mode 100755
diff --git a/cmake/modules/FindSKIQ.cmake b/cmake/modules/FindSKIQ.cmake
old mode 100644
new mode 100755
diff --git a/cmake/modules/FindSRSGUI.cmake b/cmake/modules/FindSRSGUI.cmake
old mode 100644
new mode 100755
diff --git a/cmake/modules/FindSSE.cmake b/cmake/modules/FindSSE.cmake
old mode 100644
new mode 100755
diff --git a/cmake/modules/FindSoapySDR.cmake b/cmake/modules/FindSoapySDR.cmake
old mode 100644
new mode 100755
diff --git a/cmake/modules/FindUHD.cmake b/cmake/modules/FindUHD.cmake
old mode 100644
new mode 100755
diff --git a/cmake/modules/FindZeroMQ.cmake b/cmake/modules/FindZeroMQ.cmake
old mode 100644
new mode 100755
diff --git a/cmake/modules/FindbladeRF.cmake b/cmake/modules/FindbladeRF.cmake
old mode 100644
new mode 100755
diff --git a/cmake/modules/SRSRANPackage.cmake b/cmake/modules/SRSRANPackage.cmake
old mode 100644
new mode 100755
diff --git a/cmake/modules/SRSRANVersion.cmake b/cmake/modules/SRSRANVersion.cmake
old mode 100644
new mode 100755
diff --git a/cmake/modules/SRSRANbuildinfo.cmake.in b/cmake/modules/SRSRANbuildinfo.cmake.in
old mode 100644
new mode 100755
diff --git a/cmake_uninstall.cmake.in b/cmake_uninstall.cmake.in
old mode 100644
new mode 100755
diff --git a/debian/changelog b/debian/changelog
old mode 100644
new mode 100755
diff --git a/debian/compat b/debian/compat
old mode 100644
new mode 100755
diff --git a/debian/control b/debian/control
old mode 100644
new mode 100755
diff --git a/debian/copyright b/debian/copyright
old mode 100644
new mode 100755
diff --git a/debian/man/srsenb.txt b/debian/man/srsenb.txt
old mode 100644
new mode 100755
diff --git a/debian/man/srsepc.txt b/debian/man/srsepc.txt
old mode 100644
new mode 100755
diff --git a/debian/man/srsue.txt b/debian/man/srsue.txt
old mode 100644
new mode 100755
diff --git a/debian/source/format b/debian/source/format
old mode 100644
new mode 100755
diff --git a/debian/srsenb.install b/debian/srsenb.install
old mode 100644
new mode 100755
diff --git a/debian/srsenb.manpages b/debian/srsenb.manpages
old mode 100644
new mode 100755
diff --git a/debian/srsenb.service b/debian/srsenb.service
old mode 100644
new mode 100755
diff --git a/debian/srsepc.install b/debian/srsepc.install
old mode 100644
new mode 100755
diff --git a/debian/srsepc.manpages b/debian/srsepc.manpages
old mode 100644
new mode 100755
diff --git a/debian/srsepc.service b/debian/srsepc.service
old mode 100644
new mode 100755
diff --git a/debian/srslte-core.install b/debian/srslte-core.install
old mode 100644
new mode 100755
diff --git a/debian/srslte-core.templates b/debian/srslte-core.templates
old mode 100644
new mode 100755
diff --git a/debian/srslte-dev.install b/debian/srslte-dev.install
old mode 100644
new mode 100755
diff --git a/debian/srsue.install b/debian/srsue.install
old mode 100644
new mode 100755
diff --git a/debian/srsue.manpages b/debian/srsue.manpages
old mode 100644
new mode 100755
diff --git a/debian/srsue.service b/debian/srsue.service
old mode 100644
new mode 100755
diff --git a/lib/CMakeLists.txt b/lib/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/examples/CMakeLists.txt b/lib/examples/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/examples/cell_search.c b/lib/examples/cell_search.c
old mode 100644
new mode 100755
diff --git a/lib/examples/cell_search_nbiot.c b/lib/examples/cell_search_nbiot.c
old mode 100644
new mode 100755
diff --git a/lib/examples/npdsch_enodeb.c b/lib/examples/npdsch_enodeb.c
old mode 100644
new mode 100755
diff --git a/lib/examples/npdsch_ue.c b/lib/examples/npdsch_ue.c
old mode 100644
new mode 100755
diff --git a/lib/examples/npdsch_ue_helper.cc b/lib/examples/npdsch_ue_helper.cc
old mode 100644
new mode 100755
diff --git a/lib/examples/npdsch_ue_helper.h b/lib/examples/npdsch_ue_helper.h
old mode 100644
new mode 100755
diff --git a/lib/examples/pdsch_enodeb.c b/lib/examples/pdsch_enodeb.c
old mode 100644
new mode 100755
diff --git a/lib/examples/pdsch_ue.c b/lib/examples/pdsch_ue.c
old mode 100644
new mode 100755
diff --git a/lib/examples/pssch_ue.c b/lib/examples/pssch_ue.c
old mode 100644
new mode 100755
diff --git a/lib/examples/synch_file.c b/lib/examples/synch_file.c
old mode 100644
new mode 100755
diff --git a/lib/examples/test/CMakeLists.txt b/lib/examples/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/examples/test/iqtests.cmake b/lib/examples/test/iqtests.cmake
old mode 100644
new mode 100755
diff --git a/lib/examples/usrp_capture.c b/lib/examples/usrp_capture.c
old mode 100644
new mode 100755
diff --git a/lib/examples/usrp_capture_sync.c b/lib/examples/usrp_capture_sync.c
old mode 100644
new mode 100755
diff --git a/lib/examples/usrp_capture_sync_nbiot.c b/lib/examples/usrp_capture_sync_nbiot.c
old mode 100644
new mode 100755
diff --git a/lib/examples/usrp_txrx.c b/lib/examples/usrp_txrx.c
old mode 100644
new mode 100755
diff --git a/lib/examples/zmq_remote_rx.c b/lib/examples/zmq_remote_rx.c
old mode 100644
new mode 100755
diff --git a/lib/include/CMakeLists.txt b/lib/include/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/CMakeLists.txt b/lib/include/srsran/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/adt/accumulators.h b/lib/include/srsran/adt/accumulators.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/adt/bounded_bitset.h b/lib/include/srsran/adt/bounded_bitset.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/adt/bounded_vector.h b/lib/include/srsran/adt/bounded_vector.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/adt/choice_type.h b/lib/include/srsran/adt/choice_type.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/adt/circular_array.h b/lib/include/srsran/adt/circular_array.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/adt/circular_buffer.h b/lib/include/srsran/adt/circular_buffer.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/adt/circular_map.h b/lib/include/srsran/adt/circular_map.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/adt/detail/index_sequence.h b/lib/include/srsran/adt/detail/index_sequence.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/adt/detail/type_storage.h b/lib/include/srsran/adt/detail/type_storage.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/adt/detail/type_utils.h b/lib/include/srsran/adt/detail/type_utils.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/adt/expected.h b/lib/include/srsran/adt/expected.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/adt/fsm.h b/lib/include/srsran/adt/fsm.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/adt/interval.h b/lib/include/srsran/adt/interval.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/adt/intrusive_list.h b/lib/include/srsran/adt/intrusive_list.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/adt/move_callback.h b/lib/include/srsran/adt/move_callback.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/adt/observer.h b/lib/include/srsran/adt/observer.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/adt/optional.h b/lib/include/srsran/adt/optional.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/adt/optional_array.h b/lib/include/srsran/adt/optional_array.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/adt/pool/batch_mem_pool.h b/lib/include/srsran/adt/pool/batch_mem_pool.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/adt/pool/cached_alloc.h b/lib/include/srsran/adt/pool/cached_alloc.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/adt/pool/circular_stack_pool.h b/lib/include/srsran/adt/pool/circular_stack_pool.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/adt/pool/fixed_size_pool.h b/lib/include/srsran/adt/pool/fixed_size_pool.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/adt/pool/linear_allocator.h b/lib/include/srsran/adt/pool/linear_allocator.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/adt/pool/mem_pool.h b/lib/include/srsran/adt/pool/mem_pool.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/adt/pool/memblock_cache.h b/lib/include/srsran/adt/pool/memblock_cache.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/adt/pool/obj_pool.h b/lib/include/srsran/adt/pool/obj_pool.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/adt/pool/pool_interface.h b/lib/include/srsran/adt/pool/pool_interface.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/adt/pool/pool_utils.h b/lib/include/srsran/adt/pool/pool_utils.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/adt/scope_exit.h b/lib/include/srsran/adt/scope_exit.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/adt/singleton.h b/lib/include/srsran/adt/singleton.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/adt/span.h b/lib/include/srsran/adt/span.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/asn1_utils.h b/lib/include/srsran/asn1/asn1_utils.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/e2ap.h b/lib/include/srsran/asn1/e2ap.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/e2sm.h b/lib/include/srsran/asn1/e2sm.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/e2sm_kpm.h b/lib/include/srsran/asn1/e2sm_kpm.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/e2sm_kpm_v2.h b/lib/include/srsran/asn1/e2sm_kpm_v2.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/gtpc.h b/lib/include/srsran/asn1/gtpc.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/gtpc_ies.h b/lib/include/srsran/asn1/gtpc_ies.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/gtpc_msg.h b/lib/include/srsran/asn1/gtpc_msg.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/liblte_common.h b/lib/include/srsran/asn1/liblte_common.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/liblte_mme.h b/lib/include/srsran/asn1/liblte_mme.h
old mode 100644
new mode 100755
index 93d29f348..7605d27c3
--- a/lib/include/srsran/asn1/liblte_mme.h
+++ b/lib/include/srsran/asn1/liblte_mme.h
@@ -2462,10 +2462,16 @@ typedef struct {
   bool                                          t3412_ext_present;
 } LIBLTE_MME_ATTACH_ACCEPT_MSG_STRUCT;
 // Functions
+LIBLTE_ERROR_ENUM liblte_mme_pack_attach_accept_msg_mac(LIBLTE_MME_ATTACH_ACCEPT_MSG_STRUCT* attach_accept,
+                                                    uint8                                sec_hdr_type,
+                                                    uint32                               count,
+                                                    LIBLTE_BYTE_MSG_STRUCT*              msg);
+
 LIBLTE_ERROR_ENUM liblte_mme_pack_attach_accept_msg(LIBLTE_MME_ATTACH_ACCEPT_MSG_STRUCT* attach_accept,
                                                     uint8                                sec_hdr_type,
                                                     uint32                               count,
                                                     LIBLTE_BYTE_MSG_STRUCT*              msg);
+
 LIBLTE_ERROR_ENUM liblte_mme_unpack_attach_accept_msg(LIBLTE_BYTE_MSG_STRUCT*              msg,
                                                       LIBLTE_MME_ATTACH_ACCEPT_MSG_STRUCT* attach_accept);
 
@@ -2649,9 +2655,15 @@ typedef struct {
 } LIBLTE_MME_AUTHENTICATION_REQUEST_MSG_STRUCT;
 // Functions
 LIBLTE_ERROR_ENUM liblte_mme_pack_authentication_request_msg(LIBLTE_MME_AUTHENTICATION_REQUEST_MSG_STRUCT* auth_req,
-                                                             LIBLTE_BYTE_MSG_STRUCT*                       msg);
-LIBLTE_ERROR_ENUM liblte_mme_unpack_authentication_request_msg(LIBLTE_BYTE_MSG_STRUCT*                       msg,
-                                                               LIBLTE_MME_AUTHENTICATION_REQUEST_MSG_STRUCT* auth_req);
+                                                             LIBLTE_BYTE_MSG_STRUCT*                       msg,
+                                                             uint8                                         sec_hdr_type);
+// fuzzing
+LIBLTE_ERROR_ENUM liblte_mme_pack_authentication_request_msg_mac(LIBLTE_MME_AUTHENTICATION_REQUEST_MSG_STRUCT* auth_req,
+                                                                 LIBLTE_BYTE_MSG_STRUCT*                       msg,
+                                                                 uint8                                         sec_hdr_type,
+                                                                 uint32                                        count);
+//LIBLTE_ERROR_ENUM liblte_mme_unpack_authentication_request_msg(LIBLTE_BYTE_MSG_STRUCT*                       msg,
+//                                                               LIBLTE_MME_AUTHENTICATION_REQUEST_MSG_STRUCT* auth_req);
 
 /*********************************************************************
     Message Name: Authentication Response
@@ -2731,6 +2743,15 @@ typedef struct {
   LIBLTE_MME_EPS_MOBILE_ID_STRUCT  eps_mobile_id;
 } LIBLTE_MME_DETACH_REQUEST_MSG_STRUCT;
 // Functions
+
+typedef struct {
+  LIBLTE_MME_DETACH_TYPE_STRUCT    detach_type;
+} LIBLTE_MME_DETACH_REQUEST_NET_MSG_STRUCT;
+
+LIBLTE_ERROR_ENUM liblte_mme_pack_detach_request_net_msg(LIBLTE_MME_DETACH_REQUEST_NET_MSG_STRUCT* detach_req, uint8  sec_hdr_type, uint32 count, LIBLTE_BYTE_MSG_STRUCT* msg);
+
+
+
 LIBLTE_ERROR_ENUM liblte_mme_pack_detach_request_msg(LIBLTE_MME_DETACH_REQUEST_MSG_STRUCT* detach_req,
                                                      uint8                                 sec_hdr_type,
                                                      uint32                                count,
@@ -2759,6 +2780,12 @@ liblte_mme_pack_downlink_nas_transport_msg(LIBLTE_MME_DOWNLINK_NAS_TRANSPORT_MSG
                                            uint32                                        count,
                                            LIBLTE_BYTE_MSG_STRUCT*                       msg);
 LIBLTE_ERROR_ENUM
+liblte_mme_pack_downlink_nas_transport_msg_mac(LIBLTE_MME_DOWNLINK_NAS_TRANSPORT_MSG_STRUCT* dl_nas_transport,
+                                           uint8                                         sec_hdr_type,
+                                           uint32                                        count,
+                                           LIBLTE_BYTE_MSG_STRUCT*                       msg);
+
+LIBLTE_ERROR_ENUM
 liblte_mme_unpack_downlink_nas_transport_msg(LIBLTE_BYTE_MSG_STRUCT*                       msg,
                                              LIBLTE_MME_DOWNLINK_NAS_TRANSPORT_MSG_STRUCT* dl_nas_transport);
 
@@ -2884,6 +2911,12 @@ liblte_mme_pack_guti_reallocation_command_msg(LIBLTE_MME_GUTI_REALLOCATION_COMMA
                                               uint8                                            sec_hdr_type,
                                               uint32                                           count,
                                               LIBLTE_BYTE_MSG_STRUCT*                          msg);
+
+LIBLTE_ERROR_ENUM
+liblte_mme_pack_guti_reallocation_command_msg_mac(LIBLTE_MME_GUTI_REALLOCATION_COMMAND_MSG_STRUCT* guti_realloc_cmd,
+                                              uint8                                            sec_hdr_type,
+                                              uint32                                           count,
+                                              LIBLTE_BYTE_MSG_STRUCT*                          msg);
 LIBLTE_ERROR_ENUM
 liblte_mme_unpack_guti_reallocation_command_msg(LIBLTE_BYTE_MSG_STRUCT*                          msg,
                                                 LIBLTE_MME_GUTI_REALLOCATION_COMMAND_MSG_STRUCT* guti_realloc_cmd);
@@ -2928,6 +2961,11 @@ typedef struct {
 // Functions
 LIBLTE_ERROR_ENUM liblte_mme_pack_identity_request_msg(LIBLTE_MME_ID_REQUEST_MSG_STRUCT* id_req,
                                                        LIBLTE_BYTE_MSG_STRUCT*           msg);
+// fuzzing
+LIBLTE_ERROR_ENUM liblte_mme_pack_identity_request_msg_mac(LIBLTE_MME_ID_REQUEST_MSG_STRUCT* id_req,
+                                                           LIBLTE_BYTE_MSG_STRUCT*           msg,
+                                                           uint32                            count, 
+                                                           uint8                             sec_hdr_type);
 LIBLTE_ERROR_ENUM liblte_mme_unpack_identity_request_msg(LIBLTE_BYTE_MSG_STRUCT*           msg,
                                                          LIBLTE_MME_ID_REQUEST_MSG_STRUCT* id_req);
 
@@ -2980,10 +3018,17 @@ typedef struct {
   bool                                       nonce_mme_present;
 } LIBLTE_MME_SECURITY_MODE_COMMAND_MSG_STRUCT;
 // Functions
+LIBLTE_ERROR_ENUM liblte_mme_pack_security_mode_command_msg_mac(LIBLTE_MME_SECURITY_MODE_COMMAND_MSG_STRUCT* sec_mode_cmd,
+                                                            uint8                                        sec_hdr_type,
+                                                            uint32                                       count,
+                                                            LIBLTE_BYTE_MSG_STRUCT*                      msg); //original one
+
 LIBLTE_ERROR_ENUM liblte_mme_pack_security_mode_command_msg(LIBLTE_MME_SECURITY_MODE_COMMAND_MSG_STRUCT* sec_mode_cmd,
                                                             uint8                                        sec_hdr_type,
                                                             uint32                                       count,
-                                                            LIBLTE_BYTE_MSG_STRUCT*                      msg);
+                                                            LIBLTE_BYTE_MSG_STRUCT*                      msg); //for no mac
+
+                                                            
 LIBLTE_ERROR_ENUM
 liblte_mme_unpack_security_mode_command_msg(LIBLTE_BYTE_MSG_STRUCT*                      msg,
                                             LIBLTE_MME_SECURITY_MODE_COMMAND_MSG_STRUCT* sec_mode_cmd);
diff --git a/lib/include/srsran/asn1/nas_5g_ies.h b/lib/include/srsran/asn1/nas_5g_ies.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/nas_5g_msg.h b/lib/include/srsran/asn1/nas_5g_msg.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/nas_5g_utils.h b/lib/include/srsran/asn1/nas_5g_utils.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/ngap.h b/lib/include/srsran/asn1/ngap.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/ngap_utils.h b/lib/include/srsran/asn1/ngap_utils.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/obj_id_cmp_utils.h b/lib/include/srsran/asn1/obj_id_cmp_utils.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/rrc.h b/lib/include/srsran/asn1/rrc.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/rrc/bcch_msg.h b/lib/include/srsran/asn1/rrc/bcch_msg.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/rrc/common.h b/lib/include/srsran/asn1/rrc/common.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/rrc/common_ext.h b/lib/include/srsran/asn1/rrc/common_ext.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/rrc/dl_ccch_msg.h b/lib/include/srsran/asn1/rrc/dl_ccch_msg.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/rrc/dl_dcch_msg.h b/lib/include/srsran/asn1/rrc/dl_dcch_msg.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/rrc/ho_cmd.h b/lib/include/srsran/asn1/rrc/ho_cmd.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/rrc/meascfg.h b/lib/include/srsran/asn1/rrc/meascfg.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/rrc/paging.h b/lib/include/srsran/asn1/rrc/paging.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/rrc/phy_ded.h b/lib/include/srsran/asn1/rrc/phy_ded.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/rrc/rr_common.h b/lib/include/srsran/asn1/rrc/rr_common.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/rrc/rr_ded.h b/lib/include/srsran/asn1/rrc/rr_ded.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/rrc/rrc_asn1.h b/lib/include/srsran/asn1/rrc/rrc_asn1.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/rrc/security.h b/lib/include/srsran/asn1/rrc/security.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/rrc/si.h b/lib/include/srsran/asn1/rrc/si.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/rrc/uecap.h b/lib/include/srsran/asn1/rrc/uecap.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/rrc/ul_ccch_msg.h b/lib/include/srsran/asn1/rrc/ul_ccch_msg.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/rrc/ul_dcch_msg.h b/lib/include/srsran/asn1/rrc/ul_dcch_msg.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/rrc_nbiot.h b/lib/include/srsran/asn1/rrc_nbiot.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/rrc_nr.h b/lib/include/srsran/asn1/rrc_nr.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/rrc_nr_utils.h b/lib/include/srsran/asn1/rrc_nr_utils.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/rrc_utils.h b/lib/include/srsran/asn1/rrc_utils.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/s1ap.h b/lib/include/srsran/asn1/s1ap.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/asn1/s1ap_utils.h b/lib/include/srsran/asn1/s1ap_utils.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/build_info.h.in b/lib/include/srsran/build_info.h.in
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/backtrace.h b/lib/include/srsran/common/backtrace.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/backward.hpp b/lib/include/srsran/common/backward.hpp
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/band_helper.h b/lib/include/srsran/common/band_helper.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/bcd_helpers.h b/lib/include/srsran/common/bcd_helpers.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/bearer_manager.h b/lib/include/srsran/common/bearer_manager.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/block_queue.h b/lib/include/srsran/common/block_queue.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/buffer_pool.h b/lib/include/srsran/common/buffer_pool.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/byte_buffer.h b/lib/include/srsran/common/byte_buffer.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/common.h b/lib/include/srsran/common/common.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/common_helper.h b/lib/include/srsran/common/common_helper.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/common_lte.h b/lib/include/srsran/common/common_lte.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/common_nr.h b/lib/include/srsran/common/common_nr.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/config_file.h b/lib/include/srsran/common/config_file.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/crash_handler.h b/lib/include/srsran/common/crash_handler.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/enb_events.h b/lib/include/srsran/common/enb_events.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/epoll_helper.h b/lib/include/srsran/common/epoll_helper.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/fuzzing.h b/lib/include/srsran/common/fuzzing.h
new file mode 100755
index 000000000..d87ab7fc2
--- /dev/null
+++ b/lib/include/srsran/common/fuzzing.h
@@ -0,0 +1,64 @@
+//
+// Created by rafiul on 9/20/19.
+//
+
+#ifndef SRSRAN_FUZZING_H
+#define SRSRAN_FUZZING_H
+
+// Message types for Fuzzing
+#define FUZZING_MSG_TYPE_ATTACH_REQUEST                     0x01
+#define FUZZING_MSG_TYPE_IDENTITY_REQUEST                   0x02
+#define FUZZING_MSG_TYPE_AUTH_REQUEST                       0x03
+#define FUZZING_MSG_TYPE_SEC_MOD_CMD                        0x04
+#define FUZZING_MSG_TYPE_ATTACH_ACCEPT                      0x05
+#define FUZZING_MSG_TYPE_ATTACH_REJECT                      0x06
+#define FUZZING_MSG_TYPE_AUTH_REJECT                        0x07
+#define FUZZING_MSG_TYPE_DETACH_REQUEST                     0x08
+#define FUZZING_MSG_TYPE_ESM_INFO_REQUEST                   0x09
+#define FUZZING_MSG_TYPE_EMM_INFO                           0xA0
+#define FUZZING_MSG_TYPE_PAGING_TMSI                        0xA1
+#define FUZZING_MSG_TYPE_PAGING_IMSI                        0xA2
+
+#define FUZZING_MSG_TYPE_RRC_RELEASE                        0xA3
+#define FUZZING_MSG_TYPE_IDENTITY_REQUEST_MAC               0xA4
+#define FUZZING_MSG_TYPE_IDENTITY_REQUEST_WMAC              0xA5
+#define FUZZING_MSG_TYPE_IDENTITY_REQUEST_ENCRYPT           0xA6
+#define FUZZING_MSG_TYPE_IDENTITY_REQUEST_REPLAY            0xA7
+#define FUZZING_MSG_TYPE_IDENTITY_REQUEST_ENCRYPT_MAC       0xA8
+#define FUZZING_MSG_TYPE_AUTH_REQUEST_MAC                   0xA9
+#define FUZZING_MSG_TYPE_AUTH_REQUEST_ENCRYPT_MAC           0xB0
+#define FUZZING_MSG_TYPE_AUTH_REQUEST_WMAC                  0xB1
+#define FUZZING_MSG_TYPE_AUTH_REQUEST_ENCRYPT               0xB2
+#define FUZZING_MSG_TYPE_AUTH_REQUEST_REPLAY                0xB3
+#define FUZZING_MSG_TYPE_ATTACH_ACCEPT_MAC                  0xB4
+#define FUZZING_MSG_TYPE_ATTACH_ACCEPT_WMAC                 0xB5
+#define FUZZING_MSG_TYPE_ATTACH_ACCEPT_REPLAY               0xB6
+#define FUZZING_MSG_TYPE_TAU_ACCEPT                         0xB7
+#define FUZZING_MSG_TYPE_GUTI_REALLOCATION                  0xB8
+#define FUZZING_MSG_TYPE_DL_NAS_TRANSPORT                   0xB9
+#define FUZZING_MSG_TYPE_RESET_UL_NAS_COUNT                 0xC0
+#define FUZZING_MSG_TYPE_SECURITY_MODE_COMMAND_REPLAY       0xC1
+#define FUZZING_MSG_TYPE_GUTI_REALLOCATION_PLAIN            0xC2
+#define FUZZING_MSG_TYPE_DL_NAS_TRANSPORT_PLAIN             0xC3
+#define FUZZING_MSG_TYPE_TAU_ACCEPT_PLAIN                   0xC4
+#define FUZZING_MSG_TYPE_GUTI_REALLOCATION_REPLAY           0xC5
+#define FUZZING_MSG_TYPE_DL_NAS_TRANSPORT_REPLAY            0xC6
+#define FUZZING_MSG_TYPE_IDENTITY_REQUEST_IMEI              0xC7
+#define FUZZING_MSG_TYPE_IDENTITY_REQUEST_GUTI              0xC8
+#define FUZZING_MSG_TYPE_EMM_INFO_PLAIN                     0xC9
+#define FUZZING_MSG_TYPE_SERVICE_REJECT                     0xD0
+#define FUZZING_MSG_TYPE_TAU_REJECT                         0xD1
+#define FUZZING_MSG_TYPE_RRC_SECURITY_MODE_COMMAND_REPLAY   0xD2
+#define FUZZING_MSG_TYPE_RRC_SECURITY_MODE_COMMAND_DOWNGRADED 0xD3
+#define FUZZING_MSG_TYPE_ATTACH_ACCEPT_SINGLE 0xD4
+#define FUZZING_MSG_TYPE_ATTACH_ACCEPT_SINGLE_NO_INTEGRITY 0xD5
+#define FUZZING_MSG_TYPE_ATTACH_ACCEPT_SINGLE_NULL_HEADER 0xD6
+#define FUZZING_MSG_TYPE_SEC_MOD_CMD_NO_INTEGRITY 0xD7
+#define FUZZING_MSG_TYPE_SEC_MOD_CMD_PLAIN 0xD8
+#define FUZZING_MSG_TYPE_PAGING_TMSI_IMSI                   0xD9
+#define FUZZING_MSG_TYPE_SEC_MOD_CMD_NS                      0xDA
+#define FUZZING_MSG_TYPE_SEC_MOD_CMD_NS_REPLAY                      0xDB
+#define FUZZING_MSG_TYPE_PAGING_NO_ID                       0xDC
+
+#define FUZZING_MSG_TYPE_EOL                                0xFF
+#endif //SRSLTE_FUZZING_H
diff --git a/lib/include/srsran/common/gen_mch_tables.h b/lib/include/srsran/common/gen_mch_tables.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/int_helpers.h b/lib/include/srsran/common/int_helpers.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/interfaces_common.h b/lib/include/srsran/common/interfaces_common.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/liblte_security.h b/lib/include/srsran/common/liblte_security.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/log_helper.h b/lib/include/srsran/common/log_helper.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/mac_pcap.h b/lib/include/srsran/common/mac_pcap.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/mac_pcap_base.h b/lib/include/srsran/common/mac_pcap_base.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/mac_pcap_net.h b/lib/include/srsran/common/mac_pcap_net.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/metrics_hub.h b/lib/include/srsran/common/metrics_hub.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/multiqueue.h b/lib/include/srsran/common/multiqueue.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/nas_pcap.h b/lib/include/srsran/common/nas_pcap.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/netsource_handler.h b/lib/include/srsran/common/netsource_handler.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/network_utils.h b/lib/include/srsran/common/network_utils.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/ngap_pcap.h b/lib/include/srsran/common/ngap_pcap.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/pcap.h b/lib/include/srsran/common/pcap.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/phy_cfg_nr.h b/lib/include/srsran/common/phy_cfg_nr.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/phy_cfg_nr_default.h b/lib/include/srsran/common/phy_cfg_nr_default.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/rlc_pcap.h b/lib/include/srsran/common/rlc_pcap.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/rwlock_guard.h b/lib/include/srsran/common/rwlock_guard.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/s1ap_pcap.h b/lib/include/srsran/common/s1ap_pcap.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/s3g.h b/lib/include/srsran/common/s3g.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/security.h b/lib/include/srsran/common/security.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/slot_point.h b/lib/include/srsran/common/slot_point.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/ssl.h b/lib/include/srsran/common/ssl.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/stack_procedure.h b/lib/include/srsran/common/stack_procedure.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/standard_streams.h b/lib/include/srsran/common/standard_streams.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/string_helpers.h b/lib/include/srsran/common/string_helpers.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/task_scheduler.h b/lib/include/srsran/common/task_scheduler.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/test_common.h b/lib/include/srsran/common/test_common.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/test_pcap.h b/lib/include/srsran/common/test_pcap.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/thread_pool.h b/lib/include/srsran/common/thread_pool.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/threads.h b/lib/include/srsran/common/threads.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/time_prof.h b/lib/include/srsran/common/time_prof.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/timeout.h b/lib/include/srsran/common/timeout.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/timers.h b/lib/include/srsran/common/timers.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/trace.h b/lib/include/srsran/common/trace.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/tsan_options.h b/lib/include/srsran/common/tsan_options.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/tti_point.h b/lib/include/srsran/common/tti_point.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/tti_sempahore.h b/lib/include/srsran/common/tti_sempahore.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/tti_sync.h b/lib/include/srsran/common/tti_sync.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/tti_sync_cv.h b/lib/include/srsran/common/tti_sync_cv.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/common/zuc.h b/lib/include/srsran/common/zuc.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/config.h b/lib/include/srsran/config.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/interfaces/e2_metrics_interface.h b/lib/include/srsran/interfaces/e2_metrics_interface.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/interfaces/enb_command_interface.h b/lib/include/srsran/interfaces/enb_command_interface.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/interfaces/enb_gtpu_interfaces.h b/lib/include/srsran/interfaces/enb_gtpu_interfaces.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/interfaces/enb_interfaces.h b/lib/include/srsran/interfaces/enb_interfaces.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/interfaces/enb_mac_interfaces.h b/lib/include/srsran/interfaces/enb_mac_interfaces.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/interfaces/enb_metrics_interface.h b/lib/include/srsran/interfaces/enb_metrics_interface.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/interfaces/enb_pdcp_interfaces.h b/lib/include/srsran/interfaces/enb_pdcp_interfaces.h
old mode 100644
new mode 100755
index 26f1e4560..46bbb91f5
--- a/lib/include/srsran/interfaces/enb_pdcp_interfaces.h
+++ b/lib/include/srsran/interfaces/enb_pdcp_interfaces.h
@@ -55,6 +55,10 @@ public:
   virtual bool get_bearer_state(uint16_t rnti, uint32_t lcid, srsran::pdcp_lte_state_t* state)             = 0;
   virtual bool set_bearer_state(uint16_t rnti, uint32_t lcid, const srsran::pdcp_lte_state_t& state)       = 0;
   virtual void reestablish(uint16_t rnti)                                                                  = 0;
+
+  // fuzzing
+  virtual void disable_integrity(uint16_t rnti, uint32_t lcid)                                             = 0;
+  virtual void disable_encryption(uint16_t rnti, uint32_t lcid)                                            = 0;
 };
 
 // PDCP interface for RLC
diff --git a/lib/include/srsran/interfaces/enb_phy_interfaces.h b/lib/include/srsran/interfaces/enb_phy_interfaces.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/interfaces/enb_rlc_interfaces.h b/lib/include/srsran/interfaces/enb_rlc_interfaces.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/interfaces/enb_rrc_interface_mac.h b/lib/include/srsran/interfaces/enb_rrc_interface_mac.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/interfaces/enb_rrc_interface_pdcp.h b/lib/include/srsran/interfaces/enb_rrc_interface_pdcp.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/interfaces/enb_rrc_interface_rlc.h b/lib/include/srsran/interfaces/enb_rrc_interface_rlc.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/interfaces/enb_rrc_interface_s1ap.h b/lib/include/srsran/interfaces/enb_rrc_interface_s1ap.h
old mode 100644
new mode 100755
index b35f144d0..bb73fceaf
--- a/lib/include/srsran/interfaces/enb_rrc_interface_s1ap.h
+++ b/lib/include/srsran/interfaces/enb_rrc_interface_s1ap.h
@@ -43,6 +43,14 @@ public:
   virtual int  get_erab_addr_in(uint16_t rnti, uint16_t erab_id, transp_addr_t& addr_in, uint32_t& teid_in) const  = 0;
   virtual void set_aggregate_max_bitrate(uint16_t rnti, const asn1::s1ap::ue_aggregate_maximum_bitrate_s& bitrate) = 0;
 
+  // fuzzing
+  virtual void rrc_send_ue_capability_enquiry_custom(uint16_t rnti, int integrity, int cipher) = 0;
+  virtual void rrc_send_ue_information_request_custom(uint16_t rnti, int integrity, int cipher) = 0;
+  virtual void rrc_send_counter_check_custom(uint16_t rnti, int integrity, int cipher) = 0;
+  virtual void send_rrc_release_custom(uint16_t rnti, int integrity, int cipher) = 0;
+  virtual void rrc_send_security_mode_command_custom(uint16_t rnti, int integrity, int eia, int eea) = 0;
+  virtual void rrc_send_connection_reconf_custom(uint16_t rnti, int integrity, int cipher, int set_srb2, int set_drb, int meas_config, int replay) = 0;
+
   /**
    * TS 36.413, 8.2.1 and 8.3.1 - Setup E-RAB / Initial Context Setup
    * @return if error, cause argument is updated with cause
diff --git a/lib/include/srsran/interfaces/enb_rrc_interface_types.h b/lib/include/srsran/interfaces/enb_rrc_interface_types.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/interfaces/enb_s1ap_interfaces.h b/lib/include/srsran/interfaces/enb_s1ap_interfaces.h
old mode 100644
new mode 100755
index c6a074a71..60d94fa77
--- a/lib/include/srsran/interfaces/enb_s1ap_interfaces.h
+++ b/lib/include/srsran/interfaces/enb_s1ap_interfaces.h
@@ -76,6 +76,7 @@ public:
   virtual void user_mod(uint16_t old_rnti, uint16_t new_rnti)                             = 0;
   virtual bool user_release(uint16_t rnti, asn1::s1ap::cause_radio_network_e cause_radio) = 0;
   virtual bool is_mme_connected()                                                         = 0;
+  virtual bool notify_response(uint8_t *response, uint16_t size)                          = 0; // fuzzing
 
   // Notify S1AP of RRC reconfiguration successful finish.
   // Many S1AP procedures use this notification to indicate successful end (e.g InitialContextSetupRequest)
@@ -136,6 +137,19 @@ public:
   virtual bool send_ue_cap_info_indication(uint16_t rnti, srsran::unique_byte_buffer_t ue_radio_cap) = 0;
 };
 
+//================================= Fuzzing =============================
+class enodeb_statelearner_interface_s1ap {
+public:
+  virtual bool notify_response(uint8_t *msg, uint16_t len) = 0;
+};
+
+
+class s1ap_interface_enodeb_statelearner {
+public:
+  virtual bool execute_command(uint8_t* msg, uint16_t len) = 0;
+};
+//===================================================================
+
 } // namespace srsenb
 
 #endif // SRSRAN_ENB_S1AP_INTERFACES_H
diff --git a/lib/include/srsran/interfaces/enb_time_interface.h b/lib/include/srsran/interfaces/enb_time_interface.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/interfaces/enb_x2_interfaces.h b/lib/include/srsran/interfaces/enb_x2_interfaces.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/interfaces/epc_interfaces.h b/lib/include/srsran/interfaces/epc_interfaces.h
old mode 100644
new mode 100755
index 8cdc226c0..d3acf60f1
--- a/lib/include/srsran/interfaces/epc_interfaces.h
+++ b/lib/include/srsran/interfaces/epc_interfaces.h
@@ -81,6 +81,10 @@ public:
                                                uint32_t               mme_ue_s1ap_id,
                                                srsran::byte_buffer_t* nas_msg,
                                                struct sctp_sndrcvinfo enb_sri)               = 0;
+
+  //Fuzzing
+  virtual bool     notify_response(uint8_t *msg, uint16_t len)                               = 0;
+  virtual bool     get_mme_statelearner_reset_state()                                        = 0;                                            
 };
 
 class hss_interface_nas // NAS -> HSS
@@ -127,5 +131,20 @@ public:
   virtual bool send_downlink_data_notification(uint32_t spgw_ctr_teid)                         = 0;
 };
 
+// ======================================= FUZZING =======================================//
+class mme_statelearner_interface_s1ap{
+public:
+    virtual bool notify_response(uint8_t *msg, uint16_t len) = 0;
+    virtual void set_mme_statelearner_reset_state() = 0;
+    virtual void reset_mme_statelearner_reset_state() = 0;
+    virtual bool get_mme_statelearner_reset_state() = 0;
+};
+
+
+class s1ap_interface_mme_statelearner{
+public:
+    virtual bool send_query(uint8_t* msg, uint16_t len) = 0;
+};
+
 } // namespace srsepc
 #endif // SRSRAN_EPC_INTERFACES_H
diff --git a/lib/include/srsran/interfaces/gnb_interfaces.h b/lib/include/srsran/interfaces/gnb_interfaces.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/interfaces/gnb_mac_interfaces.h b/lib/include/srsran/interfaces/gnb_mac_interfaces.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/interfaces/gnb_ngap_interfaces.h b/lib/include/srsran/interfaces/gnb_ngap_interfaces.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/interfaces/gnb_rrc_nr_interfaces.h b/lib/include/srsran/interfaces/gnb_rrc_nr_interfaces.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/interfaces/mac_interface_types.h b/lib/include/srsran/interfaces/mac_interface_types.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/interfaces/pdcp_interface_types.h b/lib/include/srsran/interfaces/pdcp_interface_types.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/interfaces/phy_common_interface.h b/lib/include/srsran/interfaces/phy_common_interface.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/interfaces/phy_interface_types.h b/lib/include/srsran/interfaces/phy_interface_types.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/interfaces/radio_interfaces.h b/lib/include/srsran/interfaces/radio_interfaces.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/interfaces/rlc_interface_types.h b/lib/include/srsran/interfaces/rlc_interface_types.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/interfaces/rrc_interface_types.h b/lib/include/srsran/interfaces/rrc_interface_types.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/interfaces/ue_gw_interfaces.h b/lib/include/srsran/interfaces/ue_gw_interfaces.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/interfaces/ue_interfaces.h b/lib/include/srsran/interfaces/ue_interfaces.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/interfaces/ue_mac_interfaces.h b/lib/include/srsran/interfaces/ue_mac_interfaces.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/interfaces/ue_nas_interfaces.h b/lib/include/srsran/interfaces/ue_nas_interfaces.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/interfaces/ue_nr_interfaces.h b/lib/include/srsran/interfaces/ue_nr_interfaces.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/interfaces/ue_pdcp_interfaces.h b/lib/include/srsran/interfaces/ue_pdcp_interfaces.h
old mode 100644
new mode 100755
index d2f7e07d0..40c20f467
--- a/lib/include/srsran/interfaces/ue_pdcp_interfaces.h
+++ b/lib/include/srsran/interfaces/ue_pdcp_interfaces.h
@@ -45,6 +45,10 @@ public:
                                  srsran::srsran_direction_t direction = srsran::srsran_direction_t::DIRECTION_TXRX) = 0;
   virtual void send_status_report()                                                                                 = 0;
   virtual void send_status_report(uint32_t lcid)                                                                    = 0;
+
+  // fuzzing
+  virtual void disable_integrity(uint32_t lcid)                                                                     = 0;
+  virtual void disable_encryption(uint32_t lcid)                                                                    = 0;
 };
 
 class pdcp_interface_rlc
diff --git a/lib/include/srsran/interfaces/ue_phy_interfaces.h b/lib/include/srsran/interfaces/ue_phy_interfaces.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/interfaces/ue_rlc_interfaces.h b/lib/include/srsran/interfaces/ue_rlc_interfaces.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/interfaces/ue_rrc_interfaces.h b/lib/include/srsran/interfaces/ue_rrc_interfaces.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/interfaces/ue_sdap_interfaces.h b/lib/include/srsran/interfaces/ue_sdap_interfaces.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/interfaces/ue_usim_interfaces.h b/lib/include/srsran/interfaces/ue_usim_interfaces.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/mac/bsr_nr.h b/lib/include/srsran/mac/bsr_nr.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/mac/mac_rar_pdu_nr.h b/lib/include/srsran/mac/mac_rar_pdu_nr.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/mac/mac_sch_pdu_nr.h b/lib/include/srsran/mac/mac_sch_pdu_nr.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/mac/pdu.h b/lib/include/srsran/mac/pdu.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/mac/pdu_queue.h b/lib/include/srsran/mac/pdu_queue.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/agc/agc.h b/lib/include/srsran/phy/agc/agc.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/cfr/cfr.h b/lib/include/srsran/phy/cfr/cfr.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/ch_estimation/chest_common.h b/lib/include/srsran/phy/ch_estimation/chest_common.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/ch_estimation/chest_dl.h b/lib/include/srsran/phy/ch_estimation/chest_dl.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/ch_estimation/chest_dl_nbiot.h b/lib/include/srsran/phy/ch_estimation/chest_dl_nbiot.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/ch_estimation/chest_sl.h b/lib/include/srsran/phy/ch_estimation/chest_sl.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/ch_estimation/chest_ul.h b/lib/include/srsran/phy/ch_estimation/chest_ul.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/ch_estimation/csi_rs.h b/lib/include/srsran/phy/ch_estimation/csi_rs.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/ch_estimation/csi_rs_cfg.h b/lib/include/srsran/phy/ch_estimation/csi_rs_cfg.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/ch_estimation/dmrs_pbch.h b/lib/include/srsran/phy/ch_estimation/dmrs_pbch.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/ch_estimation/dmrs_pdcch.h b/lib/include/srsran/phy/ch_estimation/dmrs_pdcch.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/ch_estimation/dmrs_pucch.h b/lib/include/srsran/phy/ch_estimation/dmrs_pucch.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/ch_estimation/dmrs_sch.h b/lib/include/srsran/phy/ch_estimation/dmrs_sch.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/ch_estimation/refsignal_dl.h b/lib/include/srsran/phy/ch_estimation/refsignal_dl.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/ch_estimation/refsignal_dl_nbiot.h b/lib/include/srsran/phy/ch_estimation/refsignal_dl_nbiot.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/ch_estimation/refsignal_ul.h b/lib/include/srsran/phy/ch_estimation/refsignal_ul.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/ch_estimation/wiener_dl.h b/lib/include/srsran/phy/ch_estimation/wiener_dl.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/channel/ch_awgn.h b/lib/include/srsran/phy/channel/ch_awgn.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/channel/channel.h b/lib/include/srsran/phy/channel/channel.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/channel/delay.h b/lib/include/srsran/phy/channel/delay.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/channel/fading.h b/lib/include/srsran/phy/channel/fading.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/channel/hst.h b/lib/include/srsran/phy/channel/hst.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/channel/rlf.h b/lib/include/srsran/phy/channel/rlf.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/common/phy_common.h b/lib/include/srsran/phy/common/phy_common.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/common/phy_common_nr.h b/lib/include/srsran/phy/common/phy_common_nr.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/common/phy_common_sl.h b/lib/include/srsran/phy/common/phy_common_sl.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/common/sequence.h b/lib/include/srsran/phy/common/sequence.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/common/sliv.h b/lib/include/srsran/phy/common/sliv.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/common/timestamp.h b/lib/include/srsran/phy/common/timestamp.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/common/zc_sequence.h b/lib/include/srsran/phy/common/zc_sequence.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/dft/dft.h b/lib/include/srsran/phy/dft/dft.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/dft/dft_precoding.h b/lib/include/srsran/phy/dft/dft_precoding.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/dft/ofdm.h b/lib/include/srsran/phy/dft/ofdm.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/enb/enb_dl.h b/lib/include/srsran/phy/enb/enb_dl.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/enb/enb_ul.h b/lib/include/srsran/phy/enb/enb_ul.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/fec/block/block.h b/lib/include/srsran/phy/fec/block/block.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/fec/cbsegm.h b/lib/include/srsran/phy/fec/cbsegm.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/fec/convolutional/convcoder.h b/lib/include/srsran/phy/fec/convolutional/convcoder.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/fec/convolutional/rm_conv.h b/lib/include/srsran/phy/fec/convolutional/rm_conv.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/fec/convolutional/viterbi.h b/lib/include/srsran/phy/fec/convolutional/viterbi.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/fec/crc.h b/lib/include/srsran/phy/fec/crc.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/fec/ldpc/base_graph.h b/lib/include/srsran/phy/fec/ldpc/base_graph.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/fec/ldpc/ldpc_common.h b/lib/include/srsran/phy/fec/ldpc/ldpc_common.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/fec/ldpc/ldpc_decoder.h b/lib/include/srsran/phy/fec/ldpc/ldpc_decoder.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/fec/ldpc/ldpc_encoder.h b/lib/include/srsran/phy/fec/ldpc/ldpc_encoder.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/fec/ldpc/ldpc_rm.h b/lib/include/srsran/phy/fec/ldpc/ldpc_rm.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/fec/polar/polar_chanalloc.h b/lib/include/srsran/phy/fec/polar/polar_chanalloc.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/fec/polar/polar_code.h b/lib/include/srsran/phy/fec/polar/polar_code.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/fec/polar/polar_decoder.h b/lib/include/srsran/phy/fec/polar/polar_decoder.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/fec/polar/polar_encoder.h b/lib/include/srsran/phy/fec/polar/polar_encoder.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/fec/polar/polar_interleaver.h b/lib/include/srsran/phy/fec/polar/polar_interleaver.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/fec/polar/polar_rm.h b/lib/include/srsran/phy/fec/polar/polar_rm.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/fec/polar/test/polar_sets.h b/lib/include/srsran/phy/fec/polar/test/polar_sets.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/fec/polar/test/subchannel_allocation.h b/lib/include/srsran/phy/fec/polar/test/subchannel_allocation.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/fec/softbuffer.h b/lib/include/srsran/phy/fec/softbuffer.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/fec/turbo/rm_turbo.h b/lib/include/srsran/phy/fec/turbo/rm_turbo.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/fec/turbo/tc_interl.h b/lib/include/srsran/phy/fec/turbo/tc_interl.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/fec/turbo/turbocoder.h b/lib/include/srsran/phy/fec/turbo/turbocoder.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/fec/turbo/turbodecoder.h b/lib/include/srsran/phy/fec/turbo/turbodecoder.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/fec/turbo/turbodecoder_gen.h b/lib/include/srsran/phy/fec/turbo/turbodecoder_gen.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/fec/turbo/turbodecoder_impl.h b/lib/include/srsran/phy/fec/turbo/turbodecoder_impl.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/fec/turbo/turbodecoder_iter.h b/lib/include/srsran/phy/fec/turbo/turbodecoder_iter.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/fec/turbo/turbodecoder_sse.h b/lib/include/srsran/phy/fec/turbo/turbodecoder_sse.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/fec/turbo/turbodecoder_win.h b/lib/include/srsran/phy/fec/turbo/turbodecoder_win.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/gnb/gnb_dl.h b/lib/include/srsran/phy/gnb/gnb_dl.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/gnb/gnb_ul.h b/lib/include/srsran/phy/gnb/gnb_ul.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/io/binsource.h b/lib/include/srsran/phy/io/binsource.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/io/filesink.h b/lib/include/srsran/phy/io/filesink.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/io/filesource.h b/lib/include/srsran/phy/io/filesource.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/io/format.h b/lib/include/srsran/phy/io/format.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/io/netsink.h b/lib/include/srsran/phy/io/netsink.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/io/netsource.h b/lib/include/srsran/phy/io/netsource.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/mimo/layermap.h b/lib/include/srsran/phy/mimo/layermap.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/mimo/precoding.h b/lib/include/srsran/phy/mimo/precoding.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/modem/demod_hard.h b/lib/include/srsran/phy/modem/demod_hard.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/modem/demod_soft.h b/lib/include/srsran/phy/modem/demod_soft.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/modem/evm.h b/lib/include/srsran/phy/modem/evm.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/modem/mod.h b/lib/include/srsran/phy/modem/mod.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/modem/modem_table.h b/lib/include/srsran/phy/modem/modem_table.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/cqi.h b/lib/include/srsran/phy/phch/cqi.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/csi.h b/lib/include/srsran/phy/phch/csi.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/csi_cfg.h b/lib/include/srsran/phy/phch/csi_cfg.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/dci.h b/lib/include/srsran/phy/phch/dci.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/dci_nbiot.h b/lib/include/srsran/phy/phch/dci_nbiot.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/dci_nr.h b/lib/include/srsran/phy/phch/dci_nr.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/harq_ack.h b/lib/include/srsran/phy/phch/harq_ack.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/harq_ack_cfg.h b/lib/include/srsran/phy/phch/harq_ack_cfg.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/mib_sl.h b/lib/include/srsran/phy/phch/mib_sl.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/npbch.h b/lib/include/srsran/phy/phch/npbch.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/npdcch.h b/lib/include/srsran/phy/phch/npdcch.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/npdsch.h b/lib/include/srsran/phy/phch/npdsch.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/npdsch_cfg.h b/lib/include/srsran/phy/phch/npdsch_cfg.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/pbch.h b/lib/include/srsran/phy/phch/pbch.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/pbch_msg_nr.h b/lib/include/srsran/phy/phch/pbch_msg_nr.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/pbch_nr.h b/lib/include/srsran/phy/phch/pbch_nr.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/pcfich.h b/lib/include/srsran/phy/phch/pcfich.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/pdcch.h b/lib/include/srsran/phy/phch/pdcch.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/pdcch_cfg_nr.h b/lib/include/srsran/phy/phch/pdcch_cfg_nr.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/pdcch_nr.h b/lib/include/srsran/phy/phch/pdcch_nr.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/pdsch.h b/lib/include/srsran/phy/phch/pdsch.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/pdsch_cfg.h b/lib/include/srsran/phy/phch/pdsch_cfg.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/pdsch_nr.h b/lib/include/srsran/phy/phch/pdsch_nr.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/phch_cfg_nr.h b/lib/include/srsran/phy/phch/phch_cfg_nr.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/phich.h b/lib/include/srsran/phy/phch/phich.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/pmch.h b/lib/include/srsran/phy/phch/pmch.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/prach.h b/lib/include/srsran/phy/phch/prach.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/psbch.h b/lib/include/srsran/phy/phch/psbch.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/pscch.h b/lib/include/srsran/phy/phch/pscch.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/pssch.h b/lib/include/srsran/phy/phch/pssch.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/pucch.h b/lib/include/srsran/phy/phch/pucch.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/pucch_cfg.h b/lib/include/srsran/phy/phch/pucch_cfg.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/pucch_cfg_nr.h b/lib/include/srsran/phy/phch/pucch_cfg_nr.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/pucch_nr.h b/lib/include/srsran/phy/phch/pucch_nr.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/pucch_proc.h b/lib/include/srsran/phy/phch/pucch_proc.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/pusch.h b/lib/include/srsran/phy/phch/pusch.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/pusch_cfg.h b/lib/include/srsran/phy/phch/pusch_cfg.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/pusch_nr.h b/lib/include/srsran/phy/phch/pusch_nr.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/ra.h b/lib/include/srsran/phy/phch/ra.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/ra_dl.h b/lib/include/srsran/phy/phch/ra_dl.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/ra_dl_nr.h b/lib/include/srsran/phy/phch/ra_dl_nr.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/ra_nbiot.h b/lib/include/srsran/phy/phch/ra_nbiot.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/ra_nr.h b/lib/include/srsran/phy/phch/ra_nr.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/ra_sl.h b/lib/include/srsran/phy/phch/ra_sl.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/ra_ul.h b/lib/include/srsran/phy/phch/ra_ul.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/ra_ul_nr.h b/lib/include/srsran/phy/phch/ra_ul_nr.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/regs.h b/lib/include/srsran/phy/phch/regs.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/sch.h b/lib/include/srsran/phy/phch/sch.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/sch_cfg_nr.h b/lib/include/srsran/phy/phch/sch_cfg_nr.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/sch_nr.h b/lib/include/srsran/phy/phch/sch_nr.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/sci.h b/lib/include/srsran/phy/phch/sci.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/uci.h b/lib/include/srsran/phy/phch/uci.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/uci_cfg.h b/lib/include/srsran/phy/phch/uci_cfg.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/uci_cfg_nr.h b/lib/include/srsran/phy/phch/uci_cfg_nr.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/phch/uci_nr.h b/lib/include/srsran/phy/phch/uci_nr.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/resampling/decim.h b/lib/include/srsran/phy/resampling/decim.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/resampling/interp.h b/lib/include/srsran/phy/resampling/interp.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/resampling/resample_arb.h b/lib/include/srsran/phy/resampling/resample_arb.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/resampling/resampler.h b/lib/include/srsran/phy/resampling/resampler.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/rf/rf.h b/lib/include/srsran/phy/rf/rf.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/rf/rf_utils.h b/lib/include/srsran/phy/rf/rf_utils.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/scrambling/scrambling.h b/lib/include/srsran/phy/scrambling/scrambling.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/sync/cfo.h b/lib/include/srsran/phy/sync/cfo.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/sync/cp.h b/lib/include/srsran/phy/sync/cp.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/sync/npss.h b/lib/include/srsran/phy/sync/npss.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/sync/nsss.h b/lib/include/srsran/phy/sync/nsss.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/sync/pss.h b/lib/include/srsran/phy/sync/pss.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/sync/pss_nr.h b/lib/include/srsran/phy/sync/pss_nr.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/sync/psss.h b/lib/include/srsran/phy/sync/psss.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/sync/refsignal_dl_sync.h b/lib/include/srsran/phy/sync/refsignal_dl_sync.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/sync/sfo.h b/lib/include/srsran/phy/sync/sfo.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/sync/ssb.h b/lib/include/srsran/phy/sync/ssb.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/sync/sss.h b/lib/include/srsran/phy/sync/sss.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/sync/sss_nr.h b/lib/include/srsran/phy/sync/sss_nr.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/sync/ssss.h b/lib/include/srsran/phy/sync/ssss.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/sync/sync.h b/lib/include/srsran/phy/sync/sync.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/sync/sync_nbiot.h b/lib/include/srsran/phy/sync/sync_nbiot.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/ue/ue_cell_search.h b/lib/include/srsran/phy/ue/ue_cell_search.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/ue/ue_cell_search_nbiot.h b/lib/include/srsran/phy/ue/ue_cell_search_nbiot.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/ue/ue_dl.h b/lib/include/srsran/phy/ue/ue_dl.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/ue/ue_dl_nbiot.h b/lib/include/srsran/phy/ue/ue_dl_nbiot.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/ue/ue_dl_nr.h b/lib/include/srsran/phy/ue/ue_dl_nr.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/ue/ue_mib.h b/lib/include/srsran/phy/ue/ue_mib.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/ue/ue_mib_nbiot.h b/lib/include/srsran/phy/ue/ue_mib_nbiot.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/ue/ue_mib_sl.h b/lib/include/srsran/phy/ue/ue_mib_sl.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/ue/ue_phy.h b/lib/include/srsran/phy/ue/ue_phy.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/ue/ue_sync.h b/lib/include/srsran/phy/ue/ue_sync.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/ue/ue_sync_nbiot.h b/lib/include/srsran/phy/ue/ue_sync_nbiot.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/ue/ue_sync_nr.h b/lib/include/srsran/phy/ue/ue_sync_nr.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/ue/ue_ul.h b/lib/include/srsran/phy/ue/ue_ul.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/ue/ue_ul_nr.h b/lib/include/srsran/phy/ue/ue_ul_nr.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/utils/bit.h b/lib/include/srsran/phy/utils/bit.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/utils/cexptab.h b/lib/include/srsran/phy/utils/cexptab.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/utils/convolution.h b/lib/include/srsran/phy/utils/convolution.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/utils/debug.h b/lib/include/srsran/phy/utils/debug.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/utils/filter.h b/lib/include/srsran/phy/utils/filter.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/utils/mat.h b/lib/include/srsran/phy/utils/mat.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/utils/phy_logger.h b/lib/include/srsran/phy/utils/phy_logger.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/utils/primes.h b/lib/include/srsran/phy/utils/primes.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/utils/random.h b/lib/include/srsran/phy/utils/random.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/utils/re_pattern.h b/lib/include/srsran/phy/utils/re_pattern.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/utils/ringbuffer.h b/lib/include/srsran/phy/utils/ringbuffer.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/utils/simd.h b/lib/include/srsran/phy/utils/simd.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/utils/vector.h b/lib/include/srsran/phy/utils/vector.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/phy/utils/vector_simd.h b/lib/include/srsran/phy/utils/vector_simd.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/radio/channel_mapping.h b/lib/include/srsran/radio/channel_mapping.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/radio/radio.h b/lib/include/srsran/radio/radio.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/radio/radio_base.h b/lib/include/srsran/radio/radio_base.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/radio/radio_dummy.h b/lib/include/srsran/radio/radio_dummy.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/radio/radio_metrics.h b/lib/include/srsran/radio/radio_metrics.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/radio/radio_null.h b/lib/include/srsran/radio/radio_null.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/radio/rf_buffer.h b/lib/include/srsran/radio/rf_buffer.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/radio/rf_timestamp.h b/lib/include/srsran/radio/rf_timestamp.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/rlc/bearer_mem_pool.h b/lib/include/srsran/rlc/bearer_mem_pool.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/rlc/rlc.h b/lib/include/srsran/rlc/rlc.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/rlc/rlc_am_base.h b/lib/include/srsran/rlc/rlc_am_base.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/rlc/rlc_am_data_structs.h b/lib/include/srsran/rlc/rlc_am_data_structs.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/rlc/rlc_am_lte.h b/lib/include/srsran/rlc/rlc_am_lte.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/rlc/rlc_am_lte_packing.h b/lib/include/srsran/rlc/rlc_am_lte_packing.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/rlc/rlc_am_nr.h b/lib/include/srsran/rlc/rlc_am_nr.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/rlc/rlc_am_nr_packing.h b/lib/include/srsran/rlc/rlc_am_nr_packing.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/rlc/rlc_common.h b/lib/include/srsran/rlc/rlc_common.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/rlc/rlc_metrics.h b/lib/include/srsran/rlc/rlc_metrics.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/rlc/rlc_tm.h b/lib/include/srsran/rlc/rlc_tm.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/rlc/rlc_um_base.h b/lib/include/srsran/rlc/rlc_um_base.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/rlc/rlc_um_lte.h b/lib/include/srsran/rlc/rlc_um_lte.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/rlc/rlc_um_nr.h b/lib/include/srsran/rlc/rlc_um_nr.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/rrc/rrc_common.h b/lib/include/srsran/rrc/rrc_common.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/srslog/bundled/fmt/LICENSE.rst b/lib/include/srsran/srslog/bundled/fmt/LICENSE.rst
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/srslog/bundled/fmt/chrono.h b/lib/include/srsran/srslog/bundled/fmt/chrono.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/srslog/bundled/fmt/color.h b/lib/include/srsran/srslog/bundled/fmt/color.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/srslog/bundled/fmt/compile.h b/lib/include/srsran/srslog/bundled/fmt/compile.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/srslog/bundled/fmt/core.h b/lib/include/srsran/srslog/bundled/fmt/core.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/srslog/bundled/fmt/format-inl.h b/lib/include/srsran/srslog/bundled/fmt/format-inl.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/srslog/bundled/fmt/format.h b/lib/include/srsran/srslog/bundled/fmt/format.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/srslog/bundled/fmt/locale.h b/lib/include/srsran/srslog/bundled/fmt/locale.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/srslog/bundled/fmt/os.h b/lib/include/srsran/srslog/bundled/fmt/os.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/srslog/bundled/fmt/ostream.h b/lib/include/srsran/srslog/bundled/fmt/ostream.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/srslog/bundled/fmt/posix.h b/lib/include/srsran/srslog/bundled/fmt/posix.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/srslog/bundled/fmt/printf.h b/lib/include/srsran/srslog/bundled/fmt/printf.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/srslog/bundled/fmt/ranges.h b/lib/include/srsran/srslog/bundled/fmt/ranges.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/srslog/context.h b/lib/include/srsran/srslog/context.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/srslog/detail/log_backend.h b/lib/include/srsran/srslog/detail/log_backend.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/srslog/detail/log_entry.h b/lib/include/srsran/srslog/detail/log_entry.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/srslog/detail/log_entry_metadata.h b/lib/include/srsran/srslog/detail/log_entry_metadata.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/srslog/detail/support/any.h b/lib/include/srsran/srslog/detail/support/any.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/srslog/detail/support/backend_capacity.h b/lib/include/srsran/srslog/detail/support/backend_capacity.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/srslog/detail/support/dyn_arg_store_pool.h b/lib/include/srsran/srslog/detail/support/dyn_arg_store_pool.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/srslog/detail/support/error_string.h b/lib/include/srsran/srslog/detail/support/error_string.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/srslog/detail/support/memory_buffer.h b/lib/include/srsran/srslog/detail/support/memory_buffer.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/srslog/detail/support/thread_utils.h b/lib/include/srsran/srslog/detail/support/thread_utils.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/srslog/detail/support/tmp_utils.h b/lib/include/srsran/srslog/detail/support/tmp_utils.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/srslog/detail/support/work_queue.h b/lib/include/srsran/srslog/detail/support/work_queue.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/srslog/event_trace.h b/lib/include/srsran/srslog/event_trace.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/srslog/formatter.h b/lib/include/srsran/srslog/formatter.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/srslog/log_channel.h b/lib/include/srsran/srslog/log_channel.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/srslog/logger.h b/lib/include/srsran/srslog/logger.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/srslog/shared_types.h b/lib/include/srsran/srslog/shared_types.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/srslog/sink.h b/lib/include/srsran/srslog/sink.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/srslog/srslog.h b/lib/include/srsran/srslog/srslog.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/srslog/srslog_c.h b/lib/include/srsran/srslog/srslog_c.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/srsran.h b/lib/include/srsran/srsran.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/support/emergency_handlers.h b/lib/include/srsran/support/emergency_handlers.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/support/signal_handler.h b/lib/include/srsran/support/signal_handler.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/support/srsran_assert.h b/lib/include/srsran/support/srsran_assert.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/support/srsran_test.h b/lib/include/srsran/support/srsran_test.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/system/sys_metrics.h b/lib/include/srsran/system/sys_metrics.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/system/sys_metrics_processor.h b/lib/include/srsran/system/sys_metrics_processor.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/test/ue_test_interfaces.h b/lib/include/srsran/test/ue_test_interfaces.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/upper/byte_buffer_queue.h b/lib/include/srsran/upper/byte_buffer_queue.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/upper/gtpu.h b/lib/include/srsran/upper/gtpu.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/upper/ipv6.h b/lib/include/srsran/upper/ipv6.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/upper/pdcp.h b/lib/include/srsran/upper/pdcp.h
old mode 100644
new mode 100755
index 0074fdbd3..313fd47cb
--- a/lib/include/srsran/upper/pdcp.h
+++ b/lib/include/srsran/upper/pdcp.h
@@ -62,6 +62,10 @@ public:
   void send_status_report() override;
   void send_status_report(uint32_t lcid) override;
 
+  // fuzzing
+  void disable_integrity(uint32_t lcid) override;
+  void disable_encryption(uint32_t lcid) override;
+
   // RLC interface
   void write_pdu(uint32_t lcid, unique_byte_buffer_t sdu) override;
   void write_pdu_mch(uint32_t lcid, unique_byte_buffer_t sdu) override;
diff --git a/lib/include/srsran/upper/pdcp_entity_base.h b/lib/include/srsran/upper/pdcp_entity_base.h
old mode 100644
new mode 100755
index 7ebf95f68..4bb44d44e
--- a/lib/include/srsran/upper/pdcp_entity_base.h
+++ b/lib/include/srsran/upper/pdcp_entity_base.h
@@ -101,6 +101,19 @@ public:
     logger.debug("Enabled encryption. LCID=%d, encryption=%s", lcid, srsran_direction_text[integrity_direction]);
   }
 
+  // fuzzing
+  void disable_integrity()
+  {
+    integrity_direction = DIRECTION_NONE;
+    logger.debug("Disable integrity. LCID=%d, integrity=%s", lcid, srsran_direction_text[integrity_direction]);
+  }
+
+  void disable_encryption()
+  {
+    encryption_direction = DIRECTION_NONE; //set as None probably means disable encryption
+    logger.debug("Disable encryption. LCID=%d, encryption=%s", lcid, srsran_direction_text[encryption_direction]);
+  }
+
   void enable_security_timed(srsran_direction_t direction, uint32_t sn)
   {
     switch (direction) {
diff --git a/lib/include/srsran/upper/pdcp_entity_lte.h b/lib/include/srsran/upper/pdcp_entity_lte.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/upper/pdcp_entity_nr.h b/lib/include/srsran/upper/pdcp_entity_nr.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/upper/pdcp_metrics.h b/lib/include/srsran/upper/pdcp_metrics.h
old mode 100644
new mode 100755
diff --git a/lib/include/srsran/version.h.in b/lib/include/srsran/version.h.in
old mode 100644
new mode 100755
diff --git a/lib/src/CMakeLists.txt b/lib/src/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/asn1/CMakeLists.txt b/lib/src/asn1/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/asn1/asn1_utils.cc b/lib/src/asn1/asn1_utils.cc
old mode 100644
new mode 100755
diff --git a/lib/src/asn1/e2ap.cpp b/lib/src/asn1/e2ap.cpp
old mode 100644
new mode 100755
diff --git a/lib/src/asn1/e2sm.cpp b/lib/src/asn1/e2sm.cpp
old mode 100644
new mode 100755
diff --git a/lib/src/asn1/e2sm_kpm.cpp b/lib/src/asn1/e2sm_kpm.cpp
old mode 100644
new mode 100755
diff --git a/lib/src/asn1/e2sm_kpm_v2.cpp b/lib/src/asn1/e2sm_kpm_v2.cpp
old mode 100644
new mode 100755
diff --git a/lib/src/asn1/gtpc.cc b/lib/src/asn1/gtpc.cc
old mode 100644
new mode 100755
diff --git a/lib/src/asn1/liblte_common.cc b/lib/src/asn1/liblte_common.cc
old mode 100644
new mode 100755
diff --git a/lib/src/asn1/liblte_mme.cc b/lib/src/asn1/liblte_mme.cc
old mode 100644
new mode 100755
index cfaab0f7d..10ad4dc18
--- a/lib/src/asn1/liblte_mme.cc
+++ b/lib/src/asn1/liblte_mme.cc
@@ -4486,17 +4486,18 @@ LIBLTE_ERROR_ENUM liblte_mme_pack_security_protected_nas_msg(LIBLTE_BYTE_MSG_STR
 
     Document Reference: 24.301 v10.2.0 Section 8.2.1
 *********************************************************************/
-LIBLTE_ERROR_ENUM liblte_mme_pack_attach_accept_msg(LIBLTE_MME_ATTACH_ACCEPT_MSG_STRUCT* attach_accept,
+LIBLTE_ERROR_ENUM liblte_mme_pack_attach_accept_msg_mac(LIBLTE_MME_ATTACH_ACCEPT_MSG_STRUCT* attach_accept,
                                                     uint8                                sec_hdr_type,
                                                     uint32                               count,
                                                     LIBLTE_BYTE_MSG_STRUCT*              msg)
 {
+  //original function
   bzero(msg, sizeof(LIBLTE_BYTE_MSG_STRUCT));
   LIBLTE_ERROR_ENUM err     = LIBLTE_ERROR_INVALID_INPUTS;
   uint8*            msg_ptr = msg->msg;
 
   if (attach_accept != NULL && msg != NULL) {
-    if (LIBLTE_MME_SECURITY_HDR_TYPE_PLAIN_NAS != sec_hdr_type) {
+    // if (LIBLTE_MME_SECURITY_HDR_TYPE_PLAIN_NAS != sec_hdr_type) {
       // Protocol Discriminator and Security Header Type
       *msg_ptr = (sec_hdr_type << 4) | (LIBLTE_MME_PD_EPS_MOBILITY_MANAGEMENT);
       msg_ptr++;
@@ -4507,8 +4508,139 @@ LIBLTE_ERROR_ENUM liblte_mme_pack_attach_accept_msg(LIBLTE_MME_ATTACH_ACCEPT_MSG
       // Sequence Number
       *msg_ptr = count & 0xFF;
       msg_ptr++;
+    // }
+
+    // Protocol Discriminator and Security Header Type
+    *msg_ptr = (LIBLTE_MME_SECURITY_HDR_TYPE_PLAIN_NAS << 4) | (LIBLTE_MME_PD_EPS_MOBILITY_MANAGEMENT);
+    msg_ptr++;
+
+    // Message Type
+    *msg_ptr = LIBLTE_MME_MSG_TYPE_ATTACH_ACCEPT;
+    msg_ptr++;
+
+    // EPS Attach Result & Spare Half Octet
+    *msg_ptr = 0;
+    liblte_mme_pack_eps_attach_result_ie(attach_accept->eps_attach_result, 0, &msg_ptr);
+    msg_ptr++;
+
+    // T3412 Value
+    liblte_mme_pack_gprs_timer_ie(&attach_accept->t3412, &msg_ptr);
+
+    // TAI List
+    liblte_mme_pack_tracking_area_identity_list_ie(&attach_accept->tai_list, &msg_ptr);
+
+    // ESM Message Container
+    liblte_mme_pack_esm_message_container_ie(&attach_accept->esm_msg, &msg_ptr);
+
+    // GUTI
+    if (attach_accept->guti_present) {
+      *msg_ptr = LIBLTE_MME_GUTI_IEI;
+      msg_ptr++;
+      liblte_mme_pack_eps_mobile_id_ie(&attach_accept->guti, &msg_ptr);
+    }
+
+    // Location Area Identification
+    if (attach_accept->lai_present) {
+      *msg_ptr = LIBLTE_MME_LOCATION_AREA_IDENTIFICATION_IEI;
+      msg_ptr++;
+      liblte_mme_pack_location_area_id_ie(&attach_accept->lai, &msg_ptr);
+    }
+
+    // MS Identity
+    if (attach_accept->ms_id_present) {
+      *msg_ptr = LIBLTE_MME_MS_IDENTITY_IEI;
+      msg_ptr++;
+      liblte_mme_pack_mobile_id_ie(&attach_accept->ms_id, &msg_ptr);
+    }
+
+    // EMM Cause
+    if (attach_accept->emm_cause_present) {
+      *msg_ptr = LIBLTE_MME_EMM_CAUSE_IEI;
+      msg_ptr++;
+      liblte_mme_pack_emm_cause_ie(attach_accept->emm_cause, &msg_ptr);
+    }
+
+    // T3402 Value
+    if (attach_accept->t3402_present) {
+      *msg_ptr = LIBLTE_MME_T3402_VALUE_IEI;
+      msg_ptr++;
+      liblte_mme_pack_gprs_timer_ie(&attach_accept->t3402, &msg_ptr);
+    }
+
+    // T3423 Value
+    if (attach_accept->t3423_present) {
+      *msg_ptr = LIBLTE_MME_T3423_VALUE_IEI;
+      msg_ptr++;
+      liblte_mme_pack_gprs_timer_ie(&attach_accept->t3423, &msg_ptr);
+    }
+
+    // Equivalent PLMNs
+    if (attach_accept->equivalent_plmns_present) {
+      *msg_ptr = LIBLTE_MME_EQUIVALENT_PLMNS_IEI;
+      msg_ptr++;
+      liblte_mme_pack_plmn_list_ie(&attach_accept->equivalent_plmns, &msg_ptr);
+    }
+
+    // Emergency Number List
+    if (attach_accept->emerg_num_list_present) {
+      *msg_ptr = LIBLTE_MME_EMERGENCY_NUMBER_LIST_IEI;
+      msg_ptr++;
+      liblte_mme_pack_emergency_number_list_ie(&attach_accept->emerg_num_list, &msg_ptr);
+    }
+
+    // EPS Network Feature Support
+    if (attach_accept->eps_network_feature_support_present) {
+      *msg_ptr = LIBLTE_MME_EPS_NETWORK_FEATURE_SUPPORT_IEI;
+      msg_ptr++;
+      liblte_mme_pack_eps_network_feature_support_ie(&attach_accept->eps_network_feature_support, &msg_ptr);
+    }
+
+    // Additional Update Result
+    if (attach_accept->additional_update_result_present) {
+      *msg_ptr = LIBLTE_MME_ADDITIONAL_UPDATE_RESULT_IEI << 4;
+      liblte_mme_pack_additional_update_result_ie(attach_accept->additional_update_result, 0, &msg_ptr);
+      msg_ptr++;
+    }
+
+    // T3412 Extended Value
+    if (attach_accept->t3412_ext_present) {
+      *msg_ptr = LIBLTE_MME_T3412_EXTENDED_VALUE_IEI;
+      msg_ptr++;
+      liblte_mme_pack_gprs_timer_3_ie(&attach_accept->t3412_ext, &msg_ptr);
     }
 
+    // Fill in the number of bytes used
+    msg->N_bytes = msg_ptr - msg->msg;
+
+    err = LIBLTE_SUCCESS;
+  }
+
+  return (err);
+}
+
+LIBLTE_ERROR_ENUM liblte_mme_pack_attach_accept_msg(LIBLTE_MME_ATTACH_ACCEPT_MSG_STRUCT* attach_accept,
+                                                    uint8                                sec_hdr_type,
+                                                    uint32                               count,
+                                                    LIBLTE_BYTE_MSG_STRUCT*              msg)
+{
+  bzero(msg, sizeof(LIBLTE_BYTE_MSG_STRUCT));
+  LIBLTE_ERROR_ENUM err     = LIBLTE_ERROR_INVALID_INPUTS;
+  uint8*            msg_ptr = msg->msg;
+
+  if (attach_accept != NULL && msg != NULL) {
+    // if (LIBLTE_MME_SECURITY_HDR_TYPE_PLAIN_NAS != sec_hdr_type) {
+      // Protocol Discriminator and Security Header Type
+      *msg_ptr = (sec_hdr_type << 4) | (LIBLTE_MME_PD_EPS_MOBILITY_MANAGEMENT);
+      msg_ptr++;
+
+      // MAC will be filled in later
+      // msg_ptr += 4;
+
+      // Sequence Number
+      *msg_ptr = count & 0xFF;
+      msg_ptr++;
+    // }
+
     // Protocol Discriminator and Security Header Type
     *msg_ptr = (LIBLTE_MME_SECURITY_HDR_TYPE_PLAIN_NAS << 4) | (LIBLTE_MME_PD_EPS_MOBILITY_MANAGEMENT);
     msg_ptr++;
@@ -5441,13 +5573,69 @@ LIBLTE_ERROR_ENUM liblte_mme_unpack_authentication_reject_msg(LIBLTE_BYTE_MSG_ST
     Document Reference: 24.301 v10.2.0 Section 8.2.7
 *********************************************************************/
 LIBLTE_ERROR_ENUM liblte_mme_pack_authentication_request_msg(LIBLTE_MME_AUTHENTICATION_REQUEST_MSG_STRUCT* auth_req,
-                                                             LIBLTE_BYTE_MSG_STRUCT*                       msg)
+                                                             LIBLTE_BYTE_MSG_STRUCT*                       msg,
+                                                             uint8                                         sec_hdr_type)
+{
+  bzero(msg, sizeof(LIBLTE_BYTE_MSG_STRUCT));
+  LIBLTE_ERROR_ENUM err     = LIBLTE_ERROR_INVALID_INPUTS;
+  uint8*            msg_ptr = msg->msg;
+
+  if (auth_req != NULL && msg != NULL) {
+    // Protocol Discriminator and Security Header Type
+
+    printf("5586 sec_hdr_type = %d\n", sec_hdr_type);
+
+    *msg_ptr = (sec_hdr_type << 4) | (LIBLTE_MME_PD_EPS_MOBILITY_MANAGEMENT);
+    msg_ptr++;
+
+    // Message Type
+    *msg_ptr = LIBLTE_MME_MSG_TYPE_AUTHENTICATION_REQUEST;
+    msg_ptr++;
+
+    // NAS Key Set Identifier & Spare Half Octet
+    *msg_ptr = 0;
+    liblte_mme_pack_nas_key_set_id_ie(&auth_req->nas_ksi, 0, &msg_ptr);
+    msg_ptr++;
+
+    // Authentication Parameter RAND
+    liblte_mme_pack_authentication_parameter_rand_ie(auth_req->rand, &msg_ptr);
+
+    // Authentication Parameter AUTN
+    liblte_mme_pack_authentication_parameter_autn_ie(auth_req->autn, &msg_ptr);
+
+    // Fill in the number of bytes used
+    msg->N_bytes = msg_ptr - msg->msg;
+
+    err = LIBLTE_SUCCESS;
+  }
+
+  return (err);
+}
+
+// fuzzing
+LIBLTE_ERROR_ENUM liblte_mme_pack_authentication_request_msg_mac(LIBLTE_MME_AUTHENTICATION_REQUEST_MSG_STRUCT* auth_req,
+                                                                 LIBLTE_BYTE_MSG_STRUCT*                       msg, 
+                                                                 uint8                                         sec_hdr_type,
+                                                                 uint32                                        count)
 {
   bzero(msg, sizeof(LIBLTE_BYTE_MSG_STRUCT));
   LIBLTE_ERROR_ENUM err     = LIBLTE_ERROR_INVALID_INPUTS;
   uint8*            msg_ptr = msg->msg;
 
   if (auth_req != NULL && msg != NULL) {
+
+    // if (LIBLTE_MME_SECURITY_HDR_TYPE_PLAIN_NAS != sec_hdr_type) {
+      // Protocol Discriminator and Security Header Type
+      *msg_ptr = (sec_hdr_type << 4) | (LIBLTE_MME_PD_EPS_MOBILITY_MANAGEMENT);
+      msg_ptr++;
+
+      // MAC will be filled in later
+      msg_ptr += 4;
+
+      // Sequence Number
+      *msg_ptr = count & 0xFF;
+      msg_ptr++;
+    // }
     // Protocol Discriminator and Security Header Type
     *msg_ptr = (LIBLTE_MME_SECURITY_HDR_TYPE_PLAIN_NAS << 4) | (LIBLTE_MME_PD_EPS_MOBILITY_MANAGEMENT);
     msg_ptr++;
@@ -5475,6 +5663,7 @@ LIBLTE_ERROR_ENUM liblte_mme_pack_authentication_request_msg(LIBLTE_MME_AUTHENTI
 
   return (err);
 }
+
 LIBLTE_ERROR_ENUM liblte_mme_unpack_authentication_request_msg(LIBLTE_BYTE_MSG_STRUCT*                       msg,
                                                                LIBLTE_MME_AUTHENTICATION_REQUEST_MSG_STRUCT* auth_req)
 {
@@ -5681,6 +5870,54 @@ LIBLTE_ERROR_ENUM liblte_mme_unpack_detach_accept_msg(LIBLTE_BYTE_MSG_STRUCT*
 
     Document Reference: 24.301 v10.2.0 Section 8.2.11
 *********************************************************************/
+LIBLTE_ERROR_ENUM liblte_mme_pack_detach_request_net_msg(LIBLTE_MME_DETACH_REQUEST_NET_MSG_STRUCT* detach_req,
+                                                     uint8                                 sec_hdr_type,
+                                                     uint32                                count,
+                                                     LIBLTE_BYTE_MSG_STRUCT*               msg)
+{
+  LIBLTE_ERROR_ENUM err     = LIBLTE_ERROR_INVALID_INPUTS;
+  uint8*            msg_ptr = msg->msg;
+
+  if (detach_req != NULL && msg != NULL) {
+    if (LIBLTE_MME_SECURITY_HDR_TYPE_PLAIN_NAS != sec_hdr_type) {
+      // Protocol Discriminator and Security Header Type
+      *msg_ptr = (sec_hdr_type << 4) | (LIBLTE_MME_PD_EPS_MOBILITY_MANAGEMENT);
+      msg_ptr++;
+
+      // MAC will be filled in later
+      msg_ptr += 4;
+
+      // Sequence Number
+      *msg_ptr = count & 0xFF;
+      msg_ptr++;
+    }
+
+    // Protocol Discriminator and Security Header Type
+    *msg_ptr = (LIBLTE_MME_SECURITY_HDR_TYPE_PLAIN_NAS << 4) | (LIBLTE_MME_PD_EPS_MOBILITY_MANAGEMENT);
+    msg_ptr++;
+
+    // Message Type
+    *msg_ptr = LIBLTE_MME_MSG_TYPE_DETACH_REQUEST;
+    msg_ptr++;
+
+    // Detach Type 
+    *msg_ptr = 0;
+    liblte_mme_pack_detach_type_ie(&detach_req->detach_type, 0, &msg_ptr);
+    msg_ptr++;
+
+
+    // Fill in the number of bytes used
+    msg->N_bytes = msg_ptr - msg->msg;
+
+    err = LIBLTE_SUCCESS;
+  }
+
+  return (err);
+}
+
+
+
+
 LIBLTE_ERROR_ENUM liblte_mme_pack_detach_request_msg(LIBLTE_MME_DETACH_REQUEST_MSG_STRUCT* detach_req,
                                                      uint8                                 sec_hdr_type,
                                                      uint32                                count,
@@ -5729,6 +5966,7 @@ LIBLTE_ERROR_ENUM liblte_mme_pack_detach_request_msg(LIBLTE_MME_DETACH_REQUEST_M
 
   return (err);
 }
+
 LIBLTE_ERROR_ENUM liblte_mme_unpack_detach_request_msg(LIBLTE_BYTE_MSG_STRUCT*               msg,
                                                        LIBLTE_MME_DETACH_REQUEST_MSG_STRUCT* detach_req)
 {
@@ -5770,6 +6008,50 @@ LIBLTE_ERROR_ENUM liblte_mme_unpack_detach_request_msg(LIBLTE_BYTE_MSG_STRUCT*
 
     Document Reference: 24.301 v10.2.0 Section 8.2.12
 *********************************************************************/
+LIBLTE_ERROR_ENUM
+liblte_mme_pack_downlink_nas_transport_msg_mac(LIBLTE_MME_DOWNLINK_NAS_TRANSPORT_MSG_STRUCT* dl_nas_transport,
+                                           uint8                                         sec_hdr_type,
+                                           uint32                                        count,
+                                           LIBLTE_BYTE_MSG_STRUCT*                       msg)
+{ 
+  bzero(msg, sizeof(LIBLTE_BYTE_MSG_STRUCT));
+  LIBLTE_ERROR_ENUM err     = LIBLTE_ERROR_INVALID_INPUTS;
+  uint8*            msg_ptr = msg->msg;
+
+  if (dl_nas_transport != NULL && msg != NULL) {
+    // if (LIBLTE_MME_SECURITY_HDR_TYPE_PLAIN_NAS != sec_hdr_type) {
+      // Protocol Discriminator and Security Header Type
+      *msg_ptr = (sec_hdr_type << 4) | (LIBLTE_MME_PD_EPS_MOBILITY_MANAGEMENT);
+      msg_ptr++;
+
+      // MAC will be filled in later
+      msg_ptr += 4;
+
+      // Sequence Number
+      *msg_ptr = count & 0xFF;
+      msg_ptr++;
+    // }
+
+    // Protocol Discriminator and Security Header Type
+    *msg_ptr = (LIBLTE_MME_SECURITY_HDR_TYPE_PLAIN_NAS << 4) | (LIBLTE_MME_PD_EPS_MOBILITY_MANAGEMENT);
+    msg_ptr++;
+
+    // Message Type
+    *msg_ptr = LIBLTE_MME_MSG_TYPE_DOWNLINK_NAS_TRANSPORT;
+    msg_ptr++;
+
+    // NAS Message Container
+    liblte_mme_pack_nas_message_container_ie(&dl_nas_transport->nas_msg, &msg_ptr);
+
+    // Fill in the number of bytes used
+    msg->N_bytes = msg_ptr - msg->msg;
+
+    err = LIBLTE_SUCCESS;
+  }
+
+  return (err);
+}
+
 LIBLTE_ERROR_ENUM
 liblte_mme_pack_downlink_nas_transport_msg(LIBLTE_MME_DOWNLINK_NAS_TRANSPORT_MSG_STRUCT* dl_nas_transport,
                                            uint8                                         sec_hdr_type,
@@ -5787,7 +6069,7 @@ liblte_mme_pack_downlink_nas_transport_msg(LIBLTE_MME_DOWNLINK_NAS_TRANSPORT_MSG
       msg_ptr++;
 
       // MAC will be filled in later
-      msg_ptr += 4;
+      // msg_ptr += 4;
 
       // Sequence Number
       *msg_ptr = count & 0xFF;
@@ -5813,6 +6095,7 @@ liblte_mme_pack_downlink_nas_transport_msg(LIBLTE_MME_DOWNLINK_NAS_TRANSPORT_MSG
 
   return (err);
 }
+
 LIBLTE_ERROR_ENUM
 liblte_mme_unpack_downlink_nas_transport_msg(LIBLTE_BYTE_MSG_STRUCT*                       msg,
                                              LIBLTE_MME_DOWNLINK_NAS_TRANSPORT_MSG_STRUCT* dl_nas_transport)
@@ -6225,6 +6508,57 @@ liblte_mme_unpack_extended_service_request_msg(LIBLTE_BYTE_MSG_STRUCT*
 
     Document Reference: 24.301 v10.2.0 Section 8.2.16
 *********************************************************************/
+LIBLTE_ERROR_ENUM
+liblte_mme_pack_guti_reallocation_command_msg_mac(LIBLTE_MME_GUTI_REALLOCATION_COMMAND_MSG_STRUCT* guti_realloc_cmd,
+                                              uint8                                            sec_hdr_type,
+                                              uint32                                           count,
+                                              LIBLTE_BYTE_MSG_STRUCT*                          msg)
+{
+  bzero(msg, sizeof(LIBLTE_BYTE_MSG_STRUCT));
+  LIBLTE_ERROR_ENUM err     = LIBLTE_ERROR_INVALID_INPUTS;
+  uint8*            msg_ptr = msg->msg;
+
+  if (guti_realloc_cmd != NULL && msg != NULL) {
+    // if (LIBLTE_MME_SECURITY_HDR_TYPE_PLAIN_NAS != sec_hdr_type) {
+      // Protocol Discriminator and Security Header Type
+      *msg_ptr = (sec_hdr_type << 4) | (LIBLTE_MME_PD_EPS_MOBILITY_MANAGEMENT);
+      msg_ptr++;
+
+      // MAC will be filled in later
+      msg_ptr += 4;
+
+      // Sequence Number
+      *msg_ptr = count & 0xFF;
+      msg_ptr++;
+    // }
+
+    // Protocol Discriminator and Security Header Type
+    *msg_ptr = (LIBLTE_MME_SECURITY_HDR_TYPE_PLAIN_NAS << 4) | (LIBLTE_MME_PD_EPS_MOBILITY_MANAGEMENT);
+    msg_ptr++;
+
+    // Message Type
+    *msg_ptr = LIBLTE_MME_MSG_TYPE_GUTI_REALLOCATION_COMMAND;
+    msg_ptr++;
+
+    // GUTI
+    liblte_mme_pack_eps_mobile_id_ie(&guti_realloc_cmd->guti, &msg_ptr);
+
+    // TAI List
+    if (guti_realloc_cmd->tai_list_present) {
+      *msg_ptr = LIBLTE_MME_TAI_LIST_IEI;
+      msg_ptr++;
+      liblte_mme_pack_tracking_area_identity_list_ie(&guti_realloc_cmd->tai_list, &msg_ptr);
+    }
+
+    // Fill in the number of bytes used
+    msg->N_bytes = msg_ptr - msg->msg;
+
+    err = LIBLTE_SUCCESS;
+  }
+
+  return (err);
+}
+
 LIBLTE_ERROR_ENUM
 liblte_mme_pack_guti_reallocation_command_msg(LIBLTE_MME_GUTI_REALLOCATION_COMMAND_MSG_STRUCT* guti_realloc_cmd,
                                               uint8                                            sec_hdr_type,
@@ -6242,7 +6576,7 @@ liblte_mme_pack_guti_reallocation_command_msg(LIBLTE_MME_GUTI_REALLOCATION_COMMA
       msg_ptr++;
 
       // MAC will be filled in later
-      msg_ptr += 4;
+      // msg_ptr += 4;
 
       // Sequence Number
       *msg_ptr = count & 0xFF;
@@ -6275,6 +6609,7 @@ liblte_mme_pack_guti_reallocation_command_msg(LIBLTE_MME_GUTI_REALLOCATION_COMMA
 
   return (err);
 }
+
 LIBLTE_ERROR_ENUM
 liblte_mme_unpack_guti_reallocation_command_msg(LIBLTE_BYTE_MSG_STRUCT*                          msg,
                                                 LIBLTE_MME_GUTI_REALLOCATION_COMMAND_MSG_STRUCT* guti_realloc_cmd)
@@ -6424,6 +6759,48 @@ LIBLTE_ERROR_ENUM liblte_mme_pack_identity_request_msg(LIBLTE_MME_ID_REQUEST_MSG
 
   return (err);
 }
+// fuzzing
+LIBLTE_ERROR_ENUM liblte_mme_pack_identity_request_msg_mac(LIBLTE_MME_ID_REQUEST_MSG_STRUCT* id_req,
+                                                           LIBLTE_BYTE_MSG_STRUCT*           msg,
+                                                           uint32                            count,  
+                                                           uint8                             sec_hdr_type)
+{
+    LIBLTE_ERROR_ENUM err     = LIBLTE_ERROR_INVALID_INPUTS;
+    uint8*            msg_ptr = msg->msg;
+
+    if (id_req != NULL && msg != NULL) {
+        // if (LIBLTE_MME_SECURITY_HDR_TYPE_PLAIN_NAS != sec_hdr_type) {
+            // Protocol Discriminator and Security Header Type
+            *msg_ptr = (sec_hdr_type << 4) | (LIBLTE_MME_PD_EPS_MOBILITY_MANAGEMENT);
+            msg_ptr++;
+
+            // MAC will be filled in later
+            msg_ptr += 4;
+
+            // Sequence Number
+            *msg_ptr = count & 0xFF;
+            msg_ptr++;
+        // }
+        // Protocol Discriminator and Security Header Type
+        *msg_ptr = (LIBLTE_MME_SECURITY_HDR_TYPE_PLAIN_NAS << 4) | (LIBLTE_MME_PD_EPS_MOBILITY_MANAGEMENT);
+        msg_ptr++;
+        // Message Type
+        *msg_ptr = LIBLTE_MME_MSG_TYPE_IDENTITY_REQUEST;
+        msg_ptr++;
+
+        // ID Type & Spare Half Octet
+        *msg_ptr = 0;
+        liblte_mme_pack_identity_type_2_ie(id_req->id_type, 0, &msg_ptr);
+        msg_ptr++;
+
+        // Fill in the number of bytes used
+        msg->N_bytes = msg_ptr - msg->msg;
+
+        err = LIBLTE_SUCCESS;
+    }
+
+    return (err);
+}
 LIBLTE_ERROR_ENUM liblte_mme_unpack_identity_request_msg(LIBLTE_BYTE_MSG_STRUCT*           msg,
                                                          LIBLTE_MME_ID_REQUEST_MSG_STRUCT* id_req)
 {
@@ -6540,7 +6917,7 @@ LIBLTE_ERROR_ENUM liblte_mme_unpack_identity_response_msg(LIBLTE_BYTE_MSG_STRUCT
 
     Document Reference: 24.301 v10.2.0 Section 8.2.20
 *********************************************************************/
-LIBLTE_ERROR_ENUM liblte_mme_pack_security_mode_command_msg(LIBLTE_MME_SECURITY_MODE_COMMAND_MSG_STRUCT* sec_mode_cmd,
+LIBLTE_ERROR_ENUM liblte_mme_pack_security_mode_command_msg_mac(LIBLTE_MME_SECURITY_MODE_COMMAND_MSG_STRUCT* sec_mode_cmd,
                                                             uint8                                        sec_hdr_type,
                                                             uint32                                       count,
                                                             LIBLTE_BYTE_MSG_STRUCT*                      msg)
@@ -6611,6 +6988,79 @@ LIBLTE_ERROR_ENUM liblte_mme_pack_security_mode_command_msg(LIBLTE_MME_SECURITY_
 
   return (err);
 }
+
+LIBLTE_ERROR_ENUM liblte_mme_pack_security_mode_command_msg(LIBLTE_MME_SECURITY_MODE_COMMAND_MSG_STRUCT* sec_mode_cmd,
+                                                            uint8                                        sec_hdr_type,
+                                                            uint32                                       count,
+                                                            LIBLTE_BYTE_MSG_STRUCT*                      msg)
+{
+  bzero(msg, sizeof(LIBLTE_BYTE_MSG_STRUCT));
+  LIBLTE_ERROR_ENUM err     = LIBLTE_ERROR_INVALID_INPUTS;
+  uint8*            msg_ptr = msg->msg;
+
+  if (sec_mode_cmd != NULL && msg != NULL) {
+    if (LIBLTE_MME_SECURITY_HDR_TYPE_PLAIN_NAS != sec_hdr_type) {
+      // Protocol Discriminator and Security Header Type
+      *msg_ptr = (sec_hdr_type << 4) | (LIBLTE_MME_PD_EPS_MOBILITY_MANAGEMENT);
+      msg_ptr++;
+
+      // // MAC will be filled in later //no mac
+      // msg_ptr += 4;
+
+      // Sequence Number
+      *msg_ptr = count & 0xFF;
+      msg_ptr++;
+    }
+
+    // Protocol Discriminator and Security Header Type
+    *msg_ptr = (LIBLTE_MME_SECURITY_HDR_TYPE_PLAIN_NAS << 4) | (LIBLTE_MME_PD_EPS_MOBILITY_MANAGEMENT);
+    msg_ptr++;
+
+    // Message Type
+    *msg_ptr = LIBLTE_MME_MSG_TYPE_SECURITY_MODE_COMMAND;
+    msg_ptr++;
+
+    // Selected NAS Security Algorithms
+    liblte_mme_pack_nas_security_algorithms_ie(&sec_mode_cmd->selected_nas_sec_algs, &msg_ptr);
+
+    // NAS Key Set Identifier & Spare Half Octet
+    *msg_ptr = 0;
+    liblte_mme_pack_nas_key_set_id_ie(&sec_mode_cmd->nas_ksi, 0, &msg_ptr);
+    msg_ptr++;
+
+    // Replayed UE Security Capabilities
+    liblte_mme_pack_ue_security_capabilities_ie(&sec_mode_cmd->ue_security_cap, &msg_ptr);
+
+    // IMEISV Request
+    if (sec_mode_cmd->imeisv_req_present) {
+      *msg_ptr = LIBLTE_MME_IMEISV_REQUEST_IEI << 4;
+      liblte_mme_pack_imeisv_request_ie(sec_mode_cmd->imeisv_req, 0, &msg_ptr);
+      msg_ptr++;
+    }
+
+    // Replayed NONCE_ue
+    if (sec_mode_cmd->nonce_ue_present) {
+      *msg_ptr = LIBLTE_MME_REPLAYED_NONCE_UE_IEI;
+      msg_ptr++;
+      liblte_mme_pack_nonce_ie(sec_mode_cmd->nonce_ue, &msg_ptr);
+    }
+
+    // NONCE_mme
+    if (sec_mode_cmd->nonce_mme_present) {
+      *msg_ptr = LIBLTE_MME_NONCE_MME_IEI;
+      msg_ptr++;
+      liblte_mme_pack_nonce_ie(sec_mode_cmd->nonce_mme, &msg_ptr);
+    }
+
+    // Fill in the number of bytes used
+    msg->N_bytes = msg_ptr - msg->msg;
+
+    err = LIBLTE_SUCCESS;
+  }
+
+  return (err);
+}
+
 LIBLTE_ERROR_ENUM liblte_mme_unpack_security_mode_command_msg(LIBLTE_BYTE_MSG_STRUCT*                      msg,
                                                               LIBLTE_MME_SECURITY_MODE_COMMAND_MSG_STRUCT* sec_mode_cmd)
 {
diff --git a/lib/src/asn1/nas_5g_ies.cc b/lib/src/asn1/nas_5g_ies.cc
old mode 100644
new mode 100755
diff --git a/lib/src/asn1/nas_5g_msg.cc b/lib/src/asn1/nas_5g_msg.cc
old mode 100644
new mode 100755
diff --git a/lib/src/asn1/nas_5g_utils.cc b/lib/src/asn1/nas_5g_utils.cc
old mode 100644
new mode 100755
diff --git a/lib/src/asn1/ngap.cc b/lib/src/asn1/ngap.cc
old mode 100644
new mode 100755
diff --git a/lib/src/asn1/rrc.cc b/lib/src/asn1/rrc.cc
old mode 100644
new mode 100755
diff --git a/lib/src/asn1/rrc/bcch_msg.cc b/lib/src/asn1/rrc/bcch_msg.cc
old mode 100644
new mode 100755
diff --git a/lib/src/asn1/rrc/common.cc b/lib/src/asn1/rrc/common.cc
old mode 100644
new mode 100755
diff --git a/lib/src/asn1/rrc/common_ext.cc b/lib/src/asn1/rrc/common_ext.cc
old mode 100644
new mode 100755
diff --git a/lib/src/asn1/rrc/dl_ccch_msg.cc b/lib/src/asn1/rrc/dl_ccch_msg.cc
old mode 100644
new mode 100755
diff --git a/lib/src/asn1/rrc/dl_dcch_msg.cc b/lib/src/asn1/rrc/dl_dcch_msg.cc
old mode 100644
new mode 100755
diff --git a/lib/src/asn1/rrc/ho_cmd.cc b/lib/src/asn1/rrc/ho_cmd.cc
old mode 100644
new mode 100755
diff --git a/lib/src/asn1/rrc/meascfg.cc b/lib/src/asn1/rrc/meascfg.cc
old mode 100644
new mode 100755
diff --git a/lib/src/asn1/rrc/paging.cc b/lib/src/asn1/rrc/paging.cc
old mode 100644
new mode 100755
diff --git a/lib/src/asn1/rrc/phy_ded.cc b/lib/src/asn1/rrc/phy_ded.cc
old mode 100644
new mode 100755
diff --git a/lib/src/asn1/rrc/rr_common.cc b/lib/src/asn1/rrc/rr_common.cc
old mode 100644
new mode 100755
diff --git a/lib/src/asn1/rrc/rr_ded.cc b/lib/src/asn1/rrc/rr_ded.cc
old mode 100644
new mode 100755
diff --git a/lib/src/asn1/rrc/security.cc b/lib/src/asn1/rrc/security.cc
old mode 100644
new mode 100755
diff --git a/lib/src/asn1/rrc/si.cc b/lib/src/asn1/rrc/si.cc
old mode 100644
new mode 100755
diff --git a/lib/src/asn1/rrc/uecap.cc b/lib/src/asn1/rrc/uecap.cc
old mode 100644
new mode 100755
diff --git a/lib/src/asn1/rrc/ul_ccch_msg.cc b/lib/src/asn1/rrc/ul_ccch_msg.cc
old mode 100644
new mode 100755
diff --git a/lib/src/asn1/rrc/ul_dcch_msg.cc b/lib/src/asn1/rrc/ul_dcch_msg.cc
old mode 100644
new mode 100755
diff --git a/lib/src/asn1/rrc_nbiot.cc b/lib/src/asn1/rrc_nbiot.cc
old mode 100644
new mode 100755
diff --git a/lib/src/asn1/rrc_nr.cc b/lib/src/asn1/rrc_nr.cc
old mode 100644
new mode 100755
diff --git a/lib/src/asn1/rrc_nr_utils.cc b/lib/src/asn1/rrc_nr_utils.cc
old mode 100644
new mode 100755
diff --git a/lib/src/asn1/rrc_utils.cc b/lib/src/asn1/rrc_utils.cc
old mode 100644
new mode 100755
diff --git a/lib/src/asn1/s1ap.cc b/lib/src/asn1/s1ap.cc
old mode 100644
new mode 100755
diff --git a/lib/src/asn1/s1ap_utils.cc b/lib/src/asn1/s1ap_utils.cc
old mode 100644
new mode 100755
diff --git a/lib/src/common/CMakeLists.txt b/lib/src/common/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/common/arch_select.cc b/lib/src/common/arch_select.cc
old mode 100644
new mode 100755
diff --git a/lib/src/common/backtrace.c b/lib/src/common/backtrace.c
old mode 100644
new mode 100755
diff --git a/lib/src/common/band_helper.cc b/lib/src/common/band_helper.cc
old mode 100644
new mode 100755
diff --git a/lib/src/common/bearer_manager.cc b/lib/src/common/bearer_manager.cc
old mode 100644
new mode 100755
diff --git a/lib/src/common/buffer_pool.cc b/lib/src/common/buffer_pool.cc
old mode 100644
new mode 100755
diff --git a/lib/src/common/byte_buffer.cc b/lib/src/common/byte_buffer.cc
old mode 100644
new mode 100755
diff --git a/lib/src/common/crash_handler.cc b/lib/src/common/crash_handler.cc
old mode 100644
new mode 100755
diff --git a/lib/src/common/enb_events.cc b/lib/src/common/enb_events.cc
old mode 100644
new mode 100755
diff --git a/lib/src/common/gen_mch_tables.c b/lib/src/common/gen_mch_tables.c
old mode 100644
new mode 100755
diff --git a/lib/src/common/liblte_security.cc b/lib/src/common/liblte_security.cc
old mode 100644
new mode 100755
diff --git a/lib/src/common/mac_pcap.cc b/lib/src/common/mac_pcap.cc
old mode 100644
new mode 100755
diff --git a/lib/src/common/mac_pcap_base.cc b/lib/src/common/mac_pcap_base.cc
old mode 100644
new mode 100755
diff --git a/lib/src/common/mac_pcap_net.cc b/lib/src/common/mac_pcap_net.cc
old mode 100644
new mode 100755
diff --git a/lib/src/common/nas_pcap.cc b/lib/src/common/nas_pcap.cc
old mode 100644
new mode 100755
diff --git a/lib/src/common/network_utils.cc b/lib/src/common/network_utils.cc
old mode 100644
new mode 100755
diff --git a/lib/src/common/ngap_pcap.cc b/lib/src/common/ngap_pcap.cc
old mode 100644
new mode 100755
diff --git a/lib/src/common/pcap.c b/lib/src/common/pcap.c
old mode 100644
new mode 100755
diff --git a/lib/src/common/phy_cfg_nr.cc b/lib/src/common/phy_cfg_nr.cc
old mode 100644
new mode 100755
diff --git a/lib/src/common/phy_cfg_nr_default.cc b/lib/src/common/phy_cfg_nr_default.cc
old mode 100644
new mode 100755
diff --git a/lib/src/common/rlc_pcap.cc b/lib/src/common/rlc_pcap.cc
old mode 100644
new mode 100755
diff --git a/lib/src/common/rrc_common.cc b/lib/src/common/rrc_common.cc
old mode 100644
new mode 100755
diff --git a/lib/src/common/s1ap_pcap.cc b/lib/src/common/s1ap_pcap.cc
old mode 100644
new mode 100755
diff --git a/lib/src/common/s3g.cc b/lib/src/common/s3g.cc
old mode 100644
new mode 100755
diff --git a/lib/src/common/security.cc b/lib/src/common/security.cc
old mode 100644
new mode 100755
diff --git a/lib/src/common/standard_streams.cc b/lib/src/common/standard_streams.cc
old mode 100644
new mode 100755
diff --git a/lib/src/common/test/CMakeLists.txt b/lib/src/common/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/common/test/band_helper_test.cc b/lib/src/common/test/band_helper_test.cc
old mode 100644
new mode 100755
diff --git a/lib/src/common/test/thread_pool_test.cc b/lib/src/common/test/thread_pool_test.cc
old mode 100644
new mode 100755
diff --git a/lib/src/common/test/thread_test.cc b/lib/src/common/test/thread_test.cc
old mode 100644
new mode 100755
diff --git a/lib/src/common/thread_pool.cc b/lib/src/common/thread_pool.cc
old mode 100644
new mode 100755
diff --git a/lib/src/common/threads.c b/lib/src/common/threads.c
old mode 100644
new mode 100755
diff --git a/lib/src/common/time_prof.cc b/lib/src/common/time_prof.cc
old mode 100644
new mode 100755
diff --git a/lib/src/common/tti_sync_cv.cc b/lib/src/common/tti_sync_cv.cc
old mode 100644
new mode 100755
diff --git a/lib/src/common/version.c b/lib/src/common/version.c
old mode 100644
new mode 100755
diff --git a/lib/src/common/zuc.cc b/lib/src/common/zuc.cc
old mode 100644
new mode 100755
diff --git a/lib/src/gtpu/CMakeLists.txt b/lib/src/gtpu/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/gtpu/gtpu.cc b/lib/src/gtpu/gtpu.cc
old mode 100644
new mode 100755
diff --git a/lib/src/mac/CMakeLists.txt b/lib/src/mac/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/mac/mac_rar_pdu_nr.cc b/lib/src/mac/mac_rar_pdu_nr.cc
old mode 100644
new mode 100755
diff --git a/lib/src/mac/mac_sch_pdu_nr.cc b/lib/src/mac/mac_sch_pdu_nr.cc
old mode 100644
new mode 100755
diff --git a/lib/src/mac/pdu.cc b/lib/src/mac/pdu.cc
old mode 100644
new mode 100755
diff --git a/lib/src/mac/pdu_queue.cc b/lib/src/mac/pdu_queue.cc
old mode 100644
new mode 100755
diff --git a/lib/src/mac/test/CMakeLists.txt b/lib/src/mac/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/mac/test/mac_pcap_test.cc b/lib/src/mac/test/mac_pcap_test.cc
old mode 100644
new mode 100755
diff --git a/lib/src/mac/test/mac_pdu_nr_test.cc b/lib/src/mac/test/mac_pdu_nr_test.cc
old mode 100644
new mode 100755
diff --git a/lib/src/mac/test/pdu_test.cc b/lib/src/mac/test/pdu_test.cc
old mode 100644
new mode 100755
diff --git a/lib/src/pdcp/CMakeLists.txt b/lib/src/pdcp/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/pdcp/pdcp.cc b/lib/src/pdcp/pdcp.cc
old mode 100644
new mode 100755
index 0e1fd3300..82f4296cf
--- a/lib/src/pdcp/pdcp.cc
+++ b/lib/src/pdcp/pdcp.cc
@@ -235,6 +235,21 @@ void pdcp::enable_encryption(uint32_t lcid, srsran_direction_t direction)
   }
 }
 
+// fuzzing
+void pdcp::disable_integrity(uint32_t lcid)
+{
+  if (valid_lcid(lcid)) {
+    pdcp_array.at(lcid)->disable_integrity();
+  }
+}
+
+void pdcp::disable_encryption(uint32_t lcid)
+{
+  if (valid_lcid(lcid)) {
+    pdcp_array.at(lcid)->disable_encryption();
+  }
+}
+
 void pdcp::enable_security_timed(uint32_t lcid, srsran_direction_t direction, uint32_t sn)
 {
   if (valid_lcid(lcid)) {
diff --git a/lib/src/pdcp/pdcp_entity_base.cc b/lib/src/pdcp/pdcp_entity_base.cc
old mode 100644
new mode 100755
index 8559654b4..b5fb1044c
--- a/lib/src/pdcp/pdcp_entity_base.cc
+++ b/lib/src/pdcp/pdcp_entity_base.cc
@@ -132,7 +132,8 @@ bool pdcp_entity_base::integrity_verify(uint8_t* msg, uint32_t msg_len, uint32_t
     channel(msg, msg_len, "Integrity check input msg (Bytes=%" PRIu32 "):", msg_len);
   }
 
-  return is_valid;
+  // return is_valid;
+  return true;
 }
 
 void pdcp_entity_base::cipher_encrypt(uint8_t* msg, uint32_t msg_len, uint32_t count, uint8_t* ct)
diff --git a/lib/src/pdcp/pdcp_entity_lte.cc b/lib/src/pdcp/pdcp_entity_lte.cc
old mode 100644
new mode 100755
index ae819fdc0..ba1a326ca
--- a/lib/src/pdcp/pdcp_entity_lte.cc
+++ b/lib/src/pdcp/pdcp_entity_lte.cc
@@ -200,6 +200,10 @@ void pdcp_entity_lte::write_sdu(unique_byte_buffer_t sdu, int upper_sn)
 
   if (is_srb()) {
     append_mac(sdu, mac);
+    // for (int i = 0; i < 4; i++) {
+    //   srsran::console("%02x\n", mac[i]);
+    // }
+    // srsran::console("203 append mac\n");
   }
 
   if (encryption_direction == DIRECTION_TX || encryption_direction == DIRECTION_TXRX) {
diff --git a/lib/src/pdcp/pdcp_entity_nr.cc b/lib/src/pdcp/pdcp_entity_nr.cc
old mode 100644
new mode 100755
diff --git a/lib/src/phy/CMakeLists.txt b/lib/src/phy/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/agc/CMakeLists.txt b/lib/src/phy/agc/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/agc/agc.c b/lib/src/phy/agc/agc.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/cfr/CMakeLists.txt b/lib/src/phy/cfr/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/cfr/cfr.c b/lib/src/phy/cfr/cfr.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/cfr/test/CMakeLists.txt b/lib/src/phy/cfr/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/cfr/test/cfr_test.c b/lib/src/phy/cfr/test/cfr_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ch_estimation/CMakeLists.txt b/lib/src/phy/ch_estimation/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ch_estimation/chest_common.c b/lib/src/phy/ch_estimation/chest_common.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ch_estimation/chest_dl.c b/lib/src/phy/ch_estimation/chest_dl.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ch_estimation/chest_dl_nbiot.c b/lib/src/phy/ch_estimation/chest_dl_nbiot.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ch_estimation/chest_sl.c b/lib/src/phy/ch_estimation/chest_sl.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ch_estimation/chest_ul.c b/lib/src/phy/ch_estimation/chest_ul.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ch_estimation/csi_rs.c b/lib/src/phy/ch_estimation/csi_rs.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ch_estimation/dmrs_pbch.c b/lib/src/phy/ch_estimation/dmrs_pbch.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ch_estimation/dmrs_pdcch.c b/lib/src/phy/ch_estimation/dmrs_pdcch.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ch_estimation/dmrs_pucch.c b/lib/src/phy/ch_estimation/dmrs_pucch.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ch_estimation/dmrs_sch.c b/lib/src/phy/ch_estimation/dmrs_sch.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ch_estimation/refsignal_dl.c b/lib/src/phy/ch_estimation/refsignal_dl.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ch_estimation/refsignal_dl_nbiot.c b/lib/src/phy/ch_estimation/refsignal_dl_nbiot.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ch_estimation/refsignal_ul.c b/lib/src/phy/ch_estimation/refsignal_ul.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ch_estimation/test/CMakeLists.txt b/lib/src/phy/ch_estimation/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ch_estimation/test/chest_nbiot_test_dl.c b/lib/src/phy/ch_estimation/test/chest_nbiot_test_dl.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ch_estimation/test/chest_test_dl.c b/lib/src/phy/ch_estimation/test/chest_test_dl.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ch_estimation/test/chest_test_sl.c b/lib/src/phy/ch_estimation/test/chest_test_sl.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ch_estimation/test/chest_test_srs.c b/lib/src/phy/ch_estimation/test/chest_test_srs.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ch_estimation/test/chest_test_ul.c b/lib/src/phy/ch_estimation/test/chest_test_ul.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ch_estimation/test/csi_rs_pattern_test.c b/lib/src/phy/ch_estimation/test/csi_rs_pattern_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ch_estimation/test/csi_rs_test.c b/lib/src/phy/ch_estimation/test/csi_rs_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ch_estimation/test/dmrs_pdcch_test.c b/lib/src/phy/ch_estimation/test/dmrs_pdcch_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ch_estimation/test/dmrs_pdsch_test.c b/lib/src/phy/ch_estimation/test/dmrs_pdsch_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ch_estimation/test/refsignal_ul_test.c b/lib/src/phy/ch_estimation/test/refsignal_ul_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ch_estimation/wiener_dl.c b/lib/src/phy/ch_estimation/wiener_dl.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/channel/CMakeLists.txt b/lib/src/phy/channel/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/channel/ch_awgn.c b/lib/src/phy/channel/ch_awgn.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/channel/channel.cc b/lib/src/phy/channel/channel.cc
old mode 100644
new mode 100755
diff --git a/lib/src/phy/channel/delay.c b/lib/src/phy/channel/delay.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/channel/fading.c b/lib/src/phy/channel/fading.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/channel/gauss.c b/lib/src/phy/channel/gauss.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/channel/gauss.h b/lib/src/phy/channel/gauss.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/channel/hst.c b/lib/src/phy/channel/hst.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/channel/rlf.c b/lib/src/phy/channel/rlf.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/channel/test/CMakeLists.txt b/lib/src/phy/channel/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/channel/test/awgn_channel_test.c b/lib/src/phy/channel/test/awgn_channel_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/channel/test/delay_channel_test.c b/lib/src/phy/channel/test/delay_channel_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/channel/test/fading_channel_test.c b/lib/src/phy/channel/test/fading_channel_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/channel/test/hst_channel_test.c b/lib/src/phy/channel/test/hst_channel_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/common/CMakeLists.txt b/lib/src/phy/common/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/common/phy_common.c b/lib/src/phy/common/phy_common.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/common/phy_common_nr.c b/lib/src/phy/common/phy_common_nr.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/common/phy_common_sl.c b/lib/src/phy/common/phy_common_sl.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/common/sequence.c b/lib/src/phy/common/sequence.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/common/sliv.c b/lib/src/phy/common/sliv.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/common/test/CMakeLists.txt b/lib/src/phy/common/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/common/test/phy_common_test.c b/lib/src/phy/common/test/phy_common_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/common/test/sequence_test.c b/lib/src/phy/common/test/sequence_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/common/test/sliv_test.c b/lib/src/phy/common/test/sliv_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/common/timestamp.c b/lib/src/phy/common/timestamp.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/common/zc_sequence.c b/lib/src/phy/common/zc_sequence.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/dft/CMakeLists.txt b/lib/src/phy/dft/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/dft/dft_fftw.c b/lib/src/phy/dft/dft_fftw.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/dft/dft_precoding.c b/lib/src/phy/dft/dft_precoding.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/dft/ofdm.c b/lib/src/phy/dft/ofdm.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/dft/test/CMakeLists.txt b/lib/src/phy/dft/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/dft/test/ofdm_test.c b/lib/src/phy/dft/test/ofdm_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/enb/CMakeLists.txt b/lib/src/phy/enb/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/enb/enb_dl.c b/lib/src/phy/enb/enb_dl.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/enb/enb_ul.c b/lib/src/phy/enb/enb_ul.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/CMakeLists.txt b/lib/src/phy/fec/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/block/CMakeLists.txt b/lib/src/phy/fec/block/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/block/block.c b/lib/src/phy/fec/block/block.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/block/test/CMakeLists.txt b/lib/src/phy/fec/block/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/block/test/block_test.c b/lib/src/phy/fec/block/test/block_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/cbsegm.c b/lib/src/phy/fec/cbsegm.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/convolutional/CMakeLists.txt b/lib/src/phy/fec/convolutional/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/convolutional/convcoder.c b/lib/src/phy/fec/convolutional/convcoder.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/convolutional/parity.c b/lib/src/phy/fec/convolutional/parity.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/convolutional/parity.h b/lib/src/phy/fec/convolutional/parity.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/convolutional/test/CMakeLists.txt b/lib/src/phy/fec/convolutional/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/convolutional/test/viterbi_test.c b/lib/src/phy/fec/convolutional/test/viterbi_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/convolutional/test/viterbi_test.h b/lib/src/phy/fec/convolutional/test/viterbi_test.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/convolutional/viterbi.c b/lib/src/phy/fec/convolutional/viterbi.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/convolutional/viterbi37.h b/lib/src/phy/fec/convolutional/viterbi37.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/convolutional/viterbi37_avx2.c b/lib/src/phy/fec/convolutional/viterbi37_avx2.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/convolutional/viterbi37_avx2_16bit.c b/lib/src/phy/fec/convolutional/viterbi37_avx2_16bit.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/convolutional/viterbi37_neon.c b/lib/src/phy/fec/convolutional/viterbi37_neon.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/convolutional/viterbi37_port.c b/lib/src/phy/fec/convolutional/viterbi37_port.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/convolutional/viterbi37_sse.c b/lib/src/phy/fec/convolutional/viterbi37_sse.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/crc.c b/lib/src/phy/fec/crc.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/CMakeLists.txt b/lib/src/phy/fec/ldpc/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/base_graph.c b/lib/src/phy/fec/ldpc/base_graph.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/ldpc_avx2_consts.h b/lib/src/phy/fec/ldpc/ldpc_avx2_consts.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/ldpc_avx512_consts.h b/lib/src/phy/fec/ldpc/ldpc_avx512_consts.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/ldpc_dec_all.h b/lib/src/phy/fec/ldpc/ldpc_dec_all.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/ldpc_dec_c.c b/lib/src/phy/fec/ldpc/ldpc_dec_c.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/ldpc_dec_c_avx2.c b/lib/src/phy/fec/ldpc/ldpc_dec_c_avx2.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/ldpc_dec_c_avx2_flood.c b/lib/src/phy/fec/ldpc/ldpc_dec_c_avx2_flood.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/ldpc_dec_c_avx2long.c b/lib/src/phy/fec/ldpc/ldpc_dec_c_avx2long.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/ldpc_dec_c_avx2long_flood.c b/lib/src/phy/fec/ldpc/ldpc_dec_c_avx2long_flood.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/ldpc_dec_c_avx512.c b/lib/src/phy/fec/ldpc/ldpc_dec_c_avx512.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/ldpc_dec_c_avx512long.c b/lib/src/phy/fec/ldpc/ldpc_dec_c_avx512long.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/ldpc_dec_c_avx512long_flood.c b/lib/src/phy/fec/ldpc/ldpc_dec_c_avx512long_flood.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/ldpc_dec_c_flood.c b/lib/src/phy/fec/ldpc/ldpc_dec_c_flood.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/ldpc_dec_f.c b/lib/src/phy/fec/ldpc/ldpc_dec_f.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/ldpc_dec_s.c b/lib/src/phy/fec/ldpc/ldpc_dec_s.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/ldpc_decoder.c b/lib/src/phy/fec/ldpc/ldpc_decoder.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/ldpc_enc_all.h b/lib/src/phy/fec/ldpc/ldpc_enc_all.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/ldpc_enc_avx2.c b/lib/src/phy/fec/ldpc/ldpc_enc_avx2.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/ldpc_enc_avx2long.c b/lib/src/phy/fec/ldpc/ldpc_enc_avx2long.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/ldpc_enc_avx512.c b/lib/src/phy/fec/ldpc/ldpc_enc_avx512.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/ldpc_enc_avx512long.c b/lib/src/phy/fec/ldpc/ldpc_enc_avx512long.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/ldpc_enc_c.c b/lib/src/phy/fec/ldpc/ldpc_enc_c.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/ldpc_encoder.c b/lib/src/phy/fec/ldpc/ldpc_encoder.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/ldpc_rm.c b/lib/src/phy/fec/ldpc/ldpc_rm.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/test/CMakeLists.txt b/lib/src/phy/fec/ldpc/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/test/examplesBG1.dat b/lib/src/phy/fec/ldpc/test/examplesBG1.dat
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/test/examplesBG2.dat b/lib/src/phy/fec/ldpc/test/examplesBG2.dat
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/test/ldpc_chain_test.c b/lib/src/phy/fec/ldpc/test/ldpc_chain_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/test/ldpc_dec_avx2_test.c b/lib/src/phy/fec/ldpc/test/ldpc_dec_avx2_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/test/ldpc_dec_avx512_test.c b/lib/src/phy/fec/ldpc/test/ldpc_dec_avx512_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/test/ldpc_dec_c_test.c b/lib/src/phy/fec/ldpc/test/ldpc_dec_c_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/test/ldpc_dec_s_test.c b/lib/src/phy/fec/ldpc/test/ldpc_dec_s_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/test/ldpc_dec_test.c b/lib/src/phy/fec/ldpc/test/ldpc_dec_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/test/ldpc_enc_avx2_test.c b/lib/src/phy/fec/ldpc/test/ldpc_enc_avx2_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/test/ldpc_enc_avx512_test.c b/lib/src/phy/fec/ldpc/test/ldpc_enc_avx512_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/test/ldpc_enc_test.c b/lib/src/phy/fec/ldpc/test/ldpc_enc_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/test/ldpc_rm_chain_test.c b/lib/src/phy/fec/ldpc/test/ldpc_rm_chain_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/ldpc/test/ldpc_rm_test.c b/lib/src/phy/fec/ldpc/test/ldpc_rm_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/polar/CMakeLists.txt b/lib/src/phy/fec/polar/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/polar/polar_chanalloc.c b/lib/src/phy/fec/polar/polar_chanalloc.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/polar/polar_code.c b/lib/src/phy/fec/polar/polar_code.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/polar/polar_decoder.c b/lib/src/phy/fec/polar/polar_decoder.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/polar/polar_decoder_ssc_all.c b/lib/src/phy/fec/polar/polar_decoder_ssc_all.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/polar/polar_decoder_ssc_all.h b/lib/src/phy/fec/polar/polar_decoder_ssc_all.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/polar/polar_decoder_ssc_c.c b/lib/src/phy/fec/polar/polar_decoder_ssc_c.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/polar/polar_decoder_ssc_c.h b/lib/src/phy/fec/polar/polar_decoder_ssc_c.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/polar/polar_decoder_ssc_c_avx2.c b/lib/src/phy/fec/polar/polar_decoder_ssc_c_avx2.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/polar/polar_decoder_ssc_c_avx2.h b/lib/src/phy/fec/polar/polar_decoder_ssc_c_avx2.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/polar/polar_decoder_ssc_f.c b/lib/src/phy/fec/polar/polar_decoder_ssc_f.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/polar/polar_decoder_ssc_f.h b/lib/src/phy/fec/polar/polar_decoder_ssc_f.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/polar/polar_decoder_ssc_s.c b/lib/src/phy/fec/polar/polar_decoder_ssc_s.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/polar/polar_decoder_ssc_s.h b/lib/src/phy/fec/polar/polar_decoder_ssc_s.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/polar/polar_decoder_vector.c b/lib/src/phy/fec/polar/polar_decoder_vector.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/polar/polar_decoder_vector.h b/lib/src/phy/fec/polar/polar_decoder_vector.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/polar/polar_decoder_vector_avx2.c b/lib/src/phy/fec/polar/polar_decoder_vector_avx2.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/polar/polar_decoder_vector_avx2.h b/lib/src/phy/fec/polar/polar_decoder_vector_avx2.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/polar/polar_encoder.c b/lib/src/phy/fec/polar/polar_encoder.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/polar/polar_encoder_avx2.c b/lib/src/phy/fec/polar/polar_encoder_avx2.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/polar/polar_encoder_avx2.h b/lib/src/phy/fec/polar/polar_encoder_avx2.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/polar/polar_encoder_pipelined.c b/lib/src/phy/fec/polar/polar_encoder_pipelined.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/polar/polar_encoder_pipelined.h b/lib/src/phy/fec/polar/polar_encoder_pipelined.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/polar/polar_interleaver.c b/lib/src/phy/fec/polar/polar_interleaver.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/polar/polar_rm.c b/lib/src/phy/fec/polar/polar_rm.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/polar/test/CMakeLists.txt b/lib/src/phy/fec/polar/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/polar/test/polar_chain_test.c b/lib/src/phy/fec/polar/test/polar_chain_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/polar/test/polar_interleaver_gold.h b/lib/src/phy/fec/polar/test/polar_interleaver_gold.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/polar/test/polar_interleaver_test.c b/lib/src/phy/fec/polar/test/polar_interleaver_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/polar/test/polar_sets.c b/lib/src/phy/fec/polar/test/polar_sets.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/polar/test/polar_sets.h b/lib/src/phy/fec/polar/test/polar_sets.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/polar/test/subchannel_allocation.c b/lib/src/phy/fec/polar/test/subchannel_allocation.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/polar/test/subchannel_allocation.h b/lib/src/phy/fec/polar/test/subchannel_allocation.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/softbuffer.c b/lib/src/phy/fec/softbuffer.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/test/CMakeLists.txt b/lib/src/phy/fec/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/test/crc_test.c b/lib/src/phy/fec/test/crc_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/test/crc_test.h b/lib/src/phy/fec/test/crc_test.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/turbo/CMakeLists.txt b/lib/src/phy/fec/turbo/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/turbo/rm_conv.c b/lib/src/phy/fec/turbo/rm_conv.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/turbo/rm_turbo.c b/lib/src/phy/fec/turbo/rm_turbo.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/turbo/tc_interl_lte.c b/lib/src/phy/fec/turbo/tc_interl_lte.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/turbo/tc_interl_umts.c b/lib/src/phy/fec/turbo/tc_interl_umts.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/turbo/test/CMakeLists.txt b/lib/src/phy/fec/turbo/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/turbo/test/rm_conv_test.c b/lib/src/phy/fec/turbo/test/rm_conv_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/turbo/test/rm_turbo_test.c b/lib/src/phy/fec/turbo/test/rm_turbo_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/turbo/test/turbocoder_test.c b/lib/src/phy/fec/turbo/test/turbocoder_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/turbo/test/turbodecoder_test.c b/lib/src/phy/fec/turbo/test/turbodecoder_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/turbo/test/turbodecoder_test.h b/lib/src/phy/fec/turbo/test/turbodecoder_test.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/turbo/turbocoder.c b/lib/src/phy/fec/turbo/turbocoder.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/turbo/turbodecoder.c b/lib/src/phy/fec/turbo/turbodecoder.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/turbo/turbodecoder_gen.c b/lib/src/phy/fec/turbo/turbodecoder_gen.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/turbo/turbodecoder_sse.c b/lib/src/phy/fec/turbo/turbodecoder_sse.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/utils_avx2.h b/lib/src/phy/fec/utils_avx2.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/fec/utils_avx512.h b/lib/src/phy/fec/utils_avx512.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/gnb/CMakeLists.txt b/lib/src/phy/gnb/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/gnb/gnb_dl.c b/lib/src/phy/gnb/gnb_dl.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/gnb/gnb_ul.c b/lib/src/phy/gnb/gnb_ul.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/io/CMakeLists.txt b/lib/src/phy/io/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/io/binsource.c b/lib/src/phy/io/binsource.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/io/filesink.c b/lib/src/phy/io/filesink.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/io/filesource.c b/lib/src/phy/io/filesource.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/io/netsink.c b/lib/src/phy/io/netsink.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/io/netsource.c b/lib/src/phy/io/netsource.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/mimo/CMakeLists.txt b/lib/src/phy/mimo/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/mimo/layermap.c b/lib/src/phy/mimo/layermap.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/mimo/precoding.c b/lib/src/phy/mimo/precoding.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/mimo/test/CMakeLists.txt b/lib/src/phy/mimo/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/mimo/test/layermap_test.c b/lib/src/phy/mimo/test/layermap_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/mimo/test/pmi_select_test.c b/lib/src/phy/mimo/test/pmi_select_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/mimo/test/pmi_select_test.h b/lib/src/phy/mimo/test/pmi_select_test.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/mimo/test/precoder_test.c b/lib/src/phy/mimo/test/precoder_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/modem/CMakeLists.txt b/lib/src/phy/modem/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/modem/demod_hard.c b/lib/src/phy/modem/demod_hard.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/modem/demod_soft.c b/lib/src/phy/modem/demod_soft.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/modem/hard_demod_lte.c b/lib/src/phy/modem/hard_demod_lte.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/modem/hard_demod_lte.h b/lib/src/phy/modem/hard_demod_lte.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/modem/lte_tables.c b/lib/src/phy/modem/lte_tables.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/modem/lte_tables.h b/lib/src/phy/modem/lte_tables.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/modem/mod.c b/lib/src/phy/modem/mod.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/modem/modem_table.c b/lib/src/phy/modem/modem_table.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/modem/test/CMakeLists.txt b/lib/src/phy/modem/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/modem/test/modem_test.c b/lib/src/phy/modem/test/modem_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/modem/test/soft_demod_test.c b/lib/src/phy/modem/test/soft_demod_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/CMakeLists.txt b/lib/src/phy/phch/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/cqi.c b/lib/src/phy/phch/cqi.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/csi.c b/lib/src/phy/phch/csi.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/dci.c b/lib/src/phy/phch/dci.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/dci_nbiot.c b/lib/src/phy/phch/dci_nbiot.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/dci_nr.c b/lib/src/phy/phch/dci_nr.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/harq_ack.c b/lib/src/phy/phch/harq_ack.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/mib_sl.c b/lib/src/phy/phch/mib_sl.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/npbch.c b/lib/src/phy/phch/npbch.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/npdcch.c b/lib/src/phy/phch/npdcch.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/npdsch.c b/lib/src/phy/phch/npdsch.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/pbch.c b/lib/src/phy/phch/pbch.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/pbch_msg_nr.c b/lib/src/phy/phch/pbch_msg_nr.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/pbch_nr.c b/lib/src/phy/phch/pbch_nr.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/pcfich.c b/lib/src/phy/phch/pcfich.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/pdcch.c b/lib/src/phy/phch/pdcch.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/pdcch_nr.c b/lib/src/phy/phch/pdcch_nr.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/pdsch.c b/lib/src/phy/phch/pdsch.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/pdsch_nr.c b/lib/src/phy/phch/pdsch_nr.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/phch_cfg_nr.c b/lib/src/phy/phch/phch_cfg_nr.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/phich.c b/lib/src/phy/phch/phich.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/pmch.c b/lib/src/phy/phch/pmch.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/prach.c b/lib/src/phy/phch/prach.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/prach_tables.h b/lib/src/phy/phch/prach_tables.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/prb_dl.c b/lib/src/phy/phch/prb_dl.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/prb_dl.h b/lib/src/phy/phch/prb_dl.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/psbch.c b/lib/src/phy/phch/psbch.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/pscch.c b/lib/src/phy/phch/pscch.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/pssch.c b/lib/src/phy/phch/pssch.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/pucch.c b/lib/src/phy/phch/pucch.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/pucch_cfg_nr.c b/lib/src/phy/phch/pucch_cfg_nr.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/pucch_nr.c b/lib/src/phy/phch/pucch_nr.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/pucch_proc.c b/lib/src/phy/phch/pucch_proc.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/pusch.c b/lib/src/phy/phch/pusch.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/pusch_nr.c b/lib/src/phy/phch/pusch_nr.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/ra.c b/lib/src/phy/phch/ra.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/ra_dl.c b/lib/src/phy/phch/ra_dl.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/ra_dl_nr.c b/lib/src/phy/phch/ra_dl_nr.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/ra_helper.h b/lib/src/phy/phch/ra_helper.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/ra_nbiot.c b/lib/src/phy/phch/ra_nbiot.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/ra_nr.c b/lib/src/phy/phch/ra_nr.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/ra_sl.c b/lib/src/phy/phch/ra_sl.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/ra_ul.c b/lib/src/phy/phch/ra_ul.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/ra_ul_nr.c b/lib/src/phy/phch/ra_ul_nr.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/regs.c b/lib/src/phy/phch/regs.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/sch.c b/lib/src/phy/phch/sch.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/sch_nr.c b/lib/src/phy/phch/sch_nr.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/sci.c b/lib/src/phy/phch/sci.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/sequences.c b/lib/src/phy/phch/sequences.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/tbs_tables.h b/lib/src/phy/phch/tbs_tables.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/tbs_tables_nbiot.h b/lib/src/phy/phch/tbs_tables_nbiot.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/CMakeLists.txt b/lib/src/phy/phch/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/dci_nbiot_test.c b/lib/src/phy/phch/test/dci_nbiot_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/dci_nr_test.c b/lib/src/phy/phch/test/dci_nr_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/dci_test.c b/lib/src/phy/phch/test/dci_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/mib_nr_test.c b/lib/src/phy/phch/test/mib_nr_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/npbch_file_test.c b/lib/src/phy/phch/test/npbch_file_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/npbch_test.c b/lib/src/phy/phch/test/npbch_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/npdcch_file_test.c b/lib/src/phy/phch/test/npdcch_file_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/npdcch_test.c b/lib/src/phy/phch/test/npdcch_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/npdsch_npdcch_file_test.c b/lib/src/phy/phch/test/npdsch_npdcch_file_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/npdsch_test.c b/lib/src/phy/phch/test/npdsch_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/pbch_file_test.c b/lib/src/phy/phch/test/pbch_file_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/pbch_test.c b/lib/src/phy/phch/test/pbch_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/pcfich_file_test.c b/lib/src/phy/phch/test/pcfich_file_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/pcfich_test.c b/lib/src/phy/phch/test/pcfich_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/pdcch_file_test.c b/lib/src/phy/phch/test/pdcch_file_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/pdcch_nr_test.c b/lib/src/phy/phch/test/pdcch_nr_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/pdcch_test.c b/lib/src/phy/phch/test/pdcch_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/pdsch_nr_test.c b/lib/src/phy/phch/test/pdsch_nr_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/pdsch_pdcch_file_test.c b/lib/src/phy/phch/test/pdsch_pdcch_file_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/pdsch_test.c b/lib/src/phy/phch/test/pdsch_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/phich_file_test.c b/lib/src/phy/phch/test/phich_file_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/phich_test.c b/lib/src/phy/phch/test/phich_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/pmch_100prbs_MCS2_SR0.bin b/lib/src/phy/phch/test/pmch_100prbs_MCS2_SR0.bin
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/pmch_file_test.c b/lib/src/phy/phch/test/pmch_file_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/pmch_test.c b/lib/src/phy/phch/test/pmch_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/prach_nr_test_perf.c b/lib/src/phy/phch/test/prach_nr_test_perf.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/prach_test.c b/lib/src/phy/phch/test/prach_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/prach_test_multi.c b/lib/src/phy/phch/test/prach_test_multi.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/prach_test_usrp.c b/lib/src/phy/phch/test/prach_test_usrp.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/psbch_file_test.c b/lib/src/phy/phch/test/psbch_file_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/psbch_test.c b/lib/src/phy/phch/test/psbch_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/pscch_test.c b/lib/src/phy/phch/test/pscch_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/pssch_pscch_file_test.c b/lib/src/phy/phch/test/pssch_pscch_file_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/pssch_test.c b/lib/src/phy/phch/test/pssch_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/pucch_nr_test.c b/lib/src/phy/phch/test/pucch_nr_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/pucch_test.c b/lib/src/phy/phch/test/pucch_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/pusch_nr_bler_test.c b/lib/src/phy/phch/test/pusch_nr_bler_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/pusch_nr_test.c b/lib/src/phy/phch/test/pusch_nr_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/pusch_test.c b/lib/src/phy/phch/test/pusch_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/ra_nr_test.c b/lib/src/phy/phch/test/ra_nr_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/sch_nr_test.c b/lib/src/phy/phch/test/sch_nr_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/signal.1.92M.amar.dat b/lib/src/phy/phch/test/signal.1.92M.amar.dat
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/signal.1.92M.dat b/lib/src/phy/phch/test/signal.1.92M.dat
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/signal.10M.dat b/lib/src/phy/phch/test/signal.10M.dat
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/signal_nbiot_amari_nid0_sfn514_sib2.bin b/lib/src/phy/phch/test/signal_nbiot_amari_nid0_sfn514_sib2.bin
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/signal_nbiot_dci_formatN0_L_1_nid0_tti_8624_rnti_0x102.bin b/lib/src/phy/phch/test/signal_nbiot_dci_formatN0_L_1_nid0_tti_8624_rnti_0x102.bin
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/signal_nbiot_dci_formatN1_nid0_tti_5461_rnti_0x89.bin b/lib/src/phy/phch/test/signal_nbiot_dci_formatN1_nid0_tti_5461_rnti_0x89.bin
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/signal_nbiot_nid256_r14_sf0.bin b/lib/src/phy/phch/test/signal_nbiot_nid256_r14_sf0.bin
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/signal_nbiot_nid257_r13_sf0.bin b/lib/src/phy/phch/test/signal_nbiot_nid257_r13_sf0.bin
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/signal_nbiot_nid257_r14_sf0.bin b/lib/src/phy/phch/test/signal_nbiot_nid257_r14_sf0.bin
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/signal_sidelink_cmw500_f5.92e9_s11.52e6_50prb_slss_id169.dat b/lib/src/phy/phch/test/signal_sidelink_cmw500_f5.92e9_s11.52e6_50prb_slss_id169.dat
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/signal_sidelink_huawei_s11.52e6_50prb_10prb_offset_with_retx.dat b/lib/src/phy/phch/test/signal_sidelink_huawei_s11.52e6_50prb_10prb_offset_with_retx.dat
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/signal_sidelink_ideal_tm2_p100_c335_s30.72e6.dat b/lib/src/phy/phch/test/signal_sidelink_ideal_tm2_p100_c335_s30.72e6.dat
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/signal_sidelink_ideal_tm2_p15_c84_s3.84e6.dat b/lib/src/phy/phch/test/signal_sidelink_ideal_tm2_p15_c84_s3.84e6.dat
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/signal_sidelink_ideal_tm2_p25_c168_s7.68e6.dat b/lib/src/phy/phch/test/signal_sidelink_ideal_tm2_p25_c168_s7.68e6.dat
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/signal_sidelink_ideal_tm2_p50_c252_s15.36e6.dat b/lib/src/phy/phch/test/signal_sidelink_ideal_tm2_p50_c252_s15.36e6.dat
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/signal_sidelink_ideal_tm2_p50_c252_s15.36e6_ext.dat b/lib/src/phy/phch/test/signal_sidelink_ideal_tm2_p50_c252_s15.36e6_ext.dat
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/signal_sidelink_ideal_tm2_p6_c0_s1.92e6.dat b/lib/src/phy/phch/test/signal_sidelink_ideal_tm2_p6_c0_s1.92e6.dat
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/signal_sidelink_ideal_tm4_p100_c335_size10_num10_cshift0_s30.72e6.dat b/lib/src/phy/phch/test/signal_sidelink_ideal_tm4_p100_c335_size10_num10_cshift0_s30.72e6.dat
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/signal_sidelink_ideal_tm4_p15_c84_size5_num3_cshift0_s3.84e6.dat b/lib/src/phy/phch/test/signal_sidelink_ideal_tm4_p15_c84_size5_num3_cshift0_s3.84e6.dat
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/signal_sidelink_ideal_tm4_p25_c168_size5_num5_cshift0_s7.68e6.dat b/lib/src/phy/phch/test/signal_sidelink_ideal_tm4_p25_c168_size5_num5_cshift0_s7.68e6.dat
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/signal_sidelink_ideal_tm4_p50_c252_size10_num5_cshift0_s15.36e6.dat b/lib/src/phy/phch/test/signal_sidelink_ideal_tm4_p50_c252_size10_num5_cshift0_s15.36e6.dat
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/test/signal_sidelink_ideal_tm4_p6_c0_size6_num1_cshift0_s1.92e6.dat b/lib/src/phy/phch/test/signal_sidelink_ideal_tm4_p6_c0_size6_num1_cshift0_s1.92e6.dat
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/uci.c b/lib/src/phy/phch/uci.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/phch/uci_nr.c b/lib/src/phy/phch/uci_nr.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/resampling/CMakeLists.txt b/lib/src/phy/resampling/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/resampling/decim.c b/lib/src/phy/resampling/decim.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/resampling/interp.c b/lib/src/phy/resampling/interp.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/resampling/resample_arb.c b/lib/src/phy/resampling/resample_arb.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/resampling/resampler.c b/lib/src/phy/resampling/resampler.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/resampling/test/CMakeLists.txt b/lib/src/phy/resampling/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/resampling/test/resample_arb_bench.c b/lib/src/phy/resampling/test/resample_arb_bench.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/resampling/test/resample_arb_test.c b/lib/src/phy/resampling/test/resample_arb_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/resampling/test/resampler_test.c b/lib/src/phy/resampling/test/resampler_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/rf/CMakeLists.txt b/lib/src/phy/rf/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/rf/rf_blade_imp.c b/lib/src/phy/rf/rf_blade_imp.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/rf/rf_blade_imp.h b/lib/src/phy/rf/rf_blade_imp.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/rf/rf_dev.h b/lib/src/phy/rf/rf_dev.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/rf/rf_file_imp.c b/lib/src/phy/rf/rf_file_imp.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/rf/rf_file_imp.h b/lib/src/phy/rf/rf_file_imp.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/rf/rf_file_imp_rx.c b/lib/src/phy/rf/rf_file_imp_rx.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/rf/rf_file_imp_trx.h b/lib/src/phy/rf/rf_file_imp_trx.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/rf/rf_file_imp_tx.c b/lib/src/phy/rf/rf_file_imp_tx.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/rf/rf_file_test.c b/lib/src/phy/rf/rf_file_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/rf/rf_helper.h b/lib/src/phy/rf/rf_helper.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/rf/rf_imp.c b/lib/src/phy/rf/rf_imp.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/rf/rf_plugin.h b/lib/src/phy/rf/rf_plugin.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/rf/rf_skiq_imp.c b/lib/src/phy/rf/rf_skiq_imp.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/rf/rf_skiq_imp.h b/lib/src/phy/rf/rf_skiq_imp.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/rf/rf_skiq_imp_card.c b/lib/src/phy/rf/rf_skiq_imp_card.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/rf/rf_skiq_imp_card.h b/lib/src/phy/rf/rf_skiq_imp_card.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/rf/rf_skiq_imp_cfg.h b/lib/src/phy/rf/rf_skiq_imp_cfg.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/rf/rf_skiq_imp_port.c b/lib/src/phy/rf/rf_skiq_imp_port.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/rf/rf_skiq_imp_port.h b/lib/src/phy/rf/rf_skiq_imp_port.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/rf/rf_soapy_imp.c b/lib/src/phy/rf/rf_soapy_imp.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/rf/rf_soapy_imp.h b/lib/src/phy/rf/rf_soapy_imp.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/rf/rf_uhd_generic.h b/lib/src/phy/rf/rf_uhd_generic.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/rf/rf_uhd_imp.cc b/lib/src/phy/rf/rf_uhd_imp.cc
old mode 100644
new mode 100755
diff --git a/lib/src/phy/rf/rf_uhd_imp.h b/lib/src/phy/rf/rf_uhd_imp.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/rf/rf_uhd_rfnoc.h b/lib/src/phy/rf/rf_uhd_rfnoc.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/rf/rf_uhd_safe.h b/lib/src/phy/rf/rf_uhd_safe.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/rf/rf_utils.c b/lib/src/phy/rf/rf_utils.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/rf/rf_zmq_imp.c b/lib/src/phy/rf/rf_zmq_imp.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/rf/rf_zmq_imp.h b/lib/src/phy/rf/rf_zmq_imp.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/rf/rf_zmq_imp_rx.c b/lib/src/phy/rf/rf_zmq_imp_rx.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/rf/rf_zmq_imp_trx.h b/lib/src/phy/rf/rf_zmq_imp_trx.h
old mode 100644
new mode 100755
diff --git a/lib/src/phy/rf/rf_zmq_imp_tx.c b/lib/src/phy/rf/rf_zmq_imp_tx.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/rf/rf_zmq_test.c b/lib/src/phy/rf/rf_zmq_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/rf/rfnoc_test.cc b/lib/src/phy/rf/rfnoc_test.cc
old mode 100644
new mode 100755
diff --git a/lib/src/phy/rf/skiq_pps_test.c b/lib/src/phy/rf/skiq_pps_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/scrambling/CMakeLists.txt b/lib/src/phy/scrambling/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/scrambling/scrambling.c b/lib/src/phy/scrambling/scrambling.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/scrambling/test/CMakeLists.txt b/lib/src/phy/scrambling/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/scrambling/test/scrambling_test.c b/lib/src/phy/scrambling/test/scrambling_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/sync/CMakeLists.txt b/lib/src/phy/sync/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/sync/cfo.c b/lib/src/phy/sync/cfo.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/sync/cp.c b/lib/src/phy/sync/cp.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/sync/find_sss.c b/lib/src/phy/sync/find_sss.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/sync/gen_sss.c b/lib/src/phy/sync/gen_sss.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/sync/npss.c b/lib/src/phy/sync/npss.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/sync/nsss.c b/lib/src/phy/sync/nsss.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/sync/pss.c b/lib/src/phy/sync/pss.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/sync/pss_nr.c b/lib/src/phy/sync/pss_nr.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/sync/psss.c b/lib/src/phy/sync/psss.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/sync/refsignal_dl_sync.c b/lib/src/phy/sync/refsignal_dl_sync.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/sync/sfo.c b/lib/src/phy/sync/sfo.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/sync/ssb.c b/lib/src/phy/sync/ssb.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/sync/sss.c b/lib/src/phy/sync/sss.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/sync/sss_nr.c b/lib/src/phy/sync/sss_nr.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/sync/ssss.c b/lib/src/phy/sync/ssss.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/sync/sync.c b/lib/src/phy/sync/sync.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/sync/sync_nbiot.c b/lib/src/phy/sync/sync_nbiot.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/sync/test/CMakeLists.txt b/lib/src/phy/sync/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/sync/test/cfo_test.c b/lib/src/phy/sync/test/cfo_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/sync/test/n78.fo35028.fs4608M.data b/lib/src/phy/sync/test/n78.fo35028.fs4608M.data
old mode 100644
new mode 100755
diff --git a/lib/src/phy/sync/test/n78.fo367536.fs6144M.data b/lib/src/phy/sync/test/n78.fo367536.fs6144M.data
old mode 100644
new mode 100755
diff --git a/lib/src/phy/sync/test/npss_file.c b/lib/src/phy/sync/test/npss_file.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/sync/test/npss_test.c b/lib/src/phy/sync/test/npss_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/sync/test/npss_usrp.c b/lib/src/phy/sync/test/npss_usrp.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/sync/test/nsss_test.c b/lib/src/phy/sync/test/nsss_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/sync/test/nsss_usrp.c b/lib/src/phy/sync/test/nsss_usrp.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/sync/test/pss_file.c b/lib/src/phy/sync/test/pss_file.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/sync/test/pss_usrp.c b/lib/src/phy/sync/test/pss_usrp.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/sync/test/psss_file_test.c b/lib/src/phy/sync/test/psss_file_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/sync/test/ssb_decode_test.c b/lib/src/phy/sync/test/ssb_decode_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/sync/test/ssb_file_test.c b/lib/src/phy/sync/test/ssb_file_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/sync/test/ssb_grid_test.c b/lib/src/phy/sync/test/ssb_grid_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/sync/test/ssb_measure_test.c b/lib/src/phy/sync/test/ssb_measure_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/sync/test/sync_nbiot_test.c b/lib/src/phy/sync/test/sync_nbiot_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/sync/test/sync_sl_test.c b/lib/src/phy/sync/test/sync_sl_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/sync/test/sync_test.c b/lib/src/phy/sync/test/sync_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/CMakeLists.txt b/lib/src/phy/ue/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/test/CMakeLists.txt b/lib/src/phy/ue/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/test/gen_ack_nr_test.c b/lib/src/phy/ue/test/gen_ack_nr_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/test/gen_ack_test.c b/lib/src/phy/ue/test/gen_ack_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/test/pucch_resource_test.c b/lib/src/phy/ue/test/pucch_resource_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/test/ue_dl_nbiot_test.c b/lib/src/phy/ue/test/ue_dl_nbiot_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/test/ue_dl_nr_file_test.cc b/lib/src/phy/ue/test/ue_dl_nr_file_test.cc
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/test/ue_dl_nr_pci1_rb25_n0_common_L1_ncce0.dat b/lib/src/phy/ue/test/ue_dl_nr_pci1_rb25_n0_common_L1_ncce0.dat
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/test/ue_dl_nr_pci1_rb25_n1_common_L1_ncce0.dat b/lib/src/phy/ue/test/ue_dl_nr_pci1_rb25_n1_common_L1_ncce0.dat
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/test/ue_dl_nr_pci1_rb25_n2_common_L1_ncce0.dat b/lib/src/phy/ue/test/ue_dl_nr_pci1_rb25_n2_common_L1_ncce0.dat
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/test/ue_dl_nr_pci1_rb25_n3_common_L1_ncce0.dat b/lib/src/phy/ue/test/ue_dl_nr_pci1_rb25_n3_common_L1_ncce0.dat
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/test/ue_dl_nr_pci1_rb25_n4_common_L1_ncce0.dat b/lib/src/phy/ue/test/ue_dl_nr_pci1_rb25_n4_common_L1_ncce0.dat
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/test/ue_dl_nr_pci1_rb25_n5_common_L1_ncce0.dat b/lib/src/phy/ue/test/ue_dl_nr_pci1_rb25_n5_common_L1_ncce0.dat
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/test/ue_dl_nr_pci1_rb25_n6_common_L1_ncce0.dat b/lib/src/phy/ue/test/ue_dl_nr_pci1_rb25_n6_common_L1_ncce0.dat
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/test/ue_dl_nr_pci1_rb25_n7_common_L1_ncce0.dat b/lib/src/phy/ue/test/ue_dl_nr_pci1_rb25_n7_common_L1_ncce0.dat
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/test/ue_dl_nr_pci1_rb25_n8_common_L1_ncce0.dat b/lib/src/phy/ue/test/ue_dl_nr_pci1_rb25_n8_common_L1_ncce0.dat
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/test/ue_dl_nr_pci1_rb25_n9_common_L1_ncce0.dat b/lib/src/phy/ue/test/ue_dl_nr_pci1_rb25_n9_common_L1_ncce0.dat
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/test/ue_dl_nr_pci500_rb52_n4_ra_L2_ncce0.dat b/lib/src/phy/ue/test/ue_dl_nr_pci500_rb52_n4_ra_L2_ncce0.dat
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/test/ue_dl_nr_pci500_rb52_rar_s15.36e6.dat b/lib/src/phy/ue/test/ue_dl_nr_pci500_rb52_rar_s15.36e6.dat
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/test/ue_dl_nr_pci500_rb52_rnti0x100_s15.36e6.dat b/lib/src/phy/ue/test/ue_dl_nr_pci500_rb52_rnti0x100_s15.36e6.dat
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/test/ue_dl_nr_pci500_rb52_si_coreset0_idx6_s15.36e6.dat b/lib/src/phy/ue/test/ue_dl_nr_pci500_rb52_si_coreset0_idx6_s15.36e6.dat
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/test/ue_dl_nr_pci500_rb52_si_coreset0_idx7_s15.36e6.dat b/lib/src/phy/ue/test/ue_dl_nr_pci500_rb52_si_coreset0_idx7_s15.36e6.dat
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/test/ue_mib_sync_test_nbiot_usrp.c b/lib/src/phy/ue/test/ue_mib_sync_test_nbiot_usrp.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/test/ue_sync_nr_test.c b/lib/src/phy/ue/test/ue_sync_nr_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/test/ue_sync_test_nbiot_usrp.c b/lib/src/phy/ue/test/ue_sync_test_nbiot_usrp.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/ue_cell_search.c b/lib/src/phy/ue/ue_cell_search.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/ue_cell_search_nbiot.c b/lib/src/phy/ue/ue_cell_search_nbiot.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/ue_dl.c b/lib/src/phy/ue/ue_dl.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/ue_dl_nbiot.c b/lib/src/phy/ue/ue_dl_nbiot.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/ue_dl_nr.c b/lib/src/phy/ue/ue_dl_nr.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/ue_mib.c b/lib/src/phy/ue/ue_mib.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/ue_mib_nbiot.c b/lib/src/phy/ue/ue_mib_nbiot.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/ue_mib_sl.c b/lib/src/phy/ue/ue_mib_sl.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/ue_sync.c b/lib/src/phy/ue/ue_sync.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/ue_sync_nbiot.c b/lib/src/phy/ue/ue_sync_nbiot.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/ue_sync_nr.c b/lib/src/phy/ue/ue_sync_nr.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/ue_ul.c b/lib/src/phy/ue/ue_ul.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/ue/ue_ul_nr.c b/lib/src/phy/ue/ue_ul_nr.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/utils/CMakeLists.txt b/lib/src/phy/utils/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/utils/bit.c b/lib/src/phy/utils/bit.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/utils/cexptab.c b/lib/src/phy/utils/cexptab.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/utils/convolution.c b/lib/src/phy/utils/convolution.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/utils/debug.c b/lib/src/phy/utils/debug.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/utils/filter.c b/lib/src/phy/utils/filter.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/utils/mat.c b/lib/src/phy/utils/mat.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/utils/phy_logger.c b/lib/src/phy/utils/phy_logger.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/utils/primes.c b/lib/src/phy/utils/primes.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/utils/random.cpp b/lib/src/phy/utils/random.cpp
old mode 100644
new mode 100755
diff --git a/lib/src/phy/utils/re_pattern.c b/lib/src/phy/utils/re_pattern.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/utils/ringbuffer.c b/lib/src/phy/utils/ringbuffer.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/utils/test/CMakeLists.txt b/lib/src/phy/utils/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/phy/utils/test/dft_test.c b/lib/src/phy/utils/test/dft_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/utils/test/mat_test.c b/lib/src/phy/utils/test/mat_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/utils/test/re_pattern_test.c b/lib/src/phy/utils/test/re_pattern_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/utils/test/ring_buffer_test.c b/lib/src/phy/utils/test/ring_buffer_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/utils/test/vector_test.c b/lib/src/phy/utils/test/vector_test.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/utils/vector.c b/lib/src/phy/utils/vector.c
old mode 100644
new mode 100755
diff --git a/lib/src/phy/utils/vector_simd.c b/lib/src/phy/utils/vector_simd.c
old mode 100644
new mode 100755
diff --git a/lib/src/radio/CMakeLists.txt b/lib/src/radio/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/radio/channel_mapping.cc b/lib/src/radio/channel_mapping.cc
old mode 100644
new mode 100755
diff --git a/lib/src/radio/radio.cc b/lib/src/radio/radio.cc
old mode 100644
new mode 100755
diff --git a/lib/src/radio/test/CMakeLists.txt b/lib/src/radio/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/radio/test/benchmark_radio.cc b/lib/src/radio/test/benchmark_radio.cc
old mode 100644
new mode 100755
diff --git a/lib/src/radio/test/test_radio_rt_gain.cc b/lib/src/radio/test/test_radio_rt_gain.cc
old mode 100644
new mode 100755
diff --git a/lib/src/rlc/CMakeLists.txt b/lib/src/rlc/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/rlc/bearer_mem_pool.cc b/lib/src/rlc/bearer_mem_pool.cc
old mode 100644
new mode 100755
diff --git a/lib/src/rlc/rlc.cc b/lib/src/rlc/rlc.cc
old mode 100644
new mode 100755
diff --git a/lib/src/rlc/rlc_am_base.cc b/lib/src/rlc/rlc_am_base.cc
old mode 100644
new mode 100755
diff --git a/lib/src/rlc/rlc_am_lte.cc b/lib/src/rlc/rlc_am_lte.cc
old mode 100644
new mode 100755
diff --git a/lib/src/rlc/rlc_am_lte_packing.cc b/lib/src/rlc/rlc_am_lte_packing.cc
old mode 100644
new mode 100755
diff --git a/lib/src/rlc/rlc_am_nr.cc b/lib/src/rlc/rlc_am_nr.cc
old mode 100644
new mode 100755
diff --git a/lib/src/rlc/rlc_am_nr_packing.cc b/lib/src/rlc/rlc_am_nr_packing.cc
old mode 100644
new mode 100755
diff --git a/lib/src/rlc/rlc_tm.cc b/lib/src/rlc/rlc_tm.cc
old mode 100644
new mode 100755
diff --git a/lib/src/rlc/rlc_um_base.cc b/lib/src/rlc/rlc_um_base.cc
old mode 100644
new mode 100755
diff --git a/lib/src/rlc/rlc_um_lte.cc b/lib/src/rlc/rlc_um_lte.cc
old mode 100644
new mode 100755
diff --git a/lib/src/rlc/rlc_um_nr.cc b/lib/src/rlc/rlc_um_nr.cc
old mode 100644
new mode 100755
diff --git a/lib/src/srslog/CMakeLists.txt b/lib/src/srslog/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/srslog/backend_worker.cpp b/lib/src/srslog/backend_worker.cpp
old mode 100644
new mode 100755
diff --git a/lib/src/srslog/backend_worker.h b/lib/src/srslog/backend_worker.h
old mode 100644
new mode 100755
diff --git a/lib/src/srslog/bundled/fmt/format.cc b/lib/src/srslog/bundled/fmt/format.cc
old mode 100644
new mode 100755
diff --git a/lib/src/srslog/bundled/fmt/os.cc b/lib/src/srslog/bundled/fmt/os.cc
old mode 100644
new mode 100755
diff --git a/lib/src/srslog/event_trace.cpp b/lib/src/srslog/event_trace.cpp
old mode 100644
new mode 100755
diff --git a/lib/src/srslog/formatters/json_formatter.cpp b/lib/src/srslog/formatters/json_formatter.cpp
old mode 100644
new mode 100755
diff --git a/lib/src/srslog/formatters/json_formatter.h b/lib/src/srslog/formatters/json_formatter.h
old mode 100644
new mode 100755
diff --git a/lib/src/srslog/formatters/text_formatter.cpp b/lib/src/srslog/formatters/text_formatter.cpp
old mode 100644
new mode 100755
diff --git a/lib/src/srslog/formatters/text_formatter.h b/lib/src/srslog/formatters/text_formatter.h
old mode 100644
new mode 100755
diff --git a/lib/src/srslog/log_backend_impl.h b/lib/src/srslog/log_backend_impl.h
old mode 100644
new mode 100755
diff --git a/lib/src/srslog/object_repository.h b/lib/src/srslog/object_repository.h
old mode 100644
new mode 100755
diff --git a/lib/src/srslog/sinks/buffered_file_sink.h b/lib/src/srslog/sinks/buffered_file_sink.h
old mode 100644
new mode 100755
diff --git a/lib/src/srslog/sinks/file_sink.h b/lib/src/srslog/sinks/file_sink.h
old mode 100644
new mode 100755
diff --git a/lib/src/srslog/sinks/file_utils.h b/lib/src/srslog/sinks/file_utils.h
old mode 100644
new mode 100755
diff --git a/lib/src/srslog/sinks/stream_sink.h b/lib/src/srslog/sinks/stream_sink.h
old mode 100644
new mode 100755
diff --git a/lib/src/srslog/sinks/syslog_sink.h b/lib/src/srslog/sinks/syslog_sink.h
old mode 100644
new mode 100755
diff --git a/lib/src/srslog/srslog.cpp b/lib/src/srslog/srslog.cpp
old mode 100644
new mode 100755
diff --git a/lib/src/srslog/srslog_c.cpp b/lib/src/srslog/srslog_c.cpp
old mode 100644
new mode 100755
diff --git a/lib/src/srslog/srslog_instance.h b/lib/src/srslog/srslog_instance.h
old mode 100644
new mode 100755
diff --git a/lib/src/support/CMakeLists.txt b/lib/src/support/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/support/emergency_handlers.cc b/lib/src/support/emergency_handlers.cc
old mode 100644
new mode 100755
diff --git a/lib/src/support/signal_handler.cc b/lib/src/support/signal_handler.cc
old mode 100644
new mode 100755
diff --git a/lib/src/system/CMakeLists.txt b/lib/src/system/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/src/system/sys_metrics_processor.cc b/lib/src/system/sys_metrics_processor.cc
old mode 100644
new mode 100755
diff --git a/lib/test/CMakeLists.txt b/lib/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/test/adt/CMakeLists.txt b/lib/test/adt/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/test/adt/bounded_bitset_test.cc b/lib/test/adt/bounded_bitset_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/adt/bounded_vector_test.cc b/lib/test/adt/bounded_vector_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/adt/cached_alloc_test.cc b/lib/test/adt/cached_alloc_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/adt/circular_buffer_test.cc b/lib/test/adt/circular_buffer_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/adt/circular_map_test.cc b/lib/test/adt/circular_map_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/adt/expected_test.cc b/lib/test/adt/expected_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/adt/fsm_test.cc b/lib/test/adt/fsm_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/adt/interval_test.cc b/lib/test/adt/interval_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/adt/mem_pool_test.cc b/lib/test/adt/mem_pool_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/adt/observer_test.cc b/lib/test/adt/observer_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/adt/optional_array_test.cc b/lib/test/adt/optional_array_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/adt/optional_test.cc b/lib/test/adt/optional_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/adt/scope_exit_test.cc b/lib/test/adt/scope_exit_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/adt/span_test.cc b/lib/test/adt/span_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/asn1/CMakeLists.txt b/lib/test/asn1/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/test/asn1/asn1_utils_test.cc b/lib/test/asn1/asn1_utils_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/asn1/nas_5g_msg_test.cc b/lib/test/asn1/nas_5g_msg_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/asn1/nas_decoder.cc b/lib/test/asn1/nas_decoder.cc
old mode 100644
new mode 100755
diff --git a/lib/test/asn1/ngap_test.cc b/lib/test/asn1/ngap_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/asn1/rrc_asn1_decoder.cc b/lib/test/asn1/rrc_asn1_decoder.cc
old mode 100644
new mode 100755
diff --git a/lib/test/asn1/rrc_nr_utils_test.cc b/lib/test/asn1/rrc_nr_utils_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/asn1/rrc_test.cc b/lib/test/asn1/rrc_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/asn1/s1ap_test.cc b/lib/test/asn1/s1ap_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/asn1/srsran_asn1_nas_test.cc b/lib/test/asn1/srsran_asn1_nas_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/asn1/srsran_asn1_rrc_dl_ccch_test.cc b/lib/test/asn1/srsran_asn1_rrc_dl_ccch_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/asn1/srsran_asn1_rrc_dl_dcch_test.cc b/lib/test/asn1/srsran_asn1_rrc_dl_dcch_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/asn1/srsran_asn1_rrc_mcch_test.cc b/lib/test/asn1/srsran_asn1_rrc_mcch_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/asn1/srsran_asn1_rrc_meas_test.cc b/lib/test/asn1/srsran_asn1_rrc_meas_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/asn1/srsran_asn1_rrc_nr_test.cc b/lib/test/asn1/srsran_asn1_rrc_nr_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/asn1/srsran_asn1_rrc_ul_dcch_test.cc b/lib/test/asn1/srsran_asn1_rrc_ul_dcch_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/common/CMakeLists.txt b/lib/test/common/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/test/common/bcd_helpers_test.cc b/lib/test/common/bcd_helpers_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/common/byte_buffer_queue_test.cc b/lib/test/common/byte_buffer_queue_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/common/choice_type_test.cc b/lib/test/common/choice_type_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/common/mac_pcap_net_test.cc b/lib/test/common/mac_pcap_net_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/common/multiqueue_test.cc b/lib/test/common/multiqueue_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/common/network_utils_test.cc b/lib/test/common/network_utils_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/common/stack_procedure_test.cc b/lib/test/common/stack_procedure_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/common/task_scheduler_test.cc b/lib/test/common/task_scheduler_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/common/test_eea1.cc b/lib/test/common/test_eea1.cc
old mode 100644
new mode 100755
diff --git a/lib/test/common/test_eea2.cc b/lib/test/common/test_eea2.cc
old mode 100644
new mode 100755
diff --git a/lib/test/common/test_eea3.cc b/lib/test/common/test_eea3.cc
old mode 100644
new mode 100755
diff --git a/lib/test/common/test_eia1.cc b/lib/test/common/test_eia1.cc
old mode 100644
new mode 100755
diff --git a/lib/test/common/test_eia3.cc b/lib/test/common/test_eia3.cc
old mode 100644
new mode 100755
diff --git a/lib/test/common/test_f12345.cc b/lib/test/common/test_f12345.cc
old mode 100644
new mode 100755
diff --git a/lib/test/common/test_security_kdf.cc b/lib/test/common/test_security_kdf.cc
old mode 100644
new mode 100755
diff --git a/lib/test/common/timeout_test.cc b/lib/test/common/timeout_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/common/timer_test.cc b/lib/test/common/timer_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/common/tti_point_test.cc b/lib/test/common/tti_point_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/pdcp/CMakeLists.txt b/lib/test/pdcp/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/test/pdcp/pdcp_base_test.h b/lib/test/pdcp/pdcp_base_test.h
old mode 100644
new mode 100755
diff --git a/lib/test/pdcp/pdcp_lte_test.h b/lib/test/pdcp/pdcp_lte_test.h
old mode 100644
new mode 100755
diff --git a/lib/test/pdcp/pdcp_lte_test_discard_sdu.cc b/lib/test/pdcp/pdcp_lte_test_discard_sdu.cc
old mode 100644
new mode 100755
diff --git a/lib/test/pdcp/pdcp_lte_test_rx.cc b/lib/test/pdcp/pdcp_lte_test_rx.cc
old mode 100644
new mode 100755
diff --git a/lib/test/pdcp/pdcp_lte_test_status_report.cc b/lib/test/pdcp/pdcp_lte_test_status_report.cc
old mode 100644
new mode 100755
diff --git a/lib/test/pdcp/pdcp_nr_test.h b/lib/test/pdcp/pdcp_nr_test.h
old mode 100644
new mode 100755
diff --git a/lib/test/pdcp/pdcp_nr_test_discard_sdu.cc b/lib/test/pdcp/pdcp_nr_test_discard_sdu.cc
old mode 100644
new mode 100755
diff --git a/lib/test/pdcp/pdcp_nr_test_rx.cc b/lib/test/pdcp/pdcp_nr_test_rx.cc
old mode 100644
new mode 100755
diff --git a/lib/test/pdcp/pdcp_nr_test_tx.cc b/lib/test/pdcp/pdcp_nr_test_tx.cc
old mode 100644
new mode 100755
diff --git a/lib/test/phy/CMakeLists.txt b/lib/test/phy/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/test/phy/phy_dl_nr_test.c b/lib/test/phy/phy_dl_nr_test.c
old mode 100644
new mode 100755
diff --git a/lib/test/phy/phy_dl_test.c b/lib/test/phy/phy_dl_test.c
old mode 100644
new mode 100755
diff --git a/lib/test/phy/pucch_ca_test.c b/lib/test/phy/pucch_ca_test.c
old mode 100644
new mode 100755
diff --git a/lib/test/rlc/CMakeLists.txt b/lib/test/rlc/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/test/rlc/rlc_am_control_test.cc b/lib/test/rlc/rlc_am_control_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/rlc/rlc_am_data_test.cc b/lib/test/rlc/rlc_am_data_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/rlc/rlc_am_lte_test.cc b/lib/test/rlc/rlc_am_lte_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/rlc/rlc_am_nr_pdu_test.cc b/lib/test/rlc/rlc_am_nr_pdu_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/rlc/rlc_am_nr_test.cc b/lib/test/rlc/rlc_am_nr_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/rlc/rlc_common_test.cc b/lib/test/rlc/rlc_common_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/rlc/rlc_stress_test.cc b/lib/test/rlc/rlc_stress_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/rlc/rlc_stress_test.h b/lib/test/rlc/rlc_stress_test.h
old mode 100644
new mode 100755
diff --git a/lib/test/rlc/rlc_test_common.h b/lib/test/rlc/rlc_test_common.h
old mode 100644
new mode 100755
diff --git a/lib/test/rlc/rlc_um_data_test.cc b/lib/test/rlc/rlc_um_data_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/rlc/rlc_um_nr_pdu_test.cc b/lib/test/rlc/rlc_um_nr_pdu_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/rlc/rlc_um_nr_test.cc b/lib/test/rlc/rlc_um_nr_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/rlc/rlc_um_test.cc b/lib/test/rlc/rlc_um_test.cc
old mode 100644
new mode 100755
diff --git a/lib/test/srslog/CMakeLists.txt b/lib/test/srslog/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/lib/test/srslog/any_test.cpp b/lib/test/srslog/any_test.cpp
old mode 100644
new mode 100755
diff --git a/lib/test/srslog/benchmarks/frontend_latency.cpp b/lib/test/srslog/benchmarks/frontend_latency.cpp
old mode 100644
new mode 100755
diff --git a/lib/test/srslog/context_test.cpp b/lib/test/srslog/context_test.cpp
old mode 100644
new mode 100755
diff --git a/lib/test/srslog/event_trace_test.cpp b/lib/test/srslog/event_trace_test.cpp
old mode 100644
new mode 100755
diff --git a/lib/test/srslog/file_sink_test.cpp b/lib/test/srslog/file_sink_test.cpp
old mode 100644
new mode 100755
diff --git a/lib/test/srslog/file_test_utils.h b/lib/test/srslog/file_test_utils.h
old mode 100644
new mode 100755
diff --git a/lib/test/srslog/file_utils_test.cpp b/lib/test/srslog/file_utils_test.cpp
old mode 100644
new mode 100755
diff --git a/lib/test/srslog/json_formatter_test.cpp b/lib/test/srslog/json_formatter_test.cpp
old mode 100644
new mode 100755
diff --git a/lib/test/srslog/log_backend_test.cpp b/lib/test/srslog/log_backend_test.cpp
old mode 100644
new mode 100755
diff --git a/lib/test/srslog/log_channel_test.cpp b/lib/test/srslog/log_channel_test.cpp
old mode 100644
new mode 100755
diff --git a/lib/test/srslog/logger_test.cpp b/lib/test/srslog/logger_test.cpp
old mode 100644
new mode 100755
diff --git a/lib/test/srslog/srslog_test.cpp b/lib/test/srslog/srslog_test.cpp
old mode 100644
new mode 100755
diff --git a/lib/test/srslog/syslog_sink_test.cpp b/lib/test/srslog/syslog_sink_test.cpp
old mode 100644
new mode 100755
diff --git a/lib/test/srslog/test_dummies.h b/lib/test/srslog/test_dummies.h
old mode 100644
new mode 100755
diff --git a/lib/test/srslog/testing_helpers.h b/lib/test/srslog/testing_helpers.h
old mode 100644
new mode 100755
diff --git a/lib/test/srslog/text_formatter_test.cpp b/lib/test/srslog/text_formatter_test.cpp
old mode 100644
new mode 100755
diff --git a/srsenb/CMakeLists.txt b/srsenb/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsenb/enb.conf.example b/srsenb/enb.conf.example
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/cfg_parser.h b/srsenb/hdr/cfg_parser.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/common/common_enb.h b/srsenb/hdr/common/common_enb.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/common/rnti_pool.h b/srsenb/hdr/common/rnti_pool.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/enb.h b/srsenb/hdr/enb.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/metrics_csv.h b/srsenb/hdr/metrics_csv.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/metrics_e2.h b/srsenb/hdr/metrics_e2.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/metrics_json.h b/srsenb/hdr/metrics_json.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/metrics_stdout.h b/srsenb/hdr/metrics_stdout.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/parser.h b/srsenb/hdr/parser.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/phy/enb_phy_base.h b/srsenb/hdr/phy/enb_phy_base.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/phy/lte/cc_worker.h b/srsenb/hdr/phy/lte/cc_worker.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/phy/lte/sf_worker.h b/srsenb/hdr/phy/lte/sf_worker.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/phy/lte/worker_pool.h b/srsenb/hdr/phy/lte/worker_pool.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/phy/nr/slot_worker.h b/srsenb/hdr/phy/nr/slot_worker.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/phy/nr/worker_pool.h b/srsenb/hdr/phy/nr/worker_pool.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/phy/phy.h b/srsenb/hdr/phy/phy.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/phy/phy_common.h b/srsenb/hdr/phy/phy_common.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/phy/phy_interfaces.h b/srsenb/hdr/phy/phy_interfaces.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/phy/phy_metrics.h b/srsenb/hdr/phy/phy_metrics.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/phy/phy_ue_db.h b/srsenb/hdr/phy/phy_ue_db.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/phy/prach_worker.h b/srsenb/hdr/phy/prach_worker.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/phy/txrx.h b/srsenb/hdr/phy/txrx.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/enb_stack_base.h b/srsenb/hdr/stack/enb_stack_base.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/enb_stack_lte.h b/srsenb/hdr/stack/enb_stack_lte.h
old mode 100644
new mode 100755
index f3e0ce746..0e31eea54
--- a/srsenb/hdr/stack/enb_stack_lte.h
+++ b/srsenb/hdr/stack/enb_stack_lte.h
@@ -41,6 +41,9 @@
 #include "srsran/interfaces/enb_interfaces.h"
 #include "srsran/srslog/srslog.h"
 
+// fuzzing
+#include "upper/enodeb_statelearner.h"
+
 namespace srsenb {
 
 class gtpu_pdcp_adapter;
@@ -185,6 +188,7 @@ private:
   srsenb::rrc  rrc;
   srsenb::gtpu gtpu;
   srsenb::s1ap s1ap;
+  srsenb::enodeb_statelearner enodeb_statelearner; //Fuzzing
 
   // RAT-specific interfaces
   phy_interface_stack_lte* phy = nullptr;
diff --git a/srsenb/hdr/stack/mac/common/base_ue_buffer_manager.h b/srsenb/hdr/stack/mac/common/base_ue_buffer_manager.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/mac/common/mac_metrics.h b/srsenb/hdr/stack/mac/common/mac_metrics.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/mac/common/sched_config.h b/srsenb/hdr/stack/mac/common/sched_config.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/mac/mac.h b/srsenb/hdr/stack/mac/mac.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/mac/sched.h b/srsenb/hdr/stack/mac/sched.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/mac/sched_carrier.h b/srsenb/hdr/stack/mac/sched_carrier.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/mac/sched_common.h b/srsenb/hdr/stack/mac/sched_common.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/mac/sched_grid.h b/srsenb/hdr/stack/mac/sched_grid.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/mac/sched_helpers.h b/srsenb/hdr/stack/mac/sched_helpers.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/mac/sched_interface.h b/srsenb/hdr/stack/mac/sched_interface.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/mac/sched_lte_common.h b/srsenb/hdr/stack/mac/sched_lte_common.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/mac/sched_phy_ch/sched_dci.h b/srsenb/hdr/stack/mac/sched_phy_ch/sched_dci.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/mac/sched_phy_ch/sched_phy_resource.h b/srsenb/hdr/stack/mac/sched_phy_ch/sched_phy_resource.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/mac/sched_phy_ch/sched_result.h b/srsenb/hdr/stack/mac/sched_phy_ch/sched_result.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/mac/sched_phy_ch/sf_cch_allocator.h b/srsenb/hdr/stack/mac/sched_phy_ch/sf_cch_allocator.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/mac/sched_ue.h b/srsenb/hdr/stack/mac/sched_ue.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/mac/sched_ue_ctrl/sched_dl_cqi.h b/srsenb/hdr/stack/mac/sched_ue_ctrl/sched_dl_cqi.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/mac/sched_ue_ctrl/sched_harq.h b/srsenb/hdr/stack/mac/sched_ue_ctrl/sched_harq.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/mac/sched_ue_ctrl/sched_lch.h b/srsenb/hdr/stack/mac/sched_ue_ctrl/sched_lch.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/mac/sched_ue_ctrl/sched_ue_cell.h b/srsenb/hdr/stack/mac/sched_ue_ctrl/sched_ue_cell.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/mac/sched_ue_ctrl/tpc.h b/srsenb/hdr/stack/mac/sched_ue_ctrl/tpc.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/mac/schedulers/sched_base.h b/srsenb/hdr/stack/mac/schedulers/sched_base.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/mac/schedulers/sched_time_pf.h b/srsenb/hdr/stack/mac/schedulers/sched_time_pf.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/mac/schedulers/sched_time_rr.h b/srsenb/hdr/stack/mac/schedulers/sched_time_rr.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/mac/ta.h b/srsenb/hdr/stack/mac/ta.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/mac/ue.h b/srsenb/hdr/stack/mac/ue.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/rrc/mac_controller.h b/srsenb/hdr/stack/rrc/mac_controller.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/rrc/rrc.h b/srsenb/hdr/stack/rrc/rrc.h
old mode 100644
new mode 100755
index beb1a3957..e2b8784ea
--- a/srsenb/hdr/stack/rrc/rrc.h
+++ b/srsenb/hdr/stack/rrc/rrc.h
@@ -169,6 +169,14 @@ public:
 
   class ue;
 
+  // fuzzing
+  void rrc_send_ue_capability_enquiry_custom(uint16_t rnti,int integrity, int cipher);
+  void rrc_send_counter_check_custom(uint16_t rnti,int integrity, int cipher);
+  void send_rrc_release_custom(uint16_t rnti,int integrity, int cipher);
+  void rrc_send_ue_information_request_custom(uint16_t rnti,int integrity, int cipher);
+  void rrc_send_security_mode_command_custom(uint16_t rnti,int integrity, int eia, int eea);
+  void rrc_send_connection_reconf_custom(uint16_t rnti2, int integrity, int cipher, int set_srb2, int set_drb, int meas_config, int replay);
+
 private:
   // args
   srsran::task_sched_handle task_sched;
@@ -235,6 +243,9 @@ private:
   void rem_user_thread(uint16_t rnti);
 };
 
+// fuzzing
+extern uint16_t rnti_last;
+
 } // namespace srsenb
 
 #endif // SRSENB_RRC_H
diff --git a/srsenb/hdr/stack/rrc/rrc_bearer_cfg.h b/srsenb/hdr/stack/rrc/rrc_bearer_cfg.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/rrc/rrc_cell_cfg.h b/srsenb/hdr/stack/rrc/rrc_cell_cfg.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/rrc/rrc_config.h b/srsenb/hdr/stack/rrc/rrc_config.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/rrc/rrc_config_common.h b/srsenb/hdr/stack/rrc/rrc_config_common.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/rrc/rrc_endc.h b/srsenb/hdr/stack/rrc/rrc_endc.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/rrc/rrc_metrics.h b/srsenb/hdr/stack/rrc/rrc_metrics.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/rrc/rrc_mobility.h b/srsenb/hdr/stack/rrc/rrc_mobility.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/rrc/rrc_paging.h b/srsenb/hdr/stack/rrc/rrc_paging.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/rrc/rrc_ue.h b/srsenb/hdr/stack/rrc/rrc_ue.h
old mode 100644
new mode 100755
index a4b402a1d..58578293d
--- a/srsenb/hdr/stack/rrc/rrc_ue.h
+++ b/srsenb/hdr/stack/rrc/rrc_ue.h
@@ -94,6 +94,16 @@ public:
   void send_ue_cap_enquiry(const std::vector<asn1::rrc::rat_type_opts::options>& rats);
   void send_ue_info_req();
 
+  // fuzzing
+  void send_security_mode_command_custom(int integrity, int eia, int eea);
+  void send_ue_cap_enquiry_custom(int integrity, int cipher);
+  void send_counter_check_custom(int integrity, int cipher);
+  void send_ue_information_request_custom(int integrity, int cipher);
+  void send_connection_release_custom(int integrity, int cipher);
+  void send_connection_reconf_custom(srsran::unique_byte_buffer_t sdu, int integrity, int cipher, int set_srb2, int set_drb, int meas_config, int replay);
+  void send_connection_reconf_replay(srsran::unique_byte_buffer_t pdu);
+  int  update_as_security(uint32_t lcid, int integrity, int cipher);
+
   void parse_ul_dcch(uint32_t lcid, srsran::unique_byte_buffer_t pdu);
 
   /// List of generated RRC events.
diff --git a/srsenb/hdr/stack/rrc/ue_meas_cfg.h b/srsenb/hdr/stack/rrc/ue_meas_cfg.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/rrc/ue_rr_cfg.h b/srsenb/hdr/stack/rrc/ue_rr_cfg.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/s1ap/s1ap.h b/srsenb/hdr/stack/s1ap/s1ap.h
old mode 100644
new mode 100755
index 9fb46418c..267314216
--- a/srsenb/hdr/stack/s1ap/s1ap.h
+++ b/srsenb/hdr/stack/s1ap/s1ap.h
@@ -42,6 +42,9 @@
 #include "srsran/srslog/srslog.h"
 #include <unordered_map>
 
+// fuzzing
+#include "srsran/common/fuzzing.h"
+
 namespace srsenb {
 
 class rrc_interface_s1ap;
@@ -56,7 +59,8 @@ struct ue_ctxt_t {
   struct timeval             init_timestamp = {};
 };
 
-class s1ap : public s1ap_interface_rrc
+class s1ap : public s1ap_interface_rrc, public s1ap_interface_enodeb_statelearner
+// , public srsran::thread
 {
   using s1ap_proc_id_t = asn1::s1ap::s1ap_elem_procs_o::init_msg_c::types_opts::options;
 
@@ -67,7 +71,7 @@ public:
   s1ap(srsran::task_sched_handle   task_sched_,
        srslog::basic_logger&       logger,
        srsran::socket_manager_itf* rx_socket_handler);
-  int  init(const s1ap_args_t& args_, rrc_interface_s1ap* rrc_);
+  int  init(const s1ap_args_t& args_, rrc_interface_s1ap* rrc_, enodeb_statelearner_interface_s1ap *enodeb_statelearner_); // fuzzing
   void stop();
   void get_metrics(s1ap_metrics_t& m);
 
@@ -120,6 +124,9 @@ public:
   handle_mme_rx_msg(srsran::unique_byte_buffer_t pdu, const sockaddr_in& from, const sctp_sndrcvinfo& sri, int flags);
   void start_pcap(srsran::s1ap_pcap* pcap_);
 
+  //enodeb_statelearner interface
+  bool execute_command(uint8_t* msg, uint16_t len); // Fuzzing
+
 private:
   static const int MME_PORT        = 36412;
   static const int ADDR_FAMILY     = AF_INET;
@@ -137,6 +144,9 @@ private:
   srsran::task_queue_handle   mme_task_queue;
   srsran::socket_manager_itf* rx_socket_handler;
 
+  // fuzzing
+  enodeb_statelearner_interface_s1ap *enodeb_statelearner;
+
   srsran::unique_socket mme_socket;
   struct sockaddr_in    mme_addr            = {}; // MME address
   bool                  mme_connected       = false;
@@ -363,6 +373,10 @@ private:
   void        log_s1ap_msg(const asn1::s1ap::s1ap_pdu_c& msg, srsran::const_span<uint8_t> sdu, bool is_rx);
 
   srsran::proc_t<s1_setup_proc_t> s1setup_proc;
+
+    //============================ Fuzzing ====================
+  bool handle_statelearner_query(uint8_t  msg_type);
+  bool notify_response(unsigned char* response, unsigned short size);
 };
 
 } // namespace srsenb
diff --git a/srsenb/hdr/stack/s1ap/s1ap_metrics.h b/srsenb/hdr/stack/s1ap/s1ap_metrics.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/upper/enb_parse_cmd.h b/srsenb/hdr/stack/upper/enb_parse_cmd.h
new file mode 100755
index 000000000..3bfd0f572
--- /dev/null
+++ b/srsenb/hdr/stack/upper/enb_parse_cmd.h
@@ -0,0 +1,38 @@
+#pragma once
+
+#ifndef ENB_PARSE_CMD_H
+#define ENB_PARSE_CMD_H
+
+#include <cstdint>
+#include <vector>
+#include <string>
+// #include "srsepc/hdr/mme/nas.h"
+namespace enb {
+    typedef struct {
+        char messageFieldName[50];
+        int messageFieldValue;
+    } MessageField;
+
+    typedef struct {
+        char messageName[256];
+        MessageField messageFields[10];
+        int numberOfFields;
+    } Message;
+
+    Message parseMessage(const uint8_t *data, size_t length);
+    void printMessage(const Message& message);
+    // void handleMessageCmd(Message message, srsepc::nas* myNasInstance);
+
+
+    uint8_t *handleNullAction();
+
+    uint8_t* handleRRCSecurityModeComplete();
+    uint8_t* handleRRCUECapInfo();
+    uint8_t* handleCounterCheckResponse();
+    uint8_t* handleRRCSecurityModeComplete();
+    uint8_t* handleUEInformationResponse();
+    uint8_t* handleRRCReconfComplete();
+    uint8_t* handleRRCSecurityModeFailure();
+}
+
+#endif // ENB_PARSE_CMD_H
\ No newline at end of file
diff --git a/srsenb/hdr/stack/upper/enodeb_statelearner.h b/srsenb/hdr/stack/upper/enodeb_statelearner.h
new file mode 100755
index 000000000..c0a133a4b
--- /dev/null
+++ b/srsenb/hdr/stack/upper/enodeb_statelearner.h
@@ -0,0 +1,51 @@
+//
+// Created by rafiul on 9/11/19.
+//
+
+#ifndef SRSRAN_ENODEB_STATELEARNER_H
+#define SRSRAN_ENODEB_STATELEARNER_H
+
+#include "srsran/common/buffer_pool.h"
+#include "srsran/common/threads.h"
+#include "srsran/interfaces/enb_s1ap_interfaces.h"
+
+
+namespace srsenb
+{
+    class enodeb_statelearner:
+            public enodeb_statelearner_interface_s1ap,
+            public srsran::thread
+    {
+    public:
+        // static enodeb_statelearner* get_instance(void);
+        // static void cleanup(void);
+        enodeb_statelearner();
+        int init(s1ap_interface_enodeb_statelearner *s1ap_);
+        void stop();
+        static enodeb_statelearner* get_instance(void);
+        // server
+        int statelearner_listen();
+        int get_enodeb_statelearner();
+
+        //client
+        //bool connect_statelearner();
+        bool notify_response(uint8_t *msg, uint16_t len);
+        void run_thread();
+
+    private:
+        srsran::byte_buffer_pool   *m_pool;
+        static enodeb_statelearner *m_instance;
+
+        s1ap_interface_enodeb_statelearner* m_s1ap;
+
+        in_addr_t m_enodeb_statelearner_ip;
+        int m_enodeb_statelearner_sock;
+
+        bool running = false;
+        bool statelearner_connected       = false;
+    };
+
+}
+
+
+#endif //SRSLTE_ENODEB_STATELEARNER_H
diff --git a/srsenb/hdr/stack/upper/gtpu.h b/srsenb/hdr/stack/upper/gtpu.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/upper/gtpu_pdcp_adapter.h b/srsenb/hdr/stack/upper/gtpu_pdcp_adapter.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/stack/upper/pdcp.h b/srsenb/hdr/stack/upper/pdcp.h
old mode 100644
new mode 100755
index a1ddc85a0..60dd87404
--- a/srsenb/hdr/stack/upper/pdcp.h
+++ b/srsenb/hdr/stack/upper/pdcp.h
@@ -69,6 +69,10 @@ public:
   void send_status_report(uint16_t rnti, uint32_t lcid) override;
   void reestablish(uint16_t rnti) override;
 
+  // fuzzing
+  void disable_integrity(uint16_t rnti, uint32_t lcid) override;
+  void disable_encryption(uint16_t rnti, uint32_t lcid) override;
+
   // pdcp_interface_gtpu
   std::map<uint32_t, srsran::unique_byte_buffer_t> get_buffered_pdus(uint16_t rnti, uint32_t lcid) override;
 
diff --git a/srsenb/hdr/stack/upper/rlc.h b/srsenb/hdr/stack/upper/rlc.h
old mode 100644
new mode 100755
diff --git a/srsenb/hdr/x2_adapter.h b/srsenb/hdr/x2_adapter.h
old mode 100644
new mode 100755
diff --git a/srsenb/rb.conf.example b/srsenb/rb.conf.example
old mode 100644
new mode 100755
diff --git a/srsenb/rr.conf.example b/srsenb/rr.conf.example
old mode 100644
new mode 100755
diff --git a/srsenb/sib.conf.example b/srsenb/sib.conf.example
old mode 100644
new mode 100755
diff --git a/srsenb/sib.conf.mbsfn.example b/srsenb/sib.conf.mbsfn.example
old mode 100644
new mode 100755
diff --git a/srsenb/src/CMakeLists.txt b/srsenb/src/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsenb/src/common/CMakeLists.txt b/srsenb/src/common/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsenb/src/common/rnti_pool.cc b/srsenb/src/common/rnti_pool.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/enb.cc b/srsenb/src/enb.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/enb_cfg_parser.cc b/srsenb/src/enb_cfg_parser.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/enb_cfg_parser.h b/srsenb/src/enb_cfg_parser.h
old mode 100644
new mode 100755
diff --git a/srsenb/src/main.cc b/srsenb/src/main.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/metrics_csv.cc b/srsenb/src/metrics_csv.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/metrics_e2.cc b/srsenb/src/metrics_e2.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/metrics_json.cc b/srsenb/src/metrics_json.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/metrics_stdout.cc b/srsenb/src/metrics_stdout.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/parser.cc b/srsenb/src/parser.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/phy/CMakeLists.txt b/srsenb/src/phy/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsenb/src/phy/lte/cc_worker.cc b/srsenb/src/phy/lte/cc_worker.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/phy/lte/sf_worker.cc b/srsenb/src/phy/lte/sf_worker.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/phy/lte/worker_pool.cc b/srsenb/src/phy/lte/worker_pool.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/phy/nr/slot_worker.cc b/srsenb/src/phy/nr/slot_worker.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/phy/nr/worker_pool.cc b/srsenb/src/phy/nr/worker_pool.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/phy/phy.cc b/srsenb/src/phy/phy.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/phy/phy_common.cc b/srsenb/src/phy/phy_common.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/phy/phy_ue_db.cc b/srsenb/src/phy/phy_ue_db.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/phy/prach_worker.cc b/srsenb/src/phy/prach_worker.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/phy/txrx.cc b/srsenb/src/phy/txrx.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/stack/CMakeLists.txt b/srsenb/src/stack/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsenb/src/stack/enb_stack_lte.cc b/srsenb/src/stack/enb_stack_lte.cc
old mode 100644
new mode 100755
index 2c981a21e..8791d6e9b
--- a/srsenb/src/stack/enb_stack_lte.cc
+++ b/srsenb/src/stack/enb_stack_lte.cc
@@ -139,10 +139,15 @@ int enb_stack_lte::init(const stack_args_t&      args_,
     stack_logger.error("Couldn't initialize RRC");
     return SRSRAN_ERROR;
   }
-  if (s1ap.init(args.s1ap, &rrc) != SRSRAN_SUCCESS) {
+  if (s1ap.init(args.s1ap, &rrc, &enodeb_statelearner) != SRSRAN_SUCCESS) { // fuzzing
     stack_logger.error("Couldn't initialize S1AP");
     return SRSRAN_ERROR;
   }
+  // fuzzing
+  if (enodeb_statelearner.init(&s1ap) != SRSRAN_SUCCESS) {
+    stack_logger.error("Couldn't initialize enodeb_statelearner");
+    return SRSRAN_ERROR;
+  }
 
   gtpu_args_t gtpu_args;
   gtpu_args.embms_enable                 = args.embms.enable;
@@ -187,6 +192,7 @@ void enb_stack_lte::stop_impl()
 {
   get_rx_io_manager().stop();
 
+  enodeb_statelearner.stop(); // fuzzing
   s1ap.stop();
   gtpu.stop();
   mac.stop();
diff --git a/srsenb/src/stack/mac/CMakeLists.txt b/srsenb/src/stack/mac/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsenb/src/stack/mac/common/CMakeLists.txt b/srsenb/src/stack/mac/common/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsenb/src/stack/mac/common/base_ue_buffer_manager.cc b/srsenb/src/stack/mac/common/base_ue_buffer_manager.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/stack/mac/mac.cc b/srsenb/src/stack/mac/mac.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/stack/mac/sched.cc b/srsenb/src/stack/mac/sched.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/stack/mac/sched_carrier.cc b/srsenb/src/stack/mac/sched_carrier.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/stack/mac/sched_grid.cc b/srsenb/src/stack/mac/sched_grid.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/stack/mac/sched_helpers.cc b/srsenb/src/stack/mac/sched_helpers.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/stack/mac/sched_phy_ch/sched_dci.cc b/srsenb/src/stack/mac/sched_phy_ch/sched_dci.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/stack/mac/sched_phy_ch/sched_phy_resource.cc b/srsenb/src/stack/mac/sched_phy_ch/sched_phy_resource.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/stack/mac/sched_phy_ch/sf_cch_allocator.cc b/srsenb/src/stack/mac/sched_phy_ch/sf_cch_allocator.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/stack/mac/sched_ue.cc b/srsenb/src/stack/mac/sched_ue.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/stack/mac/sched_ue_ctrl/sched_dl_cqi.cc b/srsenb/src/stack/mac/sched_ue_ctrl/sched_dl_cqi.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/stack/mac/sched_ue_ctrl/sched_harq.cc b/srsenb/src/stack/mac/sched_ue_ctrl/sched_harq.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/stack/mac/sched_ue_ctrl/sched_lch.cc b/srsenb/src/stack/mac/sched_ue_ctrl/sched_lch.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/stack/mac/sched_ue_ctrl/sched_ue_cell.cc b/srsenb/src/stack/mac/sched_ue_ctrl/sched_ue_cell.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/stack/mac/schedulers/CMakeLists.txt b/srsenb/src/stack/mac/schedulers/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsenb/src/stack/mac/schedulers/sched_base.cc b/srsenb/src/stack/mac/schedulers/sched_base.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/stack/mac/schedulers/sched_time_pf.cc b/srsenb/src/stack/mac/schedulers/sched_time_pf.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/stack/mac/schedulers/sched_time_rr.cc b/srsenb/src/stack/mac/schedulers/sched_time_rr.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/stack/mac/ue.cc b/srsenb/src/stack/mac/ue.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/stack/rrc/CMakeLists.txt b/srsenb/src/stack/rrc/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsenb/src/stack/rrc/mac_controller.cc b/srsenb/src/stack/rrc/mac_controller.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/stack/rrc/rrc.cc b/srsenb/src/stack/rrc/rrc.cc
old mode 100644
new mode 100755
index 59611d2c0..1604cff62
--- a/srsenb/src/stack/rrc/rrc.cc
+++ b/srsenb/src/stack/rrc/rrc.cc
@@ -42,6 +42,9 @@ using namespace asn1::rrc;
 
 namespace srsenb {
 
+// fuzzing
+uint16_t rnti_last = 0;
+
 rrc::rrc(srsran::task_sched_handle task_sched_, enb_bearer_manager& manager_) :
   logger(srslog::fetch_basic_logger("RRC")), bearer_manager(manager_), task_sched(task_sched_), rx_pdu_queue(128)
 {
@@ -234,6 +237,9 @@ void rrc::protocol_failure(uint16_t rnti)
 // This function is called from PRACH worker (can wait)
 int rrc::add_user(uint16_t rnti, const sched_interface::ue_cfg_t& sched_ue_cfg)
 {
+  // fuzzing
+  rnti_last = rnti;
+
   auto user_it = users.find(rnti);
   if (user_it == users.end()) {
     if (rnti != SRSRAN_MRNTI) {
@@ -720,6 +726,10 @@ void rrc::rem_user(uint16_t rnti)
 
     srsran::console("Disconnecting rnti=0x%x.\n", rnti);
     logger.info("Removed user rnti=0x%x", rnti);
+
+    // fuzzing
+    rnti_last = 0;
+
   } else {
     logger.error("Removing user rnti=0x%x (does not exist)", rnti);
   }
@@ -1054,7 +1064,7 @@ void rrc::tti_clock()
         parse_ul_dcch(ue, p.lcid, std::move(p.pdu));
         break;
       case LCID_REM_USER:
-        rem_user(p.rnti);
+        // rem_user(p.rnti);
         break;
       case LCID_REL_USER:
         process_release_complete(p.rnti);
@@ -1112,4 +1122,50 @@ void rrc::log_rxtx_pdu_impl(direction_t             dir,
   logger.info(pdu.data(), pdu.size(), "%s", srsran::to_c_str(membuf));
 }
 
+// fuzzing
+void rrc::rrc_send_ue_capability_enquiry_custom(uint16_t rnti2,int integrity, int cipher) {
+  if (rnti_last != 0) {
+    users.at(rnti_last).get()->send_ue_cap_enquiry_custom(integrity, cipher);
+  }
+}
+
+void rrc::rrc_send_ue_information_request_custom(uint16_t rnti2,int integrity, int cipher) {
+  if (rnti_last != 0) {
+    users.at(rnti_last).get()->send_ue_information_request_custom(integrity, cipher);
+  }
+}
+
+void rrc::rrc_send_counter_check_custom(uint16_t rnti2,int integrity, int cipher) {
+  if (rnti_last != 0) {
+    users.at(rnti_last).get()->send_counter_check_custom(integrity, cipher);
+  }
+}
+
+void rrc::rrc_send_security_mode_command_custom(uint16_t rnti2,int integrity, int eia, int eea) {
+  if (rnti_last != 0) {
+    users.at(rnti_last).get()->send_security_mode_command_custom(integrity, eia, eea);
+    // users.at(rnti_last).get()->send_security_mode_command();
+
+  }
+}
+
+void rrc::rrc_send_connection_reconf_custom(uint16_t rnti2, int integrity, int cipher, int set_srb2, int set_drb, int meas_config, int replay) {
+  if (rnti_last != 0) {
+    srsran::unique_byte_buffer_t pdu2 = srsran::make_byte_buffer();
+    users.at(rnti_last).get()->send_connection_reconf_custom(std::move(pdu2), integrity, cipher, set_srb2, set_drb, meas_config, replay);
+    // users.at(rnti_last).get()->send_connection_reconf();
+
+  }
+}
+
+void rrc::send_rrc_release_custom(uint16_t rnti2,int integrity, int cipher) {
+  if (rnti_last != 0) {
+    srsran::unique_byte_buffer_t pdu2 = srsran::make_byte_buffer();
+    users.at(rnti_last).get()->send_connection_release_custom(integrity, cipher);
+    // users.at(rnti_last).get()->send_connection_reconf();
+
+  }
+}
+
+
 } // namespace srsenb
diff --git a/srsenb/src/stack/rrc/rrc_bearer_cfg.cc b/srsenb/src/stack/rrc/rrc_bearer_cfg.cc
old mode 100644
new mode 100755
index c68627471..968723d60
--- a/srsenb/src/stack/rrc/rrc_bearer_cfg.cc
+++ b/srsenb/src/stack/rrc/rrc_bearer_cfg.cc
@@ -173,6 +173,7 @@ void security_cfg_handler::set_security_key(const asn1::fixed_bitstring<256, fal
   logger.info(k_enb, 32, "Key eNodeB (k_enb)");
 
   generate_as_keys();
+  printf("set_security_key\n");
 }
 
 void security_cfg_handler::generate_as_keys()
@@ -189,6 +190,7 @@ void security_cfg_handler::generate_as_keys()
   logger.info(sec_cfg.k_rrc_enc.data(), 32, "RRC Encryption Key (k_rrc_enc)");
   logger.info(sec_cfg.k_rrc_int.data(), 32, "RRC Integrity Key (k_rrc_int)");
   logger.info(sec_cfg.k_up_enc.data(), 32, "UP Encryption Key (k_up_enc)");
+  printf("generate_ac_keys\n");
 }
 
 void security_cfg_handler::regenerate_keys_handover(uint32_t new_pci, uint32_t new_dl_earfcn)
diff --git a/srsenb/src/stack/rrc/rrc_cell_cfg.cc b/srsenb/src/stack/rrc/rrc_cell_cfg.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/stack/rrc/rrc_endc.cc b/srsenb/src/stack/rrc/rrc_endc.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/stack/rrc/rrc_mobility.cc b/srsenb/src/stack/rrc/rrc_mobility.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/stack/rrc/rrc_ue.cc b/srsenb/src/stack/rrc/rrc_ue.cc
old mode 100644
new mode 100755
index 36f11594e..6287db1e7
--- a/srsenb/src/stack/rrc/rrc_ue.cc
+++ b/srsenb/src/stack/rrc/rrc_ue.cc
@@ -33,6 +33,10 @@
 #include "srsran/interfaces/enb_s1ap_interfaces.h"
 #include "srsran/support/srsran_assert.h"
 
+// fuzzing
+#include "srsenb/hdr/stack/upper/enodeb_statelearner.h"
+#include "srsenb/hdr/stack/upper/enb_parse_cmd.h"
+
 using namespace asn1::rrc;
 
 namespace srsenb {
@@ -44,6 +48,9 @@ namespace srsenb {
   need extra protection.
 *******************************************************************************/
 
+int global_eea = 0;
+int global_eia = 0;
+
 rrc::ue::ue(rrc* outer_rrc, uint16_t rnti_, const sched_interface::ue_cfg_t& sched_ue_cfg) :
   parent(outer_rrc),
   rnti(rnti_),
@@ -351,6 +358,7 @@ void rrc::ue::parse_ul_dcch(uint32_t lcid, srsran::unique_byte_buffer_t pdu)
 
   transaction_id = 0;
 
+  // fuzzing: TODO: check if any other messages needed
   switch (ul_dcch_msg.msg.c1().type()) {
     case ul_dcch_msg_type_c::c1_c_::types::rrc_conn_setup_complete:
       save_ul_message(std::move(original_pdu));
@@ -382,6 +390,13 @@ void rrc::ue::parse_ul_dcch(uint32_t lcid, srsran::unique_byte_buffer_t pdu)
       parent->s1ap->write_pdu(rnti, std::move(pdu));
       break;
     case ul_dcch_msg_type_c::c1_c_::types::rrc_conn_recfg_complete:
+      // fuzzing
+      {
+        uint8_t* messageStr = enb::handleRRCReconfComplete();
+        uint16_t len = static_cast<uint16_t>(strlen((char*)messageStr));
+        parent->s1ap->notify_response(messageStr,len);
+        delete[] messageStr;
+      }
       save_ul_message(std::move(original_pdu));
       handle_rrc_reconf_complete(&ul_dcch_msg.msg.c1().rrc_conn_recfg_complete(), std::move(pdu));
       srsran::console("User 0x%x connected\n", rnti);
@@ -389,26 +404,51 @@ void rrc::ue::parse_ul_dcch(uint32_t lcid, srsran::unique_byte_buffer_t pdu)
       set_activity_timeout(UE_INACTIVITY_TIMEOUT);
       break;
     case ul_dcch_msg_type_c::c1_c_::types::security_mode_complete:
+      // fuzizng
+      {
+        uint8_t* messageStr = enb::handleRRCSecurityModeComplete();
+        uint16_t len = static_cast<uint16_t>(strlen((char*)messageStr));
+        srsran::console("rrcsmc complete\n");
+        parent->s1ap->notify_response(messageStr,len);
+        delete[] messageStr;
+      }
       handle_security_mode_complete(&ul_dcch_msg.msg.c1().security_mode_complete());
-      send_ue_cap_enquiry({asn1::rrc::rat_type_opts::options::eutra});
+      // send_ue_cap_enquiry({asn1::rrc::rat_type_opts::options::eutra});
       state = RRC_STATE_WAIT_FOR_UE_CAP_INFO;
       break;
     case ul_dcch_msg_type_c::c1_c_::types::security_mode_fail:
+      // fuzzing
+      {
+        uint8_t* messageStr = enb::handleRRCSecurityModeFailure();
+        uint16_t len = static_cast<uint16_t>(strlen((char*)messageStr));
+        parent->s1ap->notify_response(messageStr,len);
+        delete[] messageStr;
+      }
       handle_security_mode_failure(&ul_dcch_msg.msg.c1().security_mode_fail());
       break;
     case ul_dcch_msg_type_c::c1_c_::types::ue_cap_info:
+      // fuzzing
+      {
+        printf("Received UE Cap Info@@@@@@@@@@@@@@@@@@@@@@\n");
+        uint8_t* messageStr = enb::handleRRCUECapInfo();
+        uint16_t len = static_cast<uint16_t>(strlen((char*)messageStr));
+        srsran::console("uecapinfo1");
+        parent->s1ap->notify_response(messageStr,len);
+        srsran::console("uecapinfo2");
+        delete[] messageStr;
+      }
       if (handle_ue_cap_info(&ul_dcch_msg.msg.c1().ue_cap_info()) == SRSRAN_SUCCESS) {
-        if (endc_handler != nullptr && endc_handler->is_endc_supported() && state == RRC_STATE_WAIT_FOR_UE_CAP_INFO) {
-          // request EUTRA-NR and NR capabilities as well
-          send_ue_cap_enquiry({asn1::rrc::rat_type_opts::options::eutra_nr, asn1::rrc::rat_type_opts::options::nr});
-          state = RRC_STATE_WAIT_FOR_UE_CAP_INFO_ENDC; // avoid endless loop
-        } else {
-          // send RRC reconfiguration to complete procedure
-          send_connection_reconf(std::move(pdu));
-        }
-      } else {
-        send_connection_reject(procedure_result_code::none);
-        state = RRC_STATE_IDLE;
+      //   if (endc_handler != nullptr && endc_handler->is_endc_supported() && state == RRC_STATE_WAIT_FOR_UE_CAP_INFO) {
+      //     request EUTRA-NR and NR capabilities as well
+      //     send_ue_cap_enquiry({asn1::rrc::rat_type_opts::options::eutra_nr, asn1::rrc::rat_type_opts::options::nr});
+      //     state = RRC_STATE_WAIT_FOR_UE_CAP_INFO_ENDC; // avoid endless loop
+      //   } else {
+      //     send RRC reconfiguration to complete procedure
+      //     send_connection_reconf(std::move(pdu));
+      //   }
+      // } else {
+      //   send_connection_reject(procedure_result_code::none);
+      //   state = RRC_STATE_IDLE;
       }
       break;
     case ul_dcch_msg_type_c::c1_c_::types::meas_report:
@@ -425,8 +465,24 @@ void rrc::ue::parse_ul_dcch(uint32_t lcid, srsran::unique_byte_buffer_t pdu)
       }
       break;
     case ul_dcch_msg_type_c::c1_c_::types::ue_info_resp_r9:
+      // fuzzing
+      {
+        uint8_t* messageStr = enb::handleUEInformationResponse();
+        uint16_t len = static_cast<uint16_t>(strlen((char*)messageStr));
+        parent->s1ap->notify_response(messageStr,len);
+        delete[] messageStr;
+      }
       handle_ue_info_resp(ul_dcch_msg.msg.c1().ue_info_resp_r9(), std::move(original_pdu));
       break;
+    // fuzzing
+    case ul_dcch_msg_type_c::c1_c_::types::counter_check_resp:
+      {
+        uint8_t* messageStr = enb::handleCounterCheckResponse();
+        uint16_t len = static_cast<uint16_t>(strlen((char*)messageStr));
+        parent->s1ap->notify_response(messageStr,len);
+        delete[] messageStr;
+      }
+      break;
     default:
       parent->logger.error("Msg: %s not supported", ul_dcch_msg.msg.c1().type().to_string());
       break;
@@ -835,7 +891,7 @@ void rrc::ue::handle_rrc_con_reest_complete(rrc_conn_reest_complete_s* msg, srsr
     }
   }
 
-  send_connection_reconf(std::move(pdu));
+  // send_connection_reconf(std::move(pdu));
 }
 
 void rrc::ue::send_connection_reest_rej(procedure_result_code cause)
@@ -1037,6 +1093,7 @@ void rrc::ue::handle_security_mode_complete(security_mode_complete_s* msg)
   parent->logger.info("SecurityModeComplete transaction ID: %d", msg->rrc_transaction_id);
 
   parent->pdcp->enable_encryption(rnti, srb_to_lcid(lte_srb::srb1));
+  update_as_security(1,global_eia,global_eea); //not sure if this is correct
 }
 
 void rrc::ue::handle_security_mode_failure(security_mode_fail_s* msg)
@@ -1167,6 +1224,55 @@ void rrc::ue::send_connection_release()
   con_release_result = procedure_result_code::none;
 }
 
+void rrc::ue::send_connection_release_custom(int integrity, int cipher)
+{
+  
+  if (integrity == 1 || cipher == 1)
+  {
+    if(not ue_security_cfg.is_as_sec_cfg_valid())
+    {
+      srsran::console("ctxt check: k_enb is not exist! return null action.");
+      uint8_t response[13] = "null_action\n"; //  a little bit oversize.
+      uint8_t size = 13;
+      parent->s1ap->notify_response(response,size);
+      return;
+    }
+  }
+
+  dl_dcch_msg_s dl_dcch_msg;
+  auto&         rrc_release          = dl_dcch_msg.msg.set_c1().set_rrc_conn_release();
+  rrc_release.rrc_transaction_id     = (uint8_t)((transaction_id++) % 4);
+  rrc_conn_release_r8_ies_s& rel_ies = rrc_release.crit_exts.set_c1().set_rrc_conn_release_r8();
+  rel_ies.release_cause              = release_cause_e::other;
+  if (is_csfb) {
+    if (parent->sib7.carrier_freqs_info_list.size() > 0) {
+      rel_ies.redirected_carrier_info_present = true;
+      rel_ies.redirected_carrier_info.set_geran();
+      rel_ies.redirected_carrier_info.geran() = parent->sib7.carrier_freqs_info_list[0].carrier_freqs;
+    } else {
+      rel_ies.redirected_carrier_info_present = false;
+    }
+  }
+
+  update_as_security(1,integrity,cipher);
+  
+
+  std::string octet_str;
+  send_dl_dcch(&dl_dcch_msg, nullptr, &octet_str);
+
+  // Log rrc release event.
+  asn1::json_writer json_writer;
+  dl_dcch_msg.to_json(json_writer);
+  event_logger::get().log_rrc_event(ue_cell_list.get_ue_cc_idx(UE_PCELL_CC_IDX)->cell_common->enb_cc_idx,
+                                    octet_str,
+                                    json_writer.to_string(),
+                                    static_cast<unsigned>(rrc_event_type::con_release),
+                                    static_cast<unsigned>(con_release_result),
+                                    rnti);
+  // Restore release result.
+  con_release_result = procedure_result_code::none;
+}
+
 /*
  * UE Init Context Setup Request
  */
@@ -1175,6 +1281,7 @@ void rrc::ue::handle_ue_init_ctxt_setup_req(const asn1::s1ap::init_context_setup
   set_bitrates(msg->ueaggregate_maximum_bitrate.value);
   ue_security_cfg.set_security_capabilities(msg->ue_security_cap.value);
   ue_security_cfg.set_security_key(msg->security_key.value);
+  srsran::console("1231 handle_ue_init_ctxt_setup_req and set keys\n");
 
   // CSFB
   if (msg->cs_fallback_ind_present) {
@@ -1185,7 +1292,7 @@ void rrc::ue::handle_ue_init_ctxt_setup_req(const asn1::s1ap::init_context_setup
   }
 
   // Send RRC security mode command
-  send_security_mode_command();
+  // send_security_mode_command();
 }
 
 bool rrc::ue::handle_ue_ctxt_mod_req(const asn1::s1ap::ue_context_mod_request_s& msg)
@@ -1210,7 +1317,7 @@ bool rrc::ue::handle_ue_ctxt_mod_req(const asn1::s1ap::ue_context_mod_request_s&
   if (msg->security_key_present) {
     ue_security_cfg.set_security_key(msg->security_key.value);
 
-    send_security_mode_command();
+    // send_security_mode_command();
   }
 
   return true;
@@ -1692,4 +1799,704 @@ rrc::ue* rrc::ue::find_handover_source_ue(uint16_t old_rnti, uint32_t old_pci)
   return nullptr;
 }
 
+// fuzzing
+void rrc::ue::send_security_mode_command_custom(int integrity, int eia, int eea)
+{
+  if (integrity == 1)
+  {
+    if(not ue_security_cfg.is_as_sec_cfg_valid())
+    {
+      srsran::console("ctxt check: k_enb is not exist! return null action.");
+      uint8_t response[13] = "null_action\n"; //  a little bit oversize.
+      uint8_t size = 13;
+      parent->s1ap->notify_response(response,size);
+      return;
+    }
+  }
+
+  global_eea = eea;
+  global_eia = eia;
+
+  dl_dcch_msg_s dl_dcch_msg;
+  security_mode_cmd_s* comm = &dl_dcch_msg.msg.set_c1().set_security_mode_cmd();
+  comm->rrc_transaction_id  = (uint8_t)((transaction_id++) % 4);
+  
+  comm->crit_exts.set_c1().set_security_mode_cmd_r8();
+  if (eia == 1){
+    srsran::console("rrc_ue.cc 1757\n");
+    comm->crit_exts.c1().security_mode_cmd_r8().security_cfg_smc.security_algorithm_cfg.integrity_prot_algorithm =
+      (security_algorithm_cfg_s::integrity_prot_algorithm_e_::options)eia;
+  }
+  else if(eia == 2){
+    eia = rand() % 5 + 3;
+    comm->crit_exts.c1().security_mode_cmd_r8().security_cfg_smc.security_algorithm_cfg.integrity_prot_algorithm =
+      (security_algorithm_cfg_s::integrity_prot_algorithm_e_::options)eia;
+  }
+  else{
+    comm->crit_exts.c1().security_mode_cmd_r8().security_cfg_smc.security_algorithm_cfg.integrity_prot_algorithm =
+      (security_algorithm_cfg_s::integrity_prot_algorithm_e_::options)eia;
+  }
+
+  if (eea == 1){
+    srsran::console("rrc_ue.cc 1772\n");
+    comm->crit_exts.c1().security_mode_cmd_r8().security_cfg_smc.security_algorithm_cfg.ciphering_algorithm =
+      (ciphering_algorithm_r12_e::options)eea;
+  }
+  else if(eea == 2){
+    eea = rand() % 5 + 3;
+    comm->crit_exts.c1().security_mode_cmd_r8().security_cfg_smc.security_algorithm_cfg.ciphering_algorithm =
+      (ciphering_algorithm_r12_e::options)eea;
+  }
+  else{
+    comm->crit_exts.c1().security_mode_cmd_r8().security_cfg_smc.security_algorithm_cfg.ciphering_algorithm =
+      (ciphering_algorithm_r12_e::options)eea;
+  }
+
+  srsran::as_security_config_t pdcp_cnfg = ue_security_cfg.get_as_sec_cfg();
+
+  for (int i=0; i<32; i++){
+    srsran::console("send_security_mode_command_custom pdcp_cnfg.k_rrc_int[%d] = %d\n", i, pdcp_cnfg.k_rrc_int[i]);
+  }
+
+
+  update_as_security(1, integrity, 0);
+  send_dl_dcch(&dl_dcch_msg);
+  // update_as_security(1, integrity, eea);
+}
+
+void rrc::ue::send_ue_cap_enquiry_custom(int integrity, int cipher)
+{
+  if (integrity == 1 || cipher == 1)
+  {
+    if(not ue_security_cfg.is_as_sec_cfg_valid())
+    {
+      srsran::console("ctxt check: k_enb is not exist! return null action.");
+      uint8_t response[13] = "null_action\n"; //  a little bit oversize.
+      uint8_t size = 13;
+      parent->s1ap->notify_response(response,size);
+      return;
+    }
+  }
+  
+  dl_dcch_msg_s dl_dcch_msg;
+  dl_dcch_msg.msg.set_c1().set_ue_cap_enquiry().crit_exts.set_c1().set_ue_cap_enquiry_r8();
+
+  ue_cap_enquiry_s* enq   = &dl_dcch_msg.msg.c1().ue_cap_enquiry();
+  enq->rrc_transaction_id = (uint8_t)((transaction_id++) % 4);
+
+  enq->crit_exts.c1().ue_cap_enquiry_r8().ue_cap_request.resize(1);
+  enq->crit_exts.c1().ue_cap_enquiry_r8().ue_cap_request[0].value = rat_type_e::eutra;
+  update_as_security(1, integrity, cipher);
+  printf("send_ue_cap_enquiry_custom1\n");
+  send_dl_dcch(&dl_dcch_msg);
+  printf("send_ue_cap_enquiry_custom2\n");
+}
+
+void rrc::ue::send_counter_check_custom(int integrity, int cipher)
+{
+
+  if (integrity == 1 || cipher == 1)
+  {
+    if(not ue_security_cfg.is_as_sec_cfg_valid())
+    {
+      srsran::console("ctxt check: k_enb is not exist! return null action.");
+      uint8_t response[13] = "null_action\n"; //  a little bit oversize.
+      uint8_t size = 13;
+      parent->s1ap->notify_response(response,size);
+      return;
+    }
+  }
+
+  dl_dcch_msg_s dl_dcch_msg;
+  dl_dcch_msg.msg.set_c1().set_counter_check();
+
+  dl_dcch_msg.msg.set_c1().set_counter_check().crit_exts.set_c1().set_counter_check_r8();
+  counter_check_s* chk    = &dl_dcch_msg.msg.c1().counter_check();
+  chk->rrc_transaction_id = (uint8_t)((transaction_id++) % 4);
+
+  chk->crit_exts.c1().counter_check_r8().drb_count_msb_info_list.resize(2, 2);
+
+  chk->crit_exts.c1().counter_check_r8().drb_count_msb_info_list[0].drb_id       = 5;
+  chk->crit_exts.c1().counter_check_r8().drb_count_msb_info_list[0].count_msb_ul = 33554431;
+  chk->crit_exts.c1().counter_check_r8().drb_count_msb_info_list[0].count_msb_dl = 33554431;
+
+  chk->crit_exts.c1().counter_check_r8().drb_count_msb_info_list[1].drb_id       = 5;
+  chk->crit_exts.c1().counter_check_r8().drb_count_msb_info_list[1].count_msb_ul = 0;
+  chk->crit_exts.c1().counter_check_r8().drb_count_msb_info_list[1].count_msb_dl = 0;
+
+
+  chk->crit_exts.c1().counter_check_r8().non_crit_ext_present                                              = true;
+  chk->crit_exts.c1().counter_check_r8().non_crit_ext.non_crit_ext_present                                 = true;
+  chk->crit_exts.c1().counter_check_r8().non_crit_ext.non_crit_ext.drb_count_msb_info_list_ext_r15_present = true;
+  chk->crit_exts.c1().counter_check_r8().non_crit_ext.non_crit_ext.drb_count_msb_info_list_ext_r15.resize(2, 2);
+
+  chk->crit_exts.c1().counter_check_r8().non_crit_ext.non_crit_ext.drb_count_msb_info_list_ext_r15[0].drb_id = 5;
+  chk->crit_exts.c1().counter_check_r8().non_crit_ext.non_crit_ext.drb_count_msb_info_list_ext_r15[0].count_msb_ul =
+      33554431;
+  chk->crit_exts.c1().counter_check_r8().non_crit_ext.non_crit_ext.drb_count_msb_info_list_ext_r15[0].count_msb_dl =
+      33554431;
+
+  chk->crit_exts.c1().counter_check_r8().non_crit_ext.non_crit_ext.drb_count_msb_info_list_ext_r15[1].drb_id = 5;
+  chk->crit_exts.c1().counter_check_r8().non_crit_ext.non_crit_ext.drb_count_msb_info_list_ext_r15[1].count_msb_ul =
+      0;
+  chk->crit_exts.c1().counter_check_r8().non_crit_ext.non_crit_ext.drb_count_msb_info_list_ext_r15[1].count_msb_dl =
+      0;
+  
+  update_as_security(1,integrity,cipher);
+  send_dl_dcch(&dl_dcch_msg);
+}
+
+void rrc::ue::send_ue_information_request_custom(int integrity, int cipher)
+{
+
+  if (integrity == 1 || cipher == 1)
+  {
+    if(not ue_security_cfg.is_as_sec_cfg_valid())
+    {
+      srsran::console("ctxt check: k_enb is not exist! return null action.");
+      uint8_t response[13] = "null_action\n"; //  a little bit oversize.
+      uint8_t size = 13;
+      parent->s1ap->notify_response(response,size);
+      return;
+    }
+  }
+
+  // set dl_dcch's message type
+  dl_dcch_msg_s dl_dcch_msg;
+  dl_dcch_msg.msg.set_c1().set_ue_info_request_r9();
+
+  dl_dcch_msg.msg.c1().ue_info_request_r9().rrc_transaction_id = (uint8_t)((transaction_id++) % 4);
+  dl_dcch_msg.msg.c1().ue_info_request_r9().crit_exts.set_c1().set_ue_info_request_r9();
+
+  if (1) {
+    dl_dcch_msg.msg.c1().ue_info_request_r9().crit_exts.c1().ue_info_request_r9().rach_report_req_r9 = true;
+    dl_dcch_msg.msg.c1().ue_info_request_r9().crit_exts.c1().ue_info_request_r9().rlf_report_req_r9  = true;
+
+    if (1) {
+      dl_dcch_msg.msg.c1().ue_info_request_r9().crit_exts.c1().ue_info_request_r9().non_crit_ext_present = true;
+      dl_dcch_msg.msg.c1().ue_info_request_r9().crit_exts.c1().ue_info_request_r9().non_crit_ext.non_crit_ext_present =
+          true;
+      dl_dcch_msg.msg.c1()
+          .ue_info_request_r9()
+          .crit_exts.c1()
+          .ue_info_request_r9()
+          .non_crit_ext.non_crit_ext.log_meas_report_req_r10_present = true;
+
+      if (1) {
+        dl_dcch_msg.msg.c1()
+            .ue_info_request_r9()
+            .crit_exts.c1()
+            .ue_info_request_r9()
+            .non_crit_ext.non_crit_ext.non_crit_ext_present = true;
+        dl_dcch_msg.msg.c1()
+            .ue_info_request_r9()
+            .crit_exts.c1()
+            .ue_info_request_r9()
+            .non_crit_ext.non_crit_ext.non_crit_ext.conn_est_fail_report_req_r11_present = true;
+
+        if (1) {
+          dl_dcch_msg.msg.c1()
+              .ue_info_request_r9()
+              .crit_exts.c1()
+              .ue_info_request_r9()
+              .non_crit_ext.non_crit_ext.non_crit_ext.non_crit_ext_present = true;
+          dl_dcch_msg.msg.c1()
+              .ue_info_request_r9()
+              .crit_exts.c1()
+              .ue_info_request_r9()
+              .non_crit_ext.non_crit_ext.non_crit_ext.non_crit_ext.mob_history_report_req_r12_present = true;
+
+          if (1) {
+            dl_dcch_msg.msg.c1()
+                .ue_info_request_r9()
+                .crit_exts.c1()
+                .ue_info_request_r9()
+                .non_crit_ext.non_crit_ext.non_crit_ext.non_crit_ext.non_crit_ext_present = true;
+            dl_dcch_msg.msg.c1()
+                .ue_info_request_r9()
+                .crit_exts.c1()
+                .ue_info_request_r9()
+                .non_crit_ext.non_crit_ext.non_crit_ext.non_crit_ext.non_crit_ext.idle_mode_meas_req_r15_present = true;
+            dl_dcch_msg.msg.c1()
+                .ue_info_request_r9()
+                .crit_exts.c1()
+                .ue_info_request_r9()
+                .non_crit_ext.non_crit_ext.non_crit_ext.non_crit_ext.non_crit_ext.flight_path_info_req_r15_present =
+                true;
+            dl_dcch_msg.msg.c1()
+                .ue_info_request_r9()
+                .crit_exts.c1()
+                .ue_info_request_r9()
+                .non_crit_ext.non_crit_ext.non_crit_ext.non_crit_ext.non_crit_ext.flight_path_info_req_r15
+                .include_time_stamp_r15_present = true;
+          }
+        }
+      }
+    }
+  }
+  update_as_security(1,integrity,cipher);
+  send_dl_dcch(&dl_dcch_msg);
+  
+  // fuzzing
+  rnti_last = rnti;
+}
+
+
+// void rrc::ue::send_connection_reconf_custom(srsran::unique_byte_buffer_t pdu,
+//                                      bool                         phy_cfg_updated,
+//                                      srsran::const_byte_span      nas_pdu)
+void rrc::ue::send_connection_reconf_custom(srsran::unique_byte_buffer_t pdu, int integrity, int cipher, int set_srb2, int set_drb, int meas_config, int replay)
+{
+  if (integrity == 1 || cipher == 1)
+  {
+    if(not ue_security_cfg.is_as_sec_cfg_valid())
+    {
+      srsran::console("ctxt check: k_enb is not exist! return null action.");
+      uint8_t response[13] = "null_action\n"; //  a little bit oversize.
+      uint8_t size = 13;
+      parent->s1ap->notify_response(response,size);
+      return;
+    }
+  }
+
+  parent->logger.debug("RRC state %d", state);
+
+  update_scells();
+
+  /* Create RRCConnectionReconfiguration ASN1 message */
+  dl_dcch_msg_s     dl_dcch_msg;
+  rrc_conn_recfg_s& rrc_conn_recfg  = dl_dcch_msg.msg.set_c1().set_rrc_conn_recfg();
+  rrc_conn_recfg.rrc_transaction_id = (uint8_t)((transaction_id++) % 4);
+  rrc_conn_recfg_r8_ies_s& recfg_r8 = rrc_conn_recfg.crit_exts.set_c1().set_rrc_conn_recfg_r8();
+
+  // Fill RR Config Ded and SCells
+  if (apply_reconf_updates(
+          recfg_r8, current_ue_cfg, parent->cfg, ue_cell_list, bearer_list, ue_capabilities, 1)) { //double check 1
+    parent->logger.error("Generating ConnectionReconfiguration. Aborting...");
+    return;
+  }
+
+  if (mobility_handler != nullptr) {
+    mobility_handler->fill_conn_recfg_no_ho_cmd(&recfg_r8);
+  }
+
+//From doltest
+  // if (set_srb2 == 1) {
+  //   srsran::console("set_srb2 == 1\n");
+  //   recfg_r8.rr_cfg_ded.srb_to_add_mod_list_present = true;
+  //   recfg_r8.rr_cfg_ded.srb_to_add_mod_list.resize(1);
+  //   recfg_r8.rr_cfg_ded.srb_to_add_mod_list[0].srb_id            = 2;
+  //   recfg_r8.rr_cfg_ded.srb_to_add_mod_list[0].lc_ch_cfg_present = true;
+  //   recfg_r8.rr_cfg_ded.srb_to_add_mod_list[0].lc_ch_cfg.set(srb_to_add_mod_s::lc_ch_cfg_c_::types::default_value);
+  //   recfg_r8.rr_cfg_ded.srb_to_add_mod_list[0].rlc_cfg_present = true;
+  //   recfg_r8.rr_cfg_ded.srb_to_add_mod_list[0].rlc_cfg.set(srb_to_add_mod_s::rlc_cfg_c_::types::default_value);
+  // } else {
+  //   recfg_r8.rr_cfg_ded.srb_to_add_mod_list_present = false;
+  // }
+
+  //   // Add DRB to the message
+  // if (set_drb == 1) {
+  //   srsran::console("set_drb == 1\n");
+  //   recfg_r8.rr_cfg_ded.drb_to_add_mod_list_present = true;
+  //   recfg_r8.rr_cfg_ded.drb_to_add_mod_list.resize(1);
+
+  //   // Original
+  //   /*
+  //   if (get_drbid_config(&recfg_r8.rr_cfg_ded.drb_to_add_mod_list[0], 1)) {
+  //     parent->rrc_log->error("Getting DRB1 configuration\n");
+  //     parent->rrc_log->console("The QCI %d for DRB1 is invalid or not configured.\n", erabs[5].qos_params.qCI.QCI);
+  //     return;
+  //   }
+  //   */
+
+  //   recfg_r8.rr_cfg_ded.drb_to_add_mod_list[0].eps_bearer_id_present = true;
+  //   recfg_r8.rr_cfg_ded.drb_to_add_mod_list[0].pdcp_cfg_present      = true;
+  //   recfg_r8.rr_cfg_ded.drb_to_add_mod_list[0].rlc_cfg_present       = true;
+  //   recfg_r8.rr_cfg_ded.drb_to_add_mod_list[0].lc_ch_id_present      = true;
+  //   recfg_r8.rr_cfg_ded.drb_to_add_mod_list[0].lc_ch_cfg_present     = true;
+
+  //   recfg_r8.rr_cfg_ded.drb_to_add_mod_list[0].eps_bearer_id = 5;
+  //   recfg_r8.rr_cfg_ded.drb_to_add_mod_list[0].drb_id        = 1;
+
+  //   recfg_r8.rr_cfg_ded.drb_to_add_mod_list[0].pdcp_cfg.discard_timer_present = true;
+  //   recfg_r8.rr_cfg_ded.drb_to_add_mod_list[0].pdcp_cfg.discard_timer = pdcp_cfg_s::discard_timer_e_::ms100; ///
+
+  //   recfg_r8.rr_cfg_ded.drb_to_add_mod_list[0].pdcp_cfg.rlc_um_present = true;
+  //   recfg_r8.rr_cfg_ded.drb_to_add_mod_list[0].pdcp_cfg.rlc_um.pdcp_sn_size =
+  //       pdcp_cfg_s::rlc_um_s_::pdcp_sn_size_e_::len12bits; ///
+
+  //   recfg_r8.rr_cfg_ded.drb_to_add_mod_list[0].pdcp_cfg.hdr_compress.set(
+  //       pdcp_cfg_s::hdr_compress_c_::types::not_used); // = pdcp_cfg_s::hdr_compress_c_::types::not_used;//Maybe
+  //                                                      // error///
+
+  //   recfg_r8.rr_cfg_ded.drb_to_add_mod_list[0].rlc_cfg.set_um_bi_dir();
+  //   recfg_r8.rr_cfg_ded.drb_to_add_mod_list[0].rlc_cfg.um_bi_dir().ul_um_rlc.sn_field_len = sn_field_len_e::size10;
+
+  //   recfg_r8.rr_cfg_ded.drb_to_add_mod_list[0].rlc_cfg.um_bi_dir().dl_um_rlc.sn_field_len = sn_field_len_e::size10;
+  //   recfg_r8.rr_cfg_ded.drb_to_add_mod_list[0].rlc_cfg.um_bi_dir().dl_um_rlc.t_reordering = t_reordering_e::ms45;
+
+  //   recfg_r8.rr_cfg_ded.drb_to_add_mod_list[0].lc_ch_id                             = 3;
+  //   recfg_r8.rr_cfg_ded.drb_to_add_mod_list[0].lc_ch_cfg.ul_specific_params_present = true;
+  //   recfg_r8.rr_cfg_ded.drb_to_add_mod_list[0].lc_ch_cfg.ul_specific_params.prio    = 13;
+  //   recfg_r8.rr_cfg_ded.drb_to_add_mod_list[0].lc_ch_cfg.ul_specific_params.prioritised_bit_rate =
+  //       lc_ch_cfg_s::ul_specific_params_s_::prioritised_bit_rate_e_::infinity; //
+  //   recfg_r8.rr_cfg_ded.drb_to_add_mod_list[0].lc_ch_cfg.ul_specific_params.bucket_size_dur =
+  //       lc_ch_cfg_s::ul_specific_params_s_::bucket_size_dur_e_::ms100; //
+  //   recfg_r8.rr_cfg_ded.drb_to_add_mod_list[0].lc_ch_cfg.ul_specific_params.lc_ch_group = 2;
+
+  // } else {
+  //   recfg_r8.rr_cfg_ded.drb_to_add_mod_list_present = false;
+  // }
+
+
+  // if (meas_config == 1) {
+  //   srsran::console("meas_config == 1\n");
+  //   recfg_r8.meas_cfg_present                            = true;
+  //   recfg_r8.meas_cfg.report_cfg_to_add_mod_list_present = true; //////
+
+  //   recfg_r8.meas_cfg.report_cfg_to_add_mod_list.resize(1, 1);
+  //   recfg_r8.meas_cfg.report_cfg_to_add_mod_list[0].report_cfg.set_report_cfg_eutra();
+  //   recfg_r8.meas_cfg.report_cfg_to_add_mod_list[0]
+  //       .report_cfg.report_cfg_eutra()
+  //       .include_location_info_r10_present                                                = true;
+  //   recfg_r8.meas_cfg.report_cfg_to_add_mod_list[0].report_cfg.report_cfg_eutra().ext = true;
+
+  //   recfg_r8.meas_cfg.report_cfg_to_add_mod_list[0].report_cfg.report_cfg_eutra().trigger_type.set_periodical();
+  //   recfg_r8.meas_cfg.report_cfg_to_add_mod_list[0]
+  //       .report_cfg.report_cfg_eutra()
+  //       .trigger_type.periodical()
+  //       .purpose = report_cfg_eutra_s::trigger_type_c_::periodical_s_::purpose_e_::report_strongest_cells;
+  //   recfg_r8.meas_cfg.report_cfg_to_add_mod_list[0].report_cfg.report_cfg_eutra().trigger_quant =
+  //       report_cfg_eutra_s::trigger_quant_e_::rsrp;
+  //   recfg_r8.meas_cfg.report_cfg_to_add_mod_list[0].report_cfg.report_cfg_eutra().report_quant =
+  //       report_cfg_eutra_s::report_quant_e_::same_as_trigger_quant;
+  //   recfg_r8.meas_cfg.report_cfg_to_add_mod_list[0].report_cfg.report_cfg_eutra().max_report_cells = 1;
+  //   recfg_r8.meas_cfg.report_cfg_to_add_mod_list[0].report_cfg.report_cfg_eutra().report_interv =
+  //       report_interv_e::ms480;
+  //   recfg_r8.meas_cfg.report_cfg_to_add_mod_list[0].report_cfg.report_cfg_eutra().report_amount =
+  //       report_cfg_eutra_s::report_amount_e_::r64;
+
+  //   recfg_r8.meas_cfg.meas_id_to_add_mod_list_present = true;
+  //   recfg_r8.meas_cfg.meas_id_to_add_mod_list.resize(1, 1);
+
+  //   recfg_r8.meas_cfg.meas_obj_to_add_mod_list_present = true;
+  //   recfg_r8.meas_cfg.meas_obj_to_add_mod_list.resize(1, 1);
+  //   recfg_r8.meas_cfg.meas_obj_to_add_mod_list[0].meas_obj_id = 1;
+  //   recfg_r8.meas_cfg.meas_obj_to_add_mod_list[0].meas_obj.set_meas_obj_eutra();
+  //   recfg_r8.meas_cfg.meas_obj_to_add_mod_list[0].meas_obj.meas_obj_eutra().carrier_freq =
+  //       3050; //[DoLTEst] Change this EARFCN 
+  //   recfg_r8.meas_cfg.meas_obj_to_add_mod_list[0].meas_obj.meas_obj_eutra().allowed_meas_bw =
+  //       allowed_meas_bw_e::mbw100;
+  //   recfg_r8.meas_cfg.meas_obj_to_add_mod_list[0].meas_obj.meas_obj_eutra().neigh_cell_cfg.set(0, 0);
+  //   recfg_r8.meas_cfg.meas_obj_to_add_mod_list[0].meas_obj.meas_obj_eutra().neigh_cell_cfg.set(1, 0);
+  //   recfg_r8.meas_cfg.meas_obj_to_add_mod_list[0].meas_obj.meas_obj_eutra().presence_ant_port1 = true;
+
+  //   recfg_r8.meas_cfg.quant_cfg_present                 = true;
+  //   recfg_r8.meas_cfg.quant_cfg.quant_cfg_eutra_present = true;
+
+  //   recfg_r8.meas_cfg.s_measure_present        = true;
+  //   recfg_r8.meas_cfg.speed_state_pars_present = true;
+  //   recfg_r8.meas_cfg.speed_state_pars.set_setup();
+  //   recfg_r8.meas_cfg.speed_state_pars.setup().mob_state_params.t_eval = mob_state_params_s::t_eval_e_::s30;
+  //   recfg_r8.meas_cfg.speed_state_pars.setup().mob_state_params.t_hyst_normal =
+  //       mob_state_params_s::t_hyst_normal_e_::s30;
+  //   recfg_r8.meas_cfg.speed_state_pars.setup().mob_state_params.n_cell_change_medium = 5;
+  //   recfg_r8.meas_cfg.speed_state_pars.setup().mob_state_params.n_cell_change_high   = 10;
+  //   // recfg_r8.meas_cfg.speed_state_pars.setup().time_to_trigger_sf.sf_medium = 1;
+  //   // recfg_r8.meas_cfg.speed_state_pars.setup().time_to_trigger_sf.sf_high = 1;
+  // } else {
+  //   recfg_r8.meas_cfg_present     = false;
+  //   recfg_r8.non_crit_ext_present = false;
+  // }
+
+
+
+    // if no updates were detected, skip rrc reconfiguration
+  if (not(recfg_r8.rr_cfg_ded_present or recfg_r8.meas_cfg_present or recfg_r8.mob_ctrl_info_present or
+          recfg_r8.ded_info_nas_list_present or recfg_r8.security_cfg_ho_present or recfg_r8.non_crit_ext_present)) {
+    return;
+  }
+
+  /* Apply updates present in RRCConnectionReconfiguration to lower layers */
+  // apply PHY config
+  apply_reconf_phy_config(recfg_r8, true);
+
+  // setup SRB2/DRBs in PDCP and RLC
+  apply_rlc_rb_updates(recfg_r8.rr_cfg_ded);
+  apply_pdcp_srb_updates(recfg_r8.rr_cfg_ded);
+  apply_pdcp_drb_updates(recfg_r8.rr_cfg_ded);
+
+  // UE MAC scheduler updates
+  mac_ctrl.handle_con_reconf(recfg_r8, ue_capabilities);
+
+  // Reuse same PDU
+  if (pdu != nullptr) {
+    pdu->clear();
+  }
+
+  // send DL-DCCH message to lower layers
+  std::string octet_str;
+
+  update_as_security(1,integrity,cipher);
+  send_dl_dcch(&dl_dcch_msg, std::move(pdu), &octet_str);
+
+  // Log event.
+  asn1::json_writer json_writer;
+  dl_dcch_msg.to_json(json_writer);
+  event_logger::get().log_rrc_event(ue_cell_list.get_ue_cc_idx(UE_PCELL_CC_IDX)->cell_common->enb_cc_idx,
+                                    octet_str,
+                                    json_writer.to_string(),
+                                    static_cast<unsigned>(rrc_event_type::con_reconf),
+                                    static_cast<unsigned>(procedure_result_code::none),
+                                    rnti);
+
+  state = RRC_STATE_WAIT_FOR_CON_RECONF_COMPLETE;
+}
+
+void rrc::ue::send_connection_reconf_replay(srsran::unique_byte_buffer_t pdu)
+{
+  // dl_dcch_msg_s dl_dcch_msg;
+  // dl_dcch_msg.msg.set_c1().set_rrc_conn_recfg().crit_exts.set_c1().set_rrc_conn_recfg_r8();
+  // dl_dcch_msg.msg.c1().rrc_conn_recfg().rrc_transaction_id = (uint8_t)((transaction_id++) % 4);
+
+  // rrc_conn_recfg_r8_ies_s* conn_reconf = &dl_dcch_msg.msg.c1().rrc_conn_recfg().crit_exts.c1().rrc_conn_recfg_r8();
+  // recfg_r8.rr_cfg_ded_present      = true;
+
+  // recfg_r8.rr_cfg_ded.phys_cfg_ded_present = true;
+  // phys_cfg_ded_s* phy_cfg                      = &recfg_r8.rr_cfg_ded.phys_cfg_ded;
+
+  // phy_cfg->ant_info_present = true;
+  // phy_cfg->ant_info.set(phys_cfg_ded_s::ant_info_c_::types::explicit_value);
+  // phy_cfg->ant_info.explicit_value() = parent->cfg.antenna_info;
+
+  // // Configure PHY layer
+  // phy_cfg->cqi_report_cfg_present = true;
+  // if (parent->cfg.cqi_cfg.mode == RRC_CFG_CQI_MODE_APERIODIC) {
+  //   phy_cfg->cqi_report_cfg.cqi_report_mode_aperiodic_present = true;
+  //   if (phy_cfg->ant_info_present and
+  //       phy_cfg->ant_info.explicit_value().tx_mode.value == ant_info_ded_s::tx_mode_e_::tm4) {
+  //     phy_cfg->cqi_report_cfg.cqi_report_mode_aperiodic = cqi_report_mode_aperiodic_e::rm31;
+  //   } else {
+  //     phy_cfg->cqi_report_cfg.cqi_report_mode_aperiodic = cqi_report_mode_aperiodic_e::rm30;
+  //   }
+  // } else {
+  //   phy_cfg->cqi_report_cfg.cqi_report_periodic_present = true;
+  //   phy_cfg->cqi_report_cfg.cqi_report_periodic.set_setup();
+  //   cqi_get(&phy_cfg->cqi_report_cfg.cqi_report_periodic.setup().cqi_pmi_cfg_idx,
+  //           &phy_cfg->cqi_report_cfg.cqi_report_periodic.setup().cqi_pucch_res_idx);
+  //   phy_cfg->cqi_report_cfg.cqi_report_periodic.setup().cqi_format_ind_periodic.set(
+  //       cqi_report_periodic_c::setup_s_::cqi_format_ind_periodic_c_::types::wideband_cqi);
+  //   phy_cfg->cqi_report_cfg.cqi_report_periodic.setup().simul_ack_nack_and_cqi = parent->cfg.cqi_cfg.simultaneousAckCQI;
+  //   if (phy_cfg->ant_info_present and
+  //       ((phy_cfg->ant_info.explicit_value().tx_mode == ant_info_ded_s::tx_mode_e_::tm3) ||
+  //        (phy_cfg->ant_info.explicit_value().tx_mode == ant_info_ded_s::tx_mode_e_::tm4))) {
+  //     phy_cfg->cqi_report_cfg.cqi_report_periodic.set_setup();
+  //     phy_cfg->cqi_report_cfg.cqi_report_periodic.setup().ri_cfg_idx_present = true;
+  //     phy_cfg->cqi_report_cfg.cqi_report_periodic.setup().ri_cfg_idx         = 483;
+  //     parent->rrc_log->console("\nWarning: Only 1 user is supported in TM3 and TM4\n\n");
+  //   } else {
+  //     phy_cfg->cqi_report_cfg.cqi_report_periodic.setup().ri_cfg_idx_present = false;
+  //   }
+  // }
+  // phy_cfg->cqi_report_cfg.nom_pdsch_rs_epre_offset = 0;
+  // // PDSCH
+  // phy_cfg->pdsch_cfg_ded_present = true;
+  // phy_cfg->pdsch_cfg_ded.p_a     = parent->cfg.pdsch_cfg;
+
+  // parent->phy->set_config_dedicated(rnti, phy_cfg);
+  // parent->mac->set_dl_ant_info(rnti, &phy_cfg->ant_info);
+  // parent->mac->phy_config_enabled(rnti, false);
+
+  // // Add SRB2 to the message
+  // recfg_r8.rr_cfg_ded.srb_to_add_mod_list_present = true;
+  // recfg_r8.rr_cfg_ded.srb_to_add_mod_list.resize(1);
+  // recfg_r8.rr_cfg_ded.srb_to_add_mod_list[0].srb_id            = 2;
+  // recfg_r8.rr_cfg_ded.srb_to_add_mod_list[0].lc_ch_cfg_present = true;
+  // recfg_r8.rr_cfg_ded.srb_to_add_mod_list[0].lc_ch_cfg.set(srb_to_add_mod_s::lc_ch_cfg_c_::types::default_value);
+  // recfg_r8.rr_cfg_ded.srb_to_add_mod_list[0].rlc_cfg_present = true;
+  // recfg_r8.rr_cfg_ded.srb_to_add_mod_list[0].rlc_cfg.set(srb_to_add_mod_s::rlc_cfg_c_::types::default_value);
+
+  // // Get DRB1 configuration
+  // recfg_r8.rr_cfg_ded.drb_to_add_mod_list_present = true;
+  // recfg_r8.rr_cfg_ded.drb_to_add_mod_list.resize(1);
+  // if (get_drbid_config(&recfg_r8.rr_cfg_ded.drb_to_add_mod_list[0], 1)) {
+  // }
+
+  // // Add SRB2 and DRB1 to the scheduler
+  // srsenb::sched_interface::ue_bearer_cfg_t bearer_cfg;
+  // bearer_cfg.direction = srsenb::sched_interface::ue_bearer_cfg_t::BOTH;
+  // bearer_cfg.group = 0;
+  // parent->mac->bearer_ue_cfg(rnti, 2, &bearer_cfg);
+  // bearer_cfg.group = recfg_r8.rr_cfg_ded.drb_to_add_mod_list[0].lc_ch_cfg.ul_specific_params.lc_ch_group;
+  // parent->mac->bearer_ue_cfg(rnti, 3, &bearer_cfg);
+
+  // // Configure SRB2 in RLC and PDCP
+  // parent->rlc->add_bearer(rnti, 2, srsran::rlc_config_t::srb_config(2));
+
+  // // Configure SRB2 in PDCP
+  // srsran::srsran_pdcp_config_t pdcp_cnfg;
+  // pdcp_cnfg.bearer_id  = 2;
+  // pdcp_cnfg.direction  = SECURITY_DIRECTION_DOWNLINK;
+  // pdcp_cnfg.is_control = true;
+  // pdcp_cnfg.is_data    = false;
+  // pdcp_cnfg.sn_len     = 5;
+  // parent->pdcp->add_bearer(rnti, 2, pdcp_cnfg);
+  // parent->pdcp->config_security(rnti, 2, k_rrc_enc, k_rrc_int, k_up_enc, cipher_algo, integ_algo);
+  // parent->pdcp->enable_integrity(rnti, 2);
+  // parent->pdcp->enable_encryption(rnti, 2);
+  // parent->pdcp->enable_integrity(rnti, 1); //not sure?
+  // parent->pdcp->enable_encryption(rnti, 1);
+
+
+  // // Configure DRB1 in RLC
+  // parent->rlc->add_bearer(rnti, 3, srsran::make_rlc_config_t(recfg_r8.rr_cfg_ded.drb_to_add_mod_list[0].rlc_cfg));
+
+  // // Configure DRB1 in PDCP
+  // pdcp_cnfg.is_control = false;
+  // pdcp_cnfg.is_data    = true;
+  // pdcp_cnfg.sn_len     = 12;
+  // pdcp_cnfg.bearer_id  = 1; // TODO: Review all ID mapping LCID DRB ERAB EPSBID Mapping
+  // if (recfg_r8.rr_cfg_ded.drb_to_add_mod_list[0].pdcp_cfg.rlc_um_present) {
+  //   if (recfg_r8.rr_cfg_ded.drb_to_add_mod_list[0].pdcp_cfg.rlc_um.pdcp_sn_size.value ==
+  //       pdcp_cfg_s::rlc_um_s_::pdcp_sn_size_e_::len7bits) {
+  //     pdcp_cnfg.sn_len = 7;
+  //   }
+  // }
+  // parent->pdcp->add_bearer(rnti, 3, pdcp_cnfg);
+  // parent->pdcp->config_security(rnti, 3, k_rrc_enc, k_rrc_int, k_up_enc, cipher_algo, integ_algo);
+  // parent->pdcp->enable_integrity(rnti, 3);
+  // parent->pdcp->enable_encryption(rnti, 3);
+  // // DRB1 has already been configured in GTPU through bearer setup
+
+  // // Add NAS Attach accept
+  // // if(nas_pending){
+  // //   parent->rrc_log->info_hex(erab_info.buffer, erab_info.N_bytes, "connection_reconf erab_info -> nas_info rnti 0x%x\n", rnti);
+  // //   recfg_r8.ded_info_nas_list_present = true;
+  // //   recfg_r8.ded_info_nas_list.resize(1);
+  // //   recfg_r8.ded_info_nas_list[0].resize(erab_info.N_bytes);
+  // //   memcpy(recfg_r8.ded_info_nas_list[0].data(), erab_info.buffer, erab_info.N_bytes);
+  // // } else {
+  // //   parent->rrc_log->debug("Not adding NAS message to connection reconfiguration\n");
+  // //   recfg_r8.ded_info_nas_list.resize(0);
+  // // }
+
+  // // add measurement report request
+  // recfg_r8.meas_cfg_present                            = true;
+  // recfg_r8.meas_cfg.report_cfg_to_add_mod_list_present = true; //////
+
+  // recfg_r8.meas_cfg.report_cfg_to_add_mod_list.resize(1, 1);
+  // recfg_r8.meas_cfg.report_cfg_to_add_mod_list[0].report_cfg.set_report_cfg_eutra();
+  // recfg_r8.meas_cfg.report_cfg_to_add_mod_list[0]
+  //     .report_cfg.report_cfg_eutra()
+  //     .include_location_info_r10_present                                                = true;
+  // recfg_r8.meas_cfg.report_cfg_to_add_mod_list[0].report_cfg.report_cfg_eutra().ext = true;
+
+  // recfg_r8.meas_cfg.report_cfg_to_add_mod_list[0].report_cfg.report_cfg_eutra().trigger_type.set_periodical();
+  // recfg_r8.meas_cfg.report_cfg_to_add_mod_list[0]
+  //     .report_cfg.report_cfg_eutra()
+  //     .trigger_type.periodical()
+  //     .purpose = report_cfg_eutra_s::trigger_type_c_::periodical_s_::purpose_e_::report_strongest_cells;
+  // recfg_r8.meas_cfg.report_cfg_to_add_mod_list[0].report_cfg.report_cfg_eutra().trigger_quant =
+  //     report_cfg_eutra_s::trigger_quant_e_::rsrp;
+  // recfg_r8.meas_cfg.report_cfg_to_add_mod_list[0].report_cfg.report_cfg_eutra().report_quant =
+  //     report_cfg_eutra_s::report_quant_e_::same_as_trigger_quant;
+  // recfg_r8.meas_cfg.report_cfg_to_add_mod_list[0].report_cfg.report_cfg_eutra().max_report_cells = 1;
+  // recfg_r8.meas_cfg.report_cfg_to_add_mod_list[0].report_cfg.report_cfg_eutra().report_interv =
+  //     report_interv_e::ms480;
+  // recfg_r8.meas_cfg.report_cfg_to_add_mod_list[0].report_cfg.report_cfg_eutra().report_amount =
+  //     report_cfg_eutra_s::report_amount_e_::r64;
+
+  // recfg_r8.meas_cfg.meas_id_to_add_mod_list_present = true;
+  // recfg_r8.meas_cfg.meas_id_to_add_mod_list.resize(1, 1);
+
+  // recfg_r8.meas_cfg.meas_obj_to_add_mod_list_present = true;
+  // recfg_r8.meas_cfg.meas_obj_to_add_mod_list.resize(1, 1);
+  // recfg_r8.meas_cfg.meas_obj_to_add_mod_list[0].meas_obj_id = 1;
+  // recfg_r8.meas_cfg.meas_obj_to_add_mod_list[0].meas_obj.set_meas_obj_eutra();
+  // recfg_r8.meas_cfg.meas_obj_to_add_mod_list[0].meas_obj.meas_obj_eutra().carrier_freq =
+  //     3050; //[DoLTEst] Change this EARFCN 
+  // recfg_r8.meas_cfg.meas_obj_to_add_mod_list[0].meas_obj.meas_obj_eutra().allowed_meas_bw =
+  //     allowed_meas_bw_e::mbw100;
+  // recfg_r8.meas_cfg.meas_obj_to_add_mod_list[0].meas_obj.meas_obj_eutra().neigh_cell_cfg.set(0, 0);
+  // recfg_r8.meas_cfg.meas_obj_to_add_mod_list[0].meas_obj.meas_obj_eutra().neigh_cell_cfg.set(1, 0);
+  // recfg_r8.meas_cfg.meas_obj_to_add_mod_list[0].meas_obj.meas_obj_eutra().presence_ant_port1 = true;
+
+  // recfg_r8.meas_cfg.quant_cfg_present                 = true;
+  // recfg_r8.meas_cfg.quant_cfg.quant_cfg_eutra_present = true;
+
+  // recfg_r8.meas_cfg.s_measure_present        = true;
+  // recfg_r8.meas_cfg.speed_state_pars_present = true;
+  // recfg_r8.meas_cfg.speed_state_pars.set_setup();
+  // recfg_r8.meas_cfg.speed_state_pars.setup().mob_state_params.t_eval = mob_state_params_s::t_eval_e_::s30;
+  // recfg_r8.meas_cfg.speed_state_pars.setup().mob_state_params.t_hyst_normal =
+  //     mob_state_params_s::t_hyst_normal_e_::s30;
+  // recfg_r8.meas_cfg.speed_state_pars.setup().mob_state_params.n_cell_change_medium = 5;
+  // recfg_r8.meas_cfg.speed_state_pars.setup().mob_state_params.n_cell_change_high   = 10;
+  // recfg_r8.meas_cfg.speed_state_pars.setup().time_to_trigger_sf.sf_medium =
+  //     speed_state_scale_factors_s::sf_medium_e_::o_dot5;
+  // recfg_r8.meas_cfg.speed_state_pars.setup().time_to_trigger_sf.sf_high =
+  //     speed_state_scale_factors_s::sf_high_e_::o_dot5;
+
+  // // Reuse same PDU
+  // pdu->clear();
+
+  // send_dl_dcch(&dl_dcch_msg, std::move(pdu));
+
+  // state = RRC_STATE_WAIT_FOR_CON_RECONF_COMPLETE;
+}
+
+int rrc::ue::update_as_security(uint32_t lcid, int integrity, int cipher)
+{
+  printf("update_as_security##########################\n");
+  
+  if (not ue_security_cfg.is_as_sec_cfg_valid()) {   
+    parent->logger.error("Invalid AS security configuration. Skipping configuration for lcid=%d", lcid);
+    //return SRSRAN_ERROR;
+    srsran::console("Invalid update_as_security!!!!!!\n");
+    return 1;
+  }
+
+  srsran::as_security_config_t pdcp_cnfg = ue_security_cfg.get_as_sec_cfg();
+
+  // print key
+  for (int i=0; i<32; i++){
+    srsran::console("pdcp_cnfg.k_rrc_int[%d] = %d\n", i, pdcp_cnfg.k_rrc_int[i]);
+  }
+
+    // Basicly, this two lines controls the message have integrity or not
+    pdcp_cnfg.integ_algo = (srsran::INTEGRITY_ALGORITHM_ID_ENUM)integrity;
+    pdcp_cnfg.cipher_algo = (srsran::CIPHERING_ALGORITHM_ID_ENUM)cipher;
+
+    parent->pdcp->config_security(rnti, lcid, pdcp_cnfg); //Comment: This step mainly for log and debug purpose.
+    parent->pdcp->enable_integrity(rnti, lcid);
+    parent->pdcp->enable_encryption(rnti, lcid);
+
+  if(integrity > 0){
+    if(cipher > 0) {
+      parent->pdcp->config_security(rnti, lcid, pdcp_cnfg); //Comment: This step mainly for log and debug purpose.
+      parent->pdcp->enable_integrity(rnti, lcid);
+      parent->pdcp->enable_encryption(rnti, lcid);
+    }
+    else {
+      parent->pdcp->config_security(rnti, lcid, pdcp_cnfg); //Comment: This step mainly for log and debug purpose.
+      parent->pdcp->enable_integrity(rnti, lcid);
+      parent->pdcp->disable_encryption(rnti, lcid);
+    }
+  }
+  else{
+    if(cipher > 0) {
+      parent->pdcp->config_security(rnti, lcid, pdcp_cnfg); //Comment: This step mainly for log and debug purpose.
+      parent->pdcp->disable_integrity(rnti, lcid);
+      parent->pdcp->enable_encryption(rnti, lcid);
+    }
+    else {
+      parent->pdcp->config_security(rnti, lcid, pdcp_cnfg); //Comment: This step mainly for log and debug purpose.
+      parent->pdcp->disable_integrity(rnti, lcid);
+      parent->pdcp->disable_encryption(rnti, lcid);
+    }
+  }
+
+  return 0;
+}
+
 } // namespace srsenb
diff --git a/srsenb/src/stack/rrc/ue_meas_cfg.cc b/srsenb/src/stack/rrc/ue_meas_cfg.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/stack/rrc/ue_rr_cfg.cc b/srsenb/src/stack/rrc/ue_rr_cfg.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/stack/s1ap/CMakeLists.txt b/srsenb/src/stack/s1ap/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsenb/src/stack/s1ap/s1ap.cc b/srsenb/src/stack/s1ap/s1ap.cc
old mode 100644
new mode 100755
index 85e5a9eb7..5a22881fb
--- a/srsenb/src/stack/s1ap/s1ap.cc
+++ b/srsenb/src/stack/s1ap/s1ap.cc
@@ -35,6 +35,10 @@
 #include <string.h>
 #include <sys/socket.h>
 
+// fuzzing
+#include "srsenb/hdr/stack/upper/enb_parse_cmd.h"
+#include "srsenb/hdr/stack/upper/enodeb_statelearner.h"
+
 using srsran::s1ap_mccmnc_to_plmn;
 using srsran::uint32_to_uint8;
 
@@ -333,10 +337,12 @@ s1ap::s1ap(srsran::task_sched_handle   task_sched_,
   mme_task_queue = task_sched.make_task_queue();
 }
 
-int s1ap::init(const s1ap_args_t& args_, rrc_interface_s1ap* rrc_)
+int s1ap::init(const s1ap_args_t& args_, rrc_interface_s1ap* rrc_, enodeb_statelearner_interface_s1ap *enodeb_statelearner_)
 {
   rrc  = rrc_;
   args = args_;
+  // fuzzing
+  enodeb_statelearner = enodeb_statelearner_;
 
   build_tai_cgi();
 
@@ -721,6 +727,7 @@ bool s1ap::handle_initiatingmessage(const init_msg_s& msg)
     case s1ap_elem_procs_o::init_msg_c::types_opts::init_context_setup_request:
       return handle_initialctxtsetuprequest(msg.value.init_context_setup_request());
     case s1ap_elem_procs_o::init_msg_c::types_opts::ue_context_release_cmd:
+      srsran::console("730 Received UE Context Release Command\n");
       return handle_uectxtreleasecommand(msg.value.ue_context_release_cmd());
     case s1ap_elem_procs_o::init_msg_c::types_opts::paging:
       return handle_paging(msg.value.paging());
@@ -836,13 +843,13 @@ bool s1ap::handle_initialctxtsetuprequest(const init_context_setup_request_s& ms
     return false;
   }
 
-  if (u->get_state() == s1ap_proc_id_t::init_context_setup_request) {
-    logger.warning("Initial Context Setup Request already in progress. Ignoring ICS request.");
-    asn1::s1ap::cause_c cause;
-    cause.set_protocol().value = cause_protocol_opts::msg_not_compatible_with_receiver_state;
-    send_error_indication(cause, msg->enb_ue_s1ap_id.value.value, msg->mme_ue_s1ap_id.value.value);
-    return false;
-  }
+  // if (u->get_state() == s1ap_proc_id_t::init_context_setup_request) {
+  //   logger.warning("Initial Context Setup Request already in progress. Ignoring ICS request.");
+  //   asn1::s1ap::cause_c cause;
+  //   cause.set_protocol().value = cause_protocol_opts::msg_not_compatible_with_receiver_state;
+  //   send_error_indication(cause, msg->enb_ue_s1ap_id.value.value, msg->mme_ue_s1ap_id.value.value);
+  //   return false;
+  // }
 
   // Setup UE ctxt in RRC
   if (not rrc->setup_ue_ctxt(u->ctxt.rnti, msg)) {
@@ -1092,9 +1099,10 @@ bool s1ap::handle_uecontextmodifyrequest(const ue_context_mod_request_s& msg)
   }
 
   if (!rrc->modify_ue_ctxt(u->ctxt.rnti, msg)) {
-    cause_c cause;
-    cause.set_misc().value = cause_misc_opts::unspecified;
-    u->send_uectxtmodifyfailure(cause);
+    // cause_c cause;
+    // cause.set_misc().value = cause_misc_opts::unspecified;
+    // u->send_uectxtmodifyfailure(cause);
+    srsran::console("1105 send_uectxtmodifyfailure");
     return true;
   }
 
@@ -1147,6 +1155,7 @@ bool s1ap::handle_uectxtreleasecommand(const ue_context_release_cmd_s& msg)
   rrc->release_erabs(rnti);
   u->send_uectxtreleasecomplete();
   users.erase(u);
+  srsran::console("1156 UE context for RNTI:0x%x released\n", rnti);
   logger.info("UE context for RNTI:0x%x released", rnti);
   rrc->release_ue(rnti);
   return true;
@@ -2318,4 +2327,127 @@ void s1ap::log_s1ap_msg(const asn1::s1ap::s1ap_pdu_c& msg, srsran::const_span<ui
   logger.info(sdu.data(), sdu.size(), "%s S1AP SDU - %s", is_rx ? "Rx" : "Tx", msg_type);
 }
 
+/*******************************************************************************
+/* enodeb_statelearner connection helpers
+********************************************************************************/
+bool s1ap:: execute_command(uint8_t* msg, uint16_t len){
+  bool ret = false;
+
+  printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!/n");
+  
+  srsran::console("Received command\n");
+  if(memcmp(msg, "ue_information_request", sizeof("ue_information_request") - 1) == 0) {
+    srsran::console("RRC_ue_info_req\n");
+    enb::Message message = enb::parseMessage(msg,len);
+    int integrity = 1;
+    int cipher = 1;  //todo add content
+    for(int i=0; i<message.numberOfFields; i++){
+      if (strcmp(message.messageFields[i].messageFieldName, "cipher") == 0) {
+        cipher = message.messageFields[i].messageFieldValue;
+      }
+      else if(strcmp(message.messageFields[i].messageFieldName, "integrity") == 0){
+        integrity =  message.messageFields[i].messageFieldValue;
+      }
+    }
+    rrc->rrc_send_ue_information_request_custom(0, integrity, cipher);  //How to control int and cipher?????
+  }
+  if(memcmp(msg, "counter_check", sizeof("counter_check") - 1) == 0) {
+    srsran::console("RRC_counter_check\n");
+   enb::Message message = enb::parseMessage(msg,len);
+    int integrity = 1;
+    int cipher = 1;  //todo add content
+    for(int i=0; i<message.numberOfFields; i++){
+      if (strcmp(message.messageFields[i].messageFieldName, "cipher") == 0) {
+        cipher = message.messageFields[i].messageFieldValue;
+      }
+      else if(strcmp(message.messageFields[i].messageFieldName, "integrity") == 0){
+        integrity =  message.messageFields[i].messageFieldValue;
+      }
+    }
+    rrc->rrc_send_counter_check_custom(0, integrity, cipher);  //How to control int and cipher?????
+  }
+  if(memcmp(msg, "ue_capability_inquiry", sizeof("ue_capability_inquiry") - 1) == 0) {
+    printf("ue_capability_inquiry!!!!!!!!!!!!!!!\n");
+    srsran::console("RRC_ue_capability_inquiry\n");
+    enb::Message message = enb::parseMessage(msg,len);
+    int integrity = 1;
+    int cipher = 1;  //todo add content
+    for(int i=0; i<message.numberOfFields; i++){
+      if (strcmp(message.messageFields[i].messageFieldName, "cipher") == 0) {
+        cipher = message.messageFields[i].messageFieldValue;
+      }
+      else if(strcmp(message.messageFields[i].messageFieldName, "integrity") == 0){
+        integrity =  message.messageFields[i].messageFieldValue;
+      }
+    }
+    rrc->rrc_send_ue_capability_enquiry_custom(0, integrity,cipher); 
+    printf("send!!!\n"); 
+  }
+  if(memcmp(msg, "rrc_security_mode_command", sizeof("rrc_security_mode_command") - 1) == 0) {
+    srsran::console("RRC_security_mode_command\n");
+    printf("rrc_security_mode_command!!!!!!!!!!!!!!!\n");
+    enb::Message message = enb::parseMessage(msg,len);
+    int integrity = 1;
+    int eia = 1;  //todo add content
+    int eea = 1;
+    for(int i=0; i<message.numberOfFields; i++){
+      if (strcmp(message.messageFields[i].messageFieldName, "integrity") == 0) {
+        integrity = message.messageFields[i].messageFieldValue;
+      }
+      else if(strcmp(message.messageFields[i].messageFieldName, "EIA") == 0){
+        eia =  message.messageFields[i].messageFieldValue;
+      }
+      else if(strcmp(message.messageFields[i].messageFieldName, "EEA") == 0){
+        eea =  message.messageFields[i].messageFieldValue;
+      }
+    }
+    srsran::console("2401");
+    srsran::console("%d %d %d\n",integrity, eia, eea);
+    rrc->rrc_send_security_mode_command_custom(0, integrity, eia, eea);  //How to control int and cipher?????
+  }
+  if(memcmp(msg, "rrc_reconf", sizeof("rrc_reconf") - 1) == 0) {
+    srsran::console("RRC_rrc_reconf\n");
+    printf("rrc_reconf!!!!!!!!!!!!!!!\n");
+    enb::Message message = enb::parseMessage(msg,len);
+    int integrity = 1;
+    int cipher = 1;
+    int to_add_mod_list = 0;  //todo add content
+    int set_srb2 = 0;
+    int set_drb = 0;
+    int meas_config = 0;
+    int replay = 0;
+    for(int i=0; i<message.numberOfFields; i++){
+      if (strcmp(message.messageFields[i].messageFieldName, "integrity") == 0) {
+        integrity = message.messageFields[i].messageFieldValue;
+      }
+      else if(strcmp(message.messageFields[i].messageFieldName, "cipher") == 0){
+        cipher =  message.messageFields[i].messageFieldValue;
+      }
+      else if(strcmp(message.messageFields[i].messageFieldName, "to_add_mod_list") == 0){
+        to_add_mod_list =  message.messageFields[i].messageFieldValue;
+      }
+      else if(strcmp(message.messageFields[i].messageFieldName, "meas_config") == 0){
+        meas_config =  message.messageFields[i].messageFieldValue;
+      }
+      else if(strcmp(message.messageFields[i].messageFieldName, "replay") == 0){
+        replay =  message.messageFields[i].messageFieldValue;
+      }
+    }
+    rrc->rrc_send_connection_reconf_custom(0, integrity, cipher, set_srb2, set_drb, meas_config, replay);  //How to control int and cipher?????
+  }
+
+  if(memcmp(msg, "rrc_release", sizeof("rrc_release") - 1) == 0) {
+    srsran::console("rrc_release\n");
+    int integrity = 1;
+    int cipher = 1;
+    rrc->send_rrc_release_custom(0, integrity, cipher);
+  }
+
+  return true;
+}
+
+bool s1ap::notify_response(uint8_t *response, uint16_t size) {
+  return enodeb_statelearner->notify_response(response, size);
+}
+
 } // namespace srsenb
diff --git a/srsenb/src/stack/upper/CMakeLists.txt b/srsenb/src/stack/upper/CMakeLists.txt
old mode 100644
new mode 100755
index fd740ae4b..47953af04
--- a/srsenb/src/stack/upper/CMakeLists.txt
+++ b/srsenb/src/stack/upper/CMakeLists.txt
@@ -18,6 +18,6 @@
 # and at http://www.gnu.org/licenses/.
 #
 
-set(SOURCES gtpu.cc pdcp.cc rlc.cc)
+set(SOURCES gtpu.cc pdcp.cc rlc.cc enb_parse_cmd.cc enodeb_statelearner.cc)
 add_library(srsenb_upper STATIC ${SOURCES})
 target_link_libraries(srsenb_upper srsran_asn1 srsran_gtpu)
\ No newline at end of file
diff --git a/srsenb/src/stack/upper/enb_parse_cmd.cc b/srsenb/src/stack/upper/enb_parse_cmd.cc
new file mode 100755
index 000000000..d0ef8a926
--- /dev/null
+++ b/srsenb/src/stack/upper/enb_parse_cmd.cc
@@ -0,0 +1,133 @@
+// message_parser.cc
+#include "srsenb/hdr/stack/upper/enb_parse_cmd.h"
+#include <string>
+#include <unistd.h>
+#include <sstream>
+#include <iostream>
+#include <cstring>
+#include <cstdint>
+#include <algorithm>
+
+namespace enb {
+
+Message parseMessage(const uint8_t *data, size_t length) {
+    Message message = {};  // Zero-initialize the struct
+    std::string input(data, data + length);  // Convert uint8_t* to std::string
+    std::stringstream ss(input);
+
+    // Parse the message name
+    std::string temp;
+    std::getline(ss, temp, ':');
+    if (ss.fail() || temp.empty()) {
+        std::cerr << "Debug: Missing ':' or message name." << std::endl;
+        return message;  // Return an empty message
+    }
+
+    strncpy(message.messageName, temp.c_str(), sizeof(message.messageName) - 1);  // Copy message name with safety
+
+    // If the right side is missing or only contains spaces, just return the message with the name
+    if (ss.peek() == EOF || std::all_of(std::istreambuf_iterator<char>(ss), std::istreambuf_iterator<char>(), ::isspace)) {
+        return message;  // Return message with only the name
+    }
+
+    // Parse each field-value pair
+    std::string fieldStr;
+    while (std::getline(ss, fieldStr, '&') && message.numberOfFields < 10) {
+        MessageField field = {};  // Zero-initialize
+        
+        // Clean up spaces
+        fieldStr = fieldStr.substr(fieldStr.find_first_not_of(' '), fieldStr.find_last_not_of(' ') - fieldStr.find_first_not_of(' ') + 1);
+
+        // Split the fieldStr into name and value using "==" as delimiter
+        size_t delimiterPos = fieldStr.find("==");
+        if (delimiterPos == std::string::npos) {
+            std::cerr << "Debug: Missing '==' in field definition: " << fieldStr << std::endl;
+            continue;  // Skip this field and continue with the next
+        }
+        // Extract and trim field name and value
+        std::string fieldName = fieldStr.substr(0, delimiterPos);
+        fieldName = fieldName.substr(fieldName.find_first_not_of(' '), fieldName.find_last_not_of(' ') - fieldName.find_first_not_of(' ') + 1);
+        strncpy(field.messageFieldName, fieldName.c_str(), sizeof(field.messageFieldName) - 1);  // Copy field name with safety
+
+        std::string valueStr = fieldStr.substr(delimiterPos + 2);
+        field.messageFieldValue = std::stoi(valueStr.substr(valueStr.find_first_not_of(' ')));
+
+        message.messageFields[message.numberOfFields] = field;
+        message.numberOfFields++;
+    }
+    return message;
+}
+
+void printMessage(const Message& message) {
+    std::cout << "Message Name: " << message.messageName << std::endl;
+    
+    for (int i = 0; i < message.numberOfFields; i++) {
+        std::cout << "\tField Name: " << message.messageFields[i].messageFieldName 
+                  << " Value: " << message.messageFields[i].messageFieldValue << std::endl;
+    }
+}
+
+uint8_t* constructMessage(const char* messageName, const MessageField* fields, int numFields) {
+    std::ostringstream oss;
+    oss << messageName << ":";
+
+    if (fields && numFields > 0) {
+        for (int i = 0; i < numFields; ++i) {
+            oss << " " << fields[i].messageFieldName << " == " << fields[i].messageFieldValue;
+            if (i != numFields - 1) {  // not the last field
+                oss << " &";
+            }
+        }
+    }
+    
+    std::string resultStr = oss.str();
+    uint8_t* result = new uint8_t[resultStr.length() + 1];  // +1 for null terminator
+    std::copy(resultStr.begin(), resultStr.end(), result);
+    result[resultStr.length()] = '\0';  // null-terminate
+
+    return result;
+}
+
+uint8_t* handleNullAction() {
+    uint8_t* message = constructMessage("null_action", nullptr, 0);
+    std::cout << message << std::endl;
+    return message;
+}
+
+uint8_t* handleRRCSecurityModeComplete() {
+    uint8_t* message = constructMessage("rrc_security_mode_complete", nullptr, 0);
+    std::cout << message << std::endl;
+    return message;
+}
+
+uint8_t* handleRRCUECapInfo() {
+    uint8_t* message = constructMessage("rrc_ue_cap_info", nullptr, 0);
+    std::cout << message << std::endl;
+    return message;
+}
+
+uint8_t* handleCounterCheckResponse() {
+    uint8_t* message = constructMessage("counter_check_response", nullptr, 0);
+    std::cout << message << std::endl;
+    return message;
+}
+
+uint8_t* handleUEInformationResponse() {
+    uint8_t* message = constructMessage("ue_information_response", nullptr, 0);
+    std::cout << message << std::endl;
+    return message;
+}
+
+uint8_t* handleRRCReconfComplete() {
+    uint8_t* message = constructMessage("rrc_reconf_complete", nullptr, 0);
+    std::cout << message << std::endl;
+    return message;
+}
+
+uint8_t* handleRRCSecurityModeFailure() {
+    uint8_t* message = constructMessage("rrc_security_mode_failure", nullptr, 0);
+    std::cout << message << std::endl;
+    return message;
+}
+
+} // namespace enb
\ No newline at end of file
diff --git a/srsenb/src/stack/upper/enodeb_statelearner.cc b/srsenb/src/stack/upper/enodeb_statelearner.cc
new file mode 100755
index 000000000..e46d72dea
--- /dev/null
+++ b/srsenb/src/stack/upper/enodeb_statelearner.cc
@@ -0,0 +1,173 @@
+/*
+ *  Authors: Imtiaz Karim, Syed Rafiul Hussain, Abdullah Al Ishtiaq
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+#include "srsenb/hdr/stack/upper/enodeb_statelearner.h"
+#include <iostream>
+#include <inttypes.h> // for printing uint64_t
+#include "srsenb/hdr/stack/upper/enb_parse_cmd.h"
+#include "srsran/interfaces/enb_s1ap_interfaces.h"
+
+namespace srsenb {
+enodeb_statelearner *enodeb_statelearner::m_instance = NULL;
+pthread_mutex_t enodeb_statelearner_instance_mutex = PTHREAD_MUTEX_INITIALIZER;
+pthread_mutex_t enodeb_statelearner_reset_state_mutex = PTHREAD_MUTEX_INITIALIZER;
+    enodeb_statelearner::enodeb_statelearner(): thread("ENODEB_STATELEARNER"){
+        running = false;
+        statelearner_connected       = false;
+        return;
+    }
+
+    int
+    enodeb_statelearner::init(s1ap_interface_enodeb_statelearner* s1ap_) {
+        m_s1ap = s1ap_;
+        running             = false;
+        start();
+        printf("enodeb-statelearner initialized\n");
+        return SRSRAN_SUCCESS;
+    }
+
+
+    void enodeb_statelearner::run_thread() {
+
+        printf("The enodeb_statelearner thread has been started...\n");
+
+        int sock_fd, err;
+        struct sockaddr_in enodeblearnlib_server_addr;
+
+
+        // socket create and verification
+        sock_fd = socket(AF_INET, SOCK_STREAM, 0);
+        if (sock_fd == -1) {
+            printf("enodeb-statelearner erver socket creation failed...\n");
+            return ;
+        }
+
+        bzero(&enodeblearnlib_server_addr, sizeof(enodeblearnlib_server_addr));
+        // assign IP, PORT
+        enodeblearnlib_server_addr.sin_family = AF_INET;
+        enodeblearnlib_server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
+        inet_pton(AF_INET, "127.0.0.1", &(enodeblearnlib_server_addr.sin_addr));
+        enodeblearnlib_server_addr.sin_port = htons(60001);
+        err = bind(sock_fd, (struct sockaddr *) &enodeblearnlib_server_addr, sizeof(enodeblearnlib_server_addr));
+        if (err != 0) {
+            close(sock_fd);
+            printf("Error binding TCP socket for s1ap-learnlib server\n");
+            return;
+        }
+        //Listen for connections
+        err = listen(sock_fd, SOMAXCONN);
+        if (err != 0) {
+            close(sock_fd);
+            printf("Error in s1ap-learnlib TCP socket listen\n");
+            return;
+        }
+
+        srsran::unique_byte_buffer_t pdu_buffer = srsran::make_byte_buffer("enodeb_statelearner::run_thread");
+        if (pdu_buffer == nullptr) {
+            printf("Couldn't allocate PDU in %s().", __FUNCTION__);
+            return;
+        }
+        srsran::byte_buffer_t* pdu = pdu_buffer.get();
+
+        uint32_t sz = SRSRAN_MAX_BUFFER_SIZE_BYTES - SRSRAN_BUFFER_HEADER_OFFSET;
+
+        m_enodeb_statelearner_sock = accept(sock_fd, (struct sockaddr *)NULL, (socklen_t *)NULL);
+        if(m_enodeb_statelearner_sock<0){
+            perror("Client accept failed\n");
+            return;
+        }
+        printf("Statelearner is connected\n");
+        running = true;
+        int rd_sz;
+
+        bool ret;
+        while (running) {
+            pdu->clear();
+            rd_sz = recv(m_enodeb_statelearner_sock, pdu->msg, sz, 0);
+
+            if(rd_sz == -1)
+            {
+                //printf("ERROR reading from TCP socket\n");
+            }
+            if(rd_sz == 0){
+                printf("Client Disconnected. Need to run SRSEPC again.\n");
+                return;
+            }
+            else{
+                //printf("Received a message\n");
+                pdu->N_bytes = rd_sz;
+                pdu->msg[pdu->N_bytes] = '\0';
+                printf("\nReceived Query from Statelearner = %s\n", pdu->msg);
+
+                if(memcmp(pdu->msg, "Hello\n", pdu->N_bytes) == 0) {
+                    printf("### Received the expected HELLO message ###\n");
+                    uint8_t response[5] = "ACK\n";
+                    uint8_t size = 5;
+                    notify_response(response, size);
+                }
+                else {
+                    ret = m_s1ap->execute_command(pdu->msg, pdu->N_bytes);
+                    if (ret == false) {
+                        uint8_t response[13] = "null_action:";
+                        uint8_t size = 13;
+                        uint8_t* messageStr = enb::handleNullAction();
+                        uint16_t len = static_cast<uint16_t>(strlen((char*)messageStr));
+                        notify_response(messageStr, len);
+                    }
+                }
+
+            }
+        }
+        close(sock_fd);
+    }
+
+    void
+    enodeb_statelearner::stop() {
+        if(running) {
+            running = false;
+            sleep(0.1);
+            thread_cancel();
+            wait_thread_finish();
+        }
+
+        if (m_enodeb_statelearner_sock != -1){
+            close(m_enodeb_statelearner_sock);
+        }
+        return;
+    }
+
+    
+    enodeb_statelearner*
+    enodeb_statelearner::get_instance(void) {
+      pthread_mutex_lock(&enodeb_statelearner_instance_mutex);
+      if (NULL == m_instance) {
+        printf("created a new instance!!\n");
+        m_instance = new enodeb_statelearner();
+      }
+      pthread_mutex_unlock(&enodeb_statelearner_instance_mutex);
+      return (m_instance);
+    }
+
+bool enodeb_statelearner::notify_response(uint8_t *msg, uint16_t len) {
+        printf("Sending response to statelearner\n");
+        if ((send(m_enodeb_statelearner_sock, msg, len, 0)) < 0)
+        {
+            perror("Error in Send to Statelearner");
+            exit(0);
+        }
+        return true;
+    }
+}
\ No newline at end of file
diff --git a/srsenb/src/stack/upper/gtpu.cc b/srsenb/src/stack/upper/gtpu.cc
old mode 100644
new mode 100755
diff --git a/srsenb/src/stack/upper/pdcp.cc b/srsenb/src/stack/upper/pdcp.cc
old mode 100644
new mode 100755
index cc30f39d9..2db9d8a69
--- a/srsenb/src/stack/upper/pdcp.cc
+++ b/srsenb/src/stack/upper/pdcp.cc
@@ -126,6 +126,17 @@ void pdcp::enable_encryption(uint16_t rnti, uint32_t lcid)
   users[rnti].pdcp->enable_encryption(lcid, srsran::DIRECTION_TXRX);
 }
 
+// fuzzing
+void pdcp::disable_integrity(uint16_t rnti, uint32_t lcid)
+{
+  users[rnti].pdcp->disable_integrity(lcid);
+}
+
+void pdcp::disable_encryption(uint16_t rnti, uint32_t lcid)
+{
+  users[rnti].pdcp->disable_encryption(lcid);
+}
+
 bool pdcp::get_bearer_state(uint16_t rnti, uint32_t lcid, srsran::pdcp_lte_state_t* state)
 {
   if (users.count(rnti) == 0) {
diff --git a/srsenb/src/stack/upper/rlc.cc b/srsenb/src/stack/upper/rlc.cc
old mode 100644
new mode 100755
diff --git a/srsenb/test/CMakeLists.txt b/srsenb/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsenb/test/common/dummy_classes.h b/srsenb/test/common/dummy_classes.h
old mode 100644
new mode 100755
index 64a0e6537..eee066c32
--- a/srsenb/test/common/dummy_classes.h
+++ b/srsenb/test/common/dummy_classes.h
@@ -106,6 +106,9 @@ public:
   {
     return true;
   }
+
+  // fuzzing
+  bool notify_response(uint8_t *response, uint16_t size) override { return true; }
 };
 
 class phy_dummy : public phy_interface_rrc_lte
@@ -182,6 +185,13 @@ public:
   void set_erab_status(uint16_t rnti, const asn1::s1ap::bearers_subject_to_status_transfer_list_l& erabs) override {}
 
   int notify_ue_erab_updates(uint16_t rnti, srsran::const_byte_span nas_pdu) override { return SRSRAN_SUCCESS; }
+
+  // fuzzing
+  void rrc_send_ue_capability_enquiry_custom(uint16_t rnti, int integrity, int cipher) override {}
+  void rrc_send_ue_information_request_custom(uint16_t rnti, int integrity, int cipher) override {}
+  void rrc_send_counter_check_custom(uint16_t rnti, int integrity, int cipher) override {}
+  void rrc_send_security_mode_command_custom(uint16_t rnti, int integrity, int eia, int eea) override {}
+  void rrc_send_connection_reconf_custom(uint16_t rnti, int integrity, int cipher, int set_srb2, int set_drb, int meas_config, int replay) override {}
 };
 
 } // namespace srsenb
diff --git a/srsenb/test/common/dummy_classes_common.h b/srsenb/test/common/dummy_classes_common.h
old mode 100644
new mode 100755
index edb022b6a..12e48d56a
--- a/srsenb/test/common/dummy_classes_common.h
+++ b/srsenb/test/common/dummy_classes_common.h
@@ -68,6 +68,9 @@ public:
   {
     return {};
   }
+  // fuzzing
+  void disable_integrity(uint16_t rnti, uint32_t lcid) override {}
+  void disable_encryption(uint16_t rnti, uint32_t lcid) override {}
 };
 
 } // namespace srsenb
diff --git a/srsenb/test/common/rlc_test_dummy.h b/srsenb/test/common/rlc_test_dummy.h
old mode 100644
new mode 100755
diff --git a/srsenb/test/enb_metrics_test.cc b/srsenb/test/enb_metrics_test.cc
old mode 100644
new mode 100755
diff --git a/srsenb/test/mac/CMakeLists.txt b/srsenb/test/mac/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsenb/test/mac/sched_benchmark.cc b/srsenb/test/mac/sched_benchmark.cc
old mode 100644
new mode 100755
diff --git a/srsenb/test/mac/sched_ca_test.cc b/srsenb/test/mac/sched_ca_test.cc
old mode 100644
new mode 100755
diff --git a/srsenb/test/mac/sched_common_test_suite.cc b/srsenb/test/mac/sched_common_test_suite.cc
old mode 100644
new mode 100755
diff --git a/srsenb/test/mac/sched_common_test_suite.h b/srsenb/test/mac/sched_common_test_suite.h
old mode 100644
new mode 100755
diff --git a/srsenb/test/mac/sched_cqi_test.cc b/srsenb/test/mac/sched_cqi_test.cc
old mode 100644
new mode 100755
diff --git a/srsenb/test/mac/sched_dci_test.cc b/srsenb/test/mac/sched_dci_test.cc
old mode 100644
new mode 100755
diff --git a/srsenb/test/mac/sched_grid_test.cc b/srsenb/test/mac/sched_grid_test.cc
old mode 100644
new mode 100755
diff --git a/srsenb/test/mac/sched_lc_ch_test.cc b/srsenb/test/mac/sched_lc_ch_test.cc
old mode 100644
new mode 100755
diff --git a/srsenb/test/mac/sched_phy_resource_test.cc b/srsenb/test/mac/sched_phy_resource_test.cc
old mode 100644
new mode 100755
diff --git a/srsenb/test/mac/sched_sim_ue.cc b/srsenb/test/mac/sched_sim_ue.cc
old mode 100644
new mode 100755
diff --git a/srsenb/test/mac/sched_sim_ue.h b/srsenb/test/mac/sched_sim_ue.h
old mode 100644
new mode 100755
diff --git a/srsenb/test/mac/sched_test_common.cc b/srsenb/test/mac/sched_test_common.cc
old mode 100644
new mode 100755
diff --git a/srsenb/test/mac/sched_test_common.h b/srsenb/test/mac/sched_test_common.h
old mode 100644
new mode 100755
diff --git a/srsenb/test/mac/sched_test_rand.cc b/srsenb/test/mac/sched_test_rand.cc
old mode 100644
new mode 100755
diff --git a/srsenb/test/mac/sched_test_utils.h b/srsenb/test/mac/sched_test_utils.h
old mode 100644
new mode 100755
diff --git a/srsenb/test/mac/sched_tpc_test.cc b/srsenb/test/mac/sched_tpc_test.cc
old mode 100644
new mode 100755
diff --git a/srsenb/test/mac/sched_ue_cell_test.cc b/srsenb/test/mac/sched_ue_cell_test.cc
old mode 100644
new mode 100755
diff --git a/srsenb/test/mac/sched_ue_ded_test_suite.cc b/srsenb/test/mac/sched_ue_ded_test_suite.cc
old mode 100644
new mode 100755
diff --git a/srsenb/test/mac/sched_ue_ded_test_suite.h b/srsenb/test/mac/sched_ue_ded_test_suite.h
old mode 100644
new mode 100755
diff --git a/srsenb/test/phy/CMakeLists.txt b/srsenb/test/phy/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsenb/test/phy/enb_phy_test.cc b/srsenb/test/phy/enb_phy_test.cc
old mode 100644
new mode 100755
diff --git a/srsenb/test/rrc/CMakeLists.txt b/srsenb/test/rrc/CMakeLists.txt
old mode 100644
new mode 100755
index b07a2b3f3..9d5c9a214
--- a/srsenb/test/rrc/CMakeLists.txt
+++ b/srsenb/test/rrc/CMakeLists.txt
@@ -19,7 +19,7 @@
 #
 
 add_library(test_helpers STATIC test_helpers.cc)
-target_link_libraries(test_helpers srsenb_rrc srsenb_common rrc_asn1 rrc_nr_asn1 s1ap_asn1 srsran_common enb_cfg_parser ${LIBCONFIGPP_LIBRARIES})
+target_link_libraries(test_helpers srsenb_rrc srsenb_common rrc_asn1 rrc_nr_asn1 s1ap_asn1 srsran_common enb_cfg_parser srsenb_upper ${LIBCONFIGPP_LIBRARIES})
 
 add_executable(rrc_meascfg_test rrc_meascfg_test.cc)
 target_link_libraries(rrc_meascfg_test test_helpers ${ATOMIC_LIBS})
diff --git a/srsenb/test/rrc/erab_setup_test.cc b/srsenb/test/rrc/erab_setup_test.cc
old mode 100644
new mode 100755
diff --git a/srsenb/test/rrc/rrc_meascfg_test.cc b/srsenb/test/rrc/rrc_meascfg_test.cc
old mode 100644
new mode 100755
diff --git a/srsenb/test/rrc/rrc_mobility_test.cc b/srsenb/test/rrc/rrc_mobility_test.cc
old mode 100644
new mode 100755
diff --git a/srsenb/test/rrc/rrc_paging_test.cc b/srsenb/test/rrc/rrc_paging_test.cc
old mode 100644
new mode 100755
diff --git a/srsenb/test/rrc/test_helpers.cc b/srsenb/test/rrc/test_helpers.cc
old mode 100644
new mode 100755
diff --git a/srsenb/test/rrc/test_helpers.h b/srsenb/test/rrc/test_helpers.h
old mode 100644
new mode 100755
diff --git a/srsenb/test/s1ap/CMakeLists.txt b/srsenb/test/s1ap/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsenb/test/s1ap/s1ap_test.cc b/srsenb/test/s1ap/s1ap_test.cc
old mode 100644
new mode 100755
index c4eb39be4..6a7383423
--- a/srsenb/test/s1ap/s1ap_test.cc
+++ b/srsenb/test/s1ap/s1ap_test.cc
@@ -233,7 +233,7 @@ void test_s1ap_erab_setup(test_event event)
   args.mme_addr      = mme_addr_str;
   args.enb_name      = "srsenb01";
 
-  TESTASSERT(s1ap_obj.init(args, &rrc) == SRSRAN_SUCCESS);
+  TESTASSERT(s1ap_obj.init(args, &rrc, nullptr) == SRSRAN_SUCCESS); // fuzzing
   // The S1 Setup Procedure will call `notify_background_task_result`
   // which we need to manually trigger with `run_next_task()`
   task_sched.run_next_task();
diff --git a/srsenb/test/upper/CMakeLists.txt b/srsenb/test/upper/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsenb/test/upper/gtpu_test.cc b/srsenb/test/upper/gtpu_test.cc
old mode 100644
new mode 100755
diff --git a/srsenb/test/upper/plmn_test.cc b/srsenb/test/upper/plmn_test.cc
old mode 100644
new mode 100755
diff --git a/srsepc/CMakeLists.txt b/srsepc/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsepc/epc.conf.example b/srsepc/epc.conf.example
old mode 100644
new mode 100755
diff --git a/srsepc/hdr/hss/hss.h b/srsepc/hdr/hss/hss.h
old mode 100644
new mode 100755
diff --git a/srsepc/hdr/mbms-gw/mbms-gw.h b/srsepc/hdr/mbms-gw/mbms-gw.h
old mode 100644
new mode 100755
diff --git a/srsepc/hdr/mme/mme.h b/srsepc/hdr/mme/mme.h
old mode 100644
new mode 100755
index 00a701c20..1e8684f1b
--- a/srsepc/hdr/mme/mme.h
+++ b/srsepc/hdr/mme/mme.h
@@ -70,6 +70,7 @@ private:
   static mme* m_instance;
   s1ap*       m_s1ap;
   mme_gtpc*   m_mme_gtpc;
+  mme_statelearner* m_mme_statelearner;
 
   bool   m_running;
   fd_set m_set;
diff --git a/srsepc/hdr/mme/mme_gtpc.h b/srsepc/hdr/mme/mme_gtpc.h
old mode 100644
new mode 100755
diff --git a/srsepc/hdr/mme/mme_statelearner.h b/srsepc/hdr/mme/mme_statelearner.h
new file mode 100755
index 000000000..1a250da7d
--- /dev/null
+++ b/srsepc/hdr/mme/mme_statelearner.h
@@ -0,0 +1,75 @@
+//
+// Created by rafiul on 11/29/18.
+//
+
+#ifndef SRSLTE_MME_STATELEARNER_H
+#define SRSLTE_MME_STATELEARNER_H
+
+#include "srsran/common/buffer_pool.h"
+#include "s1ap_common.h"
+#include "srsran/common/threads.h"
+#include "srsran/interfaces/epc_interfaces.h"
+#include "srsran/common/fuzzing.h"
+
+namespace srsepc
+{
+
+    class mme_statelearner: public mme_statelearner_interface_s1ap,
+                            public srsran::thread
+    {
+    public:
+
+        /*
+        typedef struct gtpc_ctx{
+          srslte::gtp_fteid_t mme_ctr_fteid;
+          srslte::gtp_fteid_t sgw_ctr_fteid;
+        }gtpc_ctx_t;
+        */
+        mme_statelearner();
+        static mme_statelearner* get_instance(void);
+        static void cleanup(void);
+
+        bool init(s1ap_interface_mme_statelearner *s1ap_);
+        void stop();
+
+        // server
+        int statelearner_listen();
+        int get_mme_statelearner();
+
+
+        //client
+        //bool connect_statelearner();
+        bool notify_response(uint8_t *msg, uint16_t len);
+        void run_thread();
+
+        void set_mme_statelearner_reset_state();
+        void reset_mme_statelearner_reset_state();
+        bool get_mme_statelearner_reset_state();
+
+    private:
+
+        mme_statelearner(const std::string &name_);
+        virtual ~mme_statelearner();
+        static mme_statelearner *m_instance;
+
+        s1ap_interface_mme_statelearner* m_s1ap;
+
+        in_addr_t m_mme_statelearner_ip;
+        int m_mme_statelearner_sock;
+
+        bool running = false;
+        bool statelearner_connected       = false;
+        bool mme_statelearner_reset_state = false;
+
+        // Not sure if the following are required
+        /*
+        uint32_t m_next_ctrl_teid;
+        std::map<uint32_t,uint64_t> m_mme_ctr_teid_to_imsi;
+        std::map<uint64_t,struct gtpc_ctx> m_imsi_to_learnlib_ctx;
+        */
+
+    };
+
+}
+
+#endif //SRSLTE_MME_STATELEARNER_H
diff --git a/srsepc/hdr/mme/nas.h b/srsepc/hdr/mme/nas.h
old mode 100644
new mode 100755
index 88364cdcd..ef0a815ad
--- a/srsepc/hdr/mme/nas.h
+++ b/srsepc/hdr/mme/nas.h
@@ -123,6 +123,8 @@ typedef struct {
   bool                                    ms_network_cap_present;
   LIBLTE_MME_MS_NETWORK_CAPABILITY_STRUCT ms_network_cap;
   LIBLTE_MME_EPS_MOBILE_ID_GUTI_STRUCT    guti;
+  // --------------------------Fuzzing-------------------------
+  uint8_t                                 k_asme_tmp[32];
 } sec_ctx_t;
 
 /*
@@ -143,6 +145,8 @@ typedef struct {
   srsran::INTEGRITY_ALGORITHM_ID_ENUM integ_algo;
   bool                                request_imeisv;
   uint16_t                            lac;
+  uint64_t                            ue_under_test_imsi; // For fuzzing
+  bool                                enable_ue_state_fuzzing; // For fuzzing
 } nas_init_t;
 
 typedef struct {
@@ -227,7 +231,7 @@ public:
   /* Uplink NAS messages handling */
   bool handle_attach_request(srsran::byte_buffer_t* nas_rx);
   bool handle_pdn_connectivity_request(srsran::byte_buffer_t* nas_rx);
-  bool handle_authentication_response(srsran::byte_buffer_t* nas_rx);
+  bool handle_authentication_response(srsran::byte_buffer_t* nas_rx, int flag);
   bool handle_security_mode_complete(srsran::byte_buffer_t* nas_rx);
   bool handle_attach_complete(srsran::byte_buffer_t* nas_rx);
   bool handle_esm_information_response(srsran::byte_buffer_t* nas_rx);
@@ -236,6 +240,13 @@ public:
   bool handle_authentication_failure(srsran::byte_buffer_t* nas_rx);
   bool handle_detach_request(srsran::byte_buffer_t* nas_rx);
 
+  // Fuzzing
+  bool handle_uplink_nas_transport(srsran::byte_buffer_t* nas_rx);
+  bool handle_security_mode_reject(srsran::byte_buffer_t* nas_rx);
+  bool handle_nas_emm_status(srsran::byte_buffer_t *nas_msg);
+  bool handle_tracking_area_update_complete(srsran::byte_buffer_t* nas_rx);
+  bool handle_guti_reallocation_complete(srsran::byte_buffer_t* nas_rx);
+
   /* Downlink NAS messages packing */
   bool pack_authentication_request(srsran::byte_buffer_t* nas_buffer);
   bool pack_authentication_reject(srsran::byte_buffer_t* nas_buffer);
@@ -246,6 +257,19 @@ public:
   bool pack_service_reject(srsran::byte_buffer_t* nas_buffer, uint8_t emm_cause);
   bool pack_tracking_area_update_reject(srsran::byte_buffer_t* nas_buffer, uint8_t emm_cause);
   bool pack_attach_accept(srsran::byte_buffer_t* nas_buffer);
+  bool pack_detach_request(srsran::byte_buffer_t* nas_buffer);
+
+  // Fuzzing
+  bool pack_authentication_request_custom(srsran::byte_buffer_t* nas_buffer, int cipher, int integrity, int replay, int seperation_bit, int sqn, int security_header_type);
+  bool pack_security_mode_command_custom(srsran::byte_buffer_t* nas_buffer, int cipher, int integrity, int auth_parameter, int hash_mme, int eia, int eea, int security_header_type);
+  bool pack_guti_reallocation_request_custom(srsran::byte_buffer_t* nas_buffer, int cipher, int integrity, int replay, int security_header_type);
+  bool pack_identity_request_custom(srsran::byte_buffer_t* nas_buffer, int cipher, int integrity, int replay, int identification_parameter, int security_header_type);
+  bool pack_dl_nas_transport_custom(srsran::byte_buffer_t* nas_buffer, int cipher, int integrity, int replay, int security_header_type);
+  bool pack_attach_accept_custom(srsran::byte_buffer_t* nas_buffer, int cipher, int integrity, int replay, int security_header_type);
+  // TODO: finish implementation of the following functions
+  bool pack_service_reject_custom(srsran::byte_buffer_t* nas_buffer, uint8_t emm_cause, int security_header_type);
+  bool pack_attach_reject_custom(srsran::byte_buffer_t* nas_buffer, uint8_t emm_cause);
+  // Can detach request be sent from MME to UE?
 
   /* Security functions */
   bool integrity_check(srsran::byte_buffer_t* pdu, bool warn_failure = true);
@@ -253,6 +277,7 @@ public:
   void integrity_generate(srsran::byte_buffer_t* pdu, uint8_t* mac);
   void cipher_decrypt(srsran::byte_buffer_t* pdu);
   void cipher_encrypt(srsran::byte_buffer_t* pdu);
+  void cipher_encrypt_null(srsran::byte_buffer_t* pdu); // fuzzing
 
   /*Timer functions*/
   bool start_timer(enum nas_timer_type type);
@@ -264,8 +289,29 @@ public:
   esm_ctx_t m_esm_ctx[MAX_ERABS_PER_UE] = {};
   sec_ctx_t m_sec_ctx                   = {};
 
+  //============================ Fuzzing ======================
+  bool handle_statelearner_query_identity_request_custom(int cipher, int integrity, int replay, int identification_parameter, int security_header_type);
+  bool handle_statelearner_query_authentication_request_custom(int cipher, int integrity, int replay, int seperation_bit, int sqn, int security_header_type);
+  bool handle_statelearner_query_security_mode_command_custom(int cipher, int integrity, int replay, int auth_parameter, int eia, int eea, int security_header_type);
+  bool handle_statelearner_query_attach_accept_custom(int cipher, int integrity, int replay, int security_header_type);
+  bool handle_statelearner_query_guti_rellocation_custom(int cipher, int integrity, int replay, int security_header_type);
+  bool handle_statelearner_query_dl_nas_transport_custom(int cipher, int integrity, int replay, int security_header_type);
+  bool handle_statelearner_query_service_reject_custom(int emm_cause, int security_header_type);
+  bool handle_statelearner_query_attach_reject_custom(int emm_cause);
+  bool handle_statelearner_query_authentication_reject_custom();
+  // emm_information (not sure if need)
+  bool handle_statelearner_query_emm_information();
+  bool handle_statelearner_query_detach_request_custom(int integrity, int cipher, int security_header_type);
+  // bool handle_statelearner_query_detach_request_custom(int integrity, int cipher, int reattach_required, int security_header_type, int emm_cause);
+  bool handle_statelearner_query_reset_attach_accept_setup();
+  bool handle_statelearner_query_authentication_request();
+  bool handle_statelearner_query_attach_accept_single();
+  bool handle_statelearner_query_security_mode_command();
+  bool handle_statelearner_query_identity_request();
+
 private:
   srslog::basic_logger& m_logger = srslog::fetch_basic_logger("NAS");
+  // srsran::byte_buffer_pool*  m_pool = nullptr;
   gtpc_interface_nas*   m_gtpc   = nullptr;
   s1ap_interface_nas*   m_s1ap   = nullptr;
   hss_interface_nas*    m_hss    = nullptr;
@@ -283,6 +329,9 @@ private:
   bool        m_request_imeisv = false;
   uint16_t    m_lac            = 0;
 
+  uint64_t m_ue_under_test_imsi = 0; // Fuzzing
+  bool m_enable_ue_state_fuzzing = false; // Fuzzing
+
   // Timers timeout values
   uint16_t m_t3413 = 0;
 
diff --git a/srsepc/hdr/mme/parse_cmd.h b/srsepc/hdr/mme/parse_cmd.h
new file mode 100755
index 000000000..e9e7dce59
--- /dev/null
+++ b/srsepc/hdr/mme/parse_cmd.h
@@ -0,0 +1,56 @@
+#pragma once
+
+#ifndef PARSE_CMD_H
+#define PARSE_CMD_H
+
+#include <cstdint>
+#include <vector>
+#include <string>
+#include "srsepc/hdr/mme/nas.h"
+
+typedef struct {
+    char messageFieldName[50];
+    int messageFieldValue;
+} MessageField;
+
+typedef struct {
+    char messageName[256];
+    MessageField messageFields[10];
+    int numberOfFields;
+} Message;
+
+Message parseMessage(const uint8_t *data, size_t length);
+void printMessage(const Message& message);
+void handleMessageCmd(Message message, srsepc::nas* myNasInstance);
+
+
+
+uint8_t *handleSecurityModeComplete(int nas_msg_container_IE);
+uint8_t *handleAuthenticationFailure(int emm_cause);
+uint8_t *handleAuthenticationResponse();
+uint8_t *handleAttachRequest(int emergency); 
+uint8_t *handleAttachComplete();
+uint8_t *handleUlNasTransport();
+uint8_t *handleGutiReallocationComplete();
+uint8_t *handleEmmStatus();
+uint8_t *handleDetachRequest();
+uint8_t *handleDetachAccept();
+uint8_t *handleSecurityModeReject(int emm_cause);
+
+uint8_t *handleAttachRequestGUTI();
+uint8_t *handleServiceRequest();
+uint8_t *handleTauRequest();
+uint8_t *handleAuthResponseRejected();
+uint8_t *handleTauComplete();
+uint8_t *handleEsmInfoResponse();
+uint8_t *handleIdentityResponse();
+
+uint8_t *handleNullAction();
+
+uint8_t* handleRRCSecurityModeComplete();
+uint8_t* handleRRCUECapInfo();
+uint8_t* handleRRCReconfComplete();
+
+
+
+#endif // PARSE_CMD_H
\ No newline at end of file
diff --git a/srsepc/hdr/mme/s1ap.h b/srsepc/hdr/mme/s1ap.h
old mode 100644
new mode 100755
index 4039953bf..806d39221
--- a/srsepc/hdr/mme/s1ap.h
+++ b/srsepc/hdr/mme/s1ap.h
@@ -52,14 +52,14 @@ const uint16_t S1MME_PORT = 36412;
 
 using s1ap_pdu_t = asn1::s1ap::s1ap_pdu_c;
 
-class s1ap : public s1ap_interface_nas, public s1ap_interface_gtpc, public s1ap_interface_mme
+class s1ap : public s1ap_interface_nas, public s1ap_interface_gtpc, public s1ap_interface_mme, public s1ap_interface_mme_statelearner // Fuzzing
 {
 public:
   static s1ap* get_instance();
   static void  cleanup();
 
   int  enb_listen();
-  int  init(const s1ap_args_t& s1ap_args);
+  int  init(const s1ap_args_t& s1ap_args, mme_statelearner_interface_s1ap *mme_statelearner_); // Fuzzing
   void stop();
 
   int get_s1_mme();
@@ -108,6 +108,9 @@ public:
   std::map<uint32_t, uint64_t>   m_tmsi_to_imsi;
   std::map<uint16_t, enb_ctx_t*> m_active_enbs;
 
+  mme_statelearner_interface_s1ap *m_mme_statelearner; // Fuzzing
+  bool send_query(uint8_t* msg, uint16_t len); // Fuzzing
+
   // Interfaces
   virtual bool send_initial_context_setup_request(uint64_t imsi, uint16_t erab_to_setup);
   virtual bool send_ue_context_release_command(uint32_t mme_ue_s1ap_id);
@@ -128,6 +131,9 @@ public:
 
   virtual bool expire_nas_timer(enum nas_timer_type type, uint64_t imsi);
 
+  virtual bool notify_response(uint8_t *msg, uint16_t len); //Fuzzing
+  virtual bool get_mme_statelearner_reset_state(); // Fuzzing
+
 private:
   s1ap();
   virtual ~s1ap();
diff --git a/srsepc/hdr/mme/s1ap_common.h b/srsepc/hdr/mme/s1ap_common.h
old mode 100644
new mode 100755
index 4c2897bba..142014785
--- a/srsepc/hdr/mme/s1ap_common.h
+++ b/srsepc/hdr/mme/s1ap_common.h
@@ -53,6 +53,8 @@ typedef struct {
   srsran::INTEGRITY_ALGORITHM_ID_ENUM integrity_algo;
   bool                                request_imeisv;
   uint16_t                            lac;
+  uint64_t                            ue_under_test_imsi; // For fuzzing
+  bool                                ue_state_fuzzing_enable; // For fuzzing
 } s1ap_args_t;
 
 typedef struct {
diff --git a/srsepc/hdr/mme/s1ap_ctx_mngmt_proc.h b/srsepc/hdr/mme/s1ap_ctx_mngmt_proc.h
old mode 100644
new mode 100755
diff --git a/srsepc/hdr/mme/s1ap_erab_mngmt_proc.h b/srsepc/hdr/mme/s1ap_erab_mngmt_proc.h
old mode 100644
new mode 100755
diff --git a/srsepc/hdr/mme/s1ap_mngmt_proc.h b/srsepc/hdr/mme/s1ap_mngmt_proc.h
old mode 100644
new mode 100755
diff --git a/srsepc/hdr/mme/s1ap_nas_transport.h b/srsepc/hdr/mme/s1ap_nas_transport.h
old mode 100644
new mode 100755
index ba8dfc5d8..9ac2113c5
--- a/srsepc/hdr/mme/s1ap_nas_transport.h
+++ b/srsepc/hdr/mme/s1ap_nas_transport.h
@@ -28,6 +28,10 @@
 #include "srsran/asn1/s1ap.h"
 #include "srsran/common/buffer_pool.h"
 
+// Fuzzing
+#include "srsepc/hdr/mme/mme_statelearner.h" 
+#include "srsepc/hdr/mme/parse_cmd.h"
+
 namespace srsepc {
 
 class s1ap_nas_transport
@@ -36,7 +40,7 @@ public:
   static s1ap_nas_transport* m_instance;
   static s1ap_nas_transport* get_instance();
   static void                cleanup();
-  void                       init();
+  void                       init(mme_statelearner_interface_s1ap *mme_statelearner_); // fuzzing
 
   bool handle_initial_ue_message(const asn1::s1ap::init_ue_msg_s& init_ue, struct sctp_sndrcvinfo* enb_sri);
   bool handle_uplink_nas_transport(const asn1::s1ap::ul_nas_transport_s& ul_xport, struct sctp_sndrcvinfo* enb_sri);
@@ -45,6 +49,9 @@ public:
                                    srsran::byte_buffer_t* nas_msg,
                                    struct sctp_sndrcvinfo enb_sri);
 
+  // fuzzing
+  bool handle_statelearner_query(Message msg_type, uint8_t event);
+
 private:
   s1ap_nas_transport();
   virtual ~s1ap_nas_transport();
@@ -52,6 +59,7 @@ private:
   srslog::basic_logger& m_logger = srslog::fetch_basic_logger("S1AP");
 
   s1ap* m_s1ap;
+  mme_statelearner_interface_s1ap *m_mme_statelearner; // fuzzing
 
   nas_init_t m_nas_init;
   nas_if_t   m_nas_if;
diff --git a/srsepc/hdr/mme/s1ap_paging.h b/srsepc/hdr/mme/s1ap_paging.h
old mode 100644
new mode 100755
diff --git a/srsepc/hdr/mme/string_help.h b/srsepc/hdr/mme/string_help.h
new file mode 100755
index 000000000..786caf438
--- /dev/null
+++ b/srsepc/hdr/mme/string_help.h
@@ -0,0 +1,22 @@
+//
+// Created by ishtiaq on 9/20/23.
+//
+
+#pragma once
+
+#include <ctype.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void reverse(char str[], int length);
+char* custom_itoa(int num, int base);
+int custom_atoi(const char* str);
+char *string_trim_whitespace(const char *str);
+int findFirst(char *str, char target);
+int countChar(const char *str, char target);
+char **splitStr(char *str, char target, int *splitCount, int trim);
+#ifdef __cplusplus
+}
+#endif
\ No newline at end of file
diff --git a/srsepc/hdr/spgw/gtpc.h b/srsepc/hdr/spgw/gtpc.h
old mode 100644
new mode 100755
diff --git a/srsepc/hdr/spgw/gtpu.h b/srsepc/hdr/spgw/gtpu.h
old mode 100644
new mode 100755
diff --git a/srsepc/hdr/spgw/spgw.h b/srsepc/hdr/spgw/spgw.h
old mode 100644
new mode 100755
diff --git a/srsepc/mbms.conf.example b/srsepc/mbms.conf.example
old mode 100644
new mode 100755
diff --git a/srsepc/src/CMakeLists.txt b/srsepc/src/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsepc/src/hss/CMakeLists.txt b/srsepc/src/hss/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsepc/src/hss/hss.cc b/srsepc/src/hss/hss.cc
old mode 100644
new mode 100755
diff --git a/srsepc/src/main.cc b/srsepc/src/main.cc
old mode 100644
new mode 100755
index 10dc8cf19..95c0fc59d
--- a/srsepc/src/main.cc
+++ b/srsepc/src/main.cc
@@ -34,6 +34,8 @@
 #include <boost/program_options.hpp>
 #include <iostream>
 
+#include "srsepc/hdr/mme/mme_statelearner.h" // Fuzzing
+
 using namespace std;
 using namespace srsepc;
 namespace bpo = boost::program_options;
@@ -98,6 +100,7 @@ void parse_args(all_args_t* args, int argc, char* argv[])
   string   hss_auth_algo;
   string   log_filename;
   string   lac;
+  string   ue_under_test_imsi; // For fuzzing
 
   // Command line only options
   bpo::options_description general("General options");
@@ -126,6 +129,8 @@ void parse_args(all_args_t* args, int argc, char* argv[])
     ("mme.paging_timer",    bpo::value<uint16_t>(&paging_timer)->default_value(2),           "Set paging timer value in seconds (T3413)")
     ("mme.request_imeisv",  bpo::value<bool>(&request_imeisv)->default_value(false),         "Enable IMEISV request in Security mode command")
     ("mme.lac",             bpo::value<string>(&lac)->default_value("0x01"),                 "Location Area Code")
+    ("mme.ue_under_test_imsi",  bpo::value<string>(&ue_under_test_imsi)->default_value("001011234567895"),  "Set UE_UNDER_TEST_IMSI for protocol state fuzzing") // fuzzing
+    ("mme.ue_state_fuzzing_enable", bpo::value<bool>(&args->mme_args.s1ap_args.ue_state_fuzzing_enable)->default_value(true),         "Enable UE_STATE_FUZZING") // fuzzing
     ("hss.db_file",         bpo::value<string>(&hss_db_file)->default_value("ue_db.csv"),    ".csv file that stores UE's keys")
     ("spgw.gtpu_bind_addr", bpo::value<string>(&spgw_bind_addr)->default_value("127.0.0.1"), "IP address of SP-GW for the S1-U connection")
     ("spgw.sgi_if_addr",    bpo::value<string>(&sgi_if_addr)->default_value("176.16.0.1"),   "IP address of TUN interface for the SGi connection")
@@ -243,6 +248,23 @@ void parse_args(all_args_t* args, int argc, char* argv[])
     cout << "Error parsing mme.mnc:" << mnc << " - must be a 2 or 3-digit string." << endl;
   }
 
+  // ======================================= Fuzzing =======================================
+  // Convert IMSI string to uint64_t
+  uint8_t tmp_imsi_arr[15];
+  strncpy((char *)tmp_imsi_arr, ue_under_test_imsi.c_str(), ue_under_test_imsi.length());
+  cout << "The IMSI of UE_Under_Test: \n";
+  //  for (int i=0; i<15; i++)
+  //  {
+  //    cout << "IMSI["<<i<<"] = " << tmp_imsi_arr[i] <<"\n";
+  //  }
+  uint64_t tmp_imsi = 0;
+  for(int i=0;i<=14;i++){
+    tmp_imsi  += (tmp_imsi_arr[i]-'0')*std::pow(10,14-i); //NOTE: need to subtract '0' because of char conversion during strncpy
+  }
+  args->mme_args.s1ap_args.ue_under_test_imsi = tmp_imsi;
+  cout<< "UUT IMSI = " << args->mme_args.s1ap_args.ue_under_test_imsi << "\n";
+  //=========================================================================================
+
   std::transform(encryption_algo.begin(), encryption_algo.end(), encryption_algo.begin(), ::tolower);
   if (encryption_algo == "eea0") {
     args->mme_args.s1ap_args.encryption_algo = srsran::CIPHERING_ALGORITHM_ID_EEA0;
diff --git a/srsepc/src/mbms-gw/CMakeLists.txt b/srsepc/src/mbms-gw/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsepc/src/mbms-gw/main.cc b/srsepc/src/mbms-gw/main.cc
old mode 100644
new mode 100755
diff --git a/srsepc/src/mbms-gw/mbms-gw.cc b/srsepc/src/mbms-gw/mbms-gw.cc
old mode 100644
new mode 100755
diff --git a/srsepc/src/mme/CMakeLists.txt b/srsepc/src/mme/CMakeLists.txt
old mode 100644
new mode 100755
index f5e884702..c1c9d68fd
--- a/srsepc/src/mme/CMakeLists.txt
+++ b/srsepc/src/mme/CMakeLists.txt
@@ -18,5 +18,5 @@
 # and at http://www.gnu.org/licenses/.
 #
 
-file(GLOB SOURCES "*.cc")
+file(GLOB SOURCES "*.cc" "*.c")
 add_library(srsepc_mme STATIC ${SOURCES})
\ No newline at end of file
diff --git a/srsepc/src/mme/mme.cc b/srsepc/src/mme/mme.cc
old mode 100644
new mode 100755
index 5ccedc2d4..da495c535
--- a/srsepc/src/mme/mme.cc
+++ b/srsepc/src/mme/mme.cc
@@ -65,7 +65,17 @@ int mme::init(mme_args_t* args)
 {
   /*Init S1AP*/
   m_s1ap = s1ap::get_instance();
-  if (m_s1ap->init(args->s1ap_args)) {
+
+  //=================================== Fuzzing ===========================
+  // Init the connection to statelearner
+  m_mme_statelearner = mme_statelearner::get_instance();
+  if(!m_mme_statelearner->init(m_s1ap)){
+    printf("Error initializing MME STATELEARNER\n");
+    exit(-1);
+  }
+  //======================================================================
+
+  if (m_s1ap->init(args->s1ap_args, m_mme_statelearner)) {
     m_s1ap_logger.error("Error initializing MME S1APP");
     exit(-1);
   }
@@ -77,6 +87,9 @@ int mme::init(mme_args_t* args)
     exit(-1);
   }
 
+  // fuzzing
+  m_mme_statelearner->start();
+
   /*Log successful initialization*/
   m_s1ap_logger.info("MME Initialized. MCC: 0x%x, MNC: 0x%x", args->s1ap_args.mcc, args->s1ap_args.mnc);
   srsran::console("MME Initialized. MCC: 0x%x, MNC: 0x%x\n", args->s1ap_args.mcc, args->s1ap_args.mnc);
diff --git a/srsepc/src/mme/mme_gtpc.cc b/srsepc/src/mme/mme_gtpc.cc
old mode 100644
new mode 100755
diff --git a/srsepc/src/mme/mme_statelearner.cc b/srsepc/src/mme/mme_statelearner.cc
new file mode 100755
index 000000000..a76b69842
--- /dev/null
+++ b/srsepc/src/mme/mme_statelearner.cc
@@ -0,0 +1,250 @@
+/*
+ *  Authors: Imtiaz Karim, Syed Rafiul Hussain, Abdullah Al Ishtiaq
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+#include "srsepc/hdr/mme/mme_statelearner.h"
+#include <iostream>
+#include <inttypes.h> // for printing uint64_t
+#include "srsepc/hdr/mme/s1ap.h"
+#include "srsepc/hdr/spgw/spgw.h"
+
+#include "srsepc/hdr/mme/parse_cmd.h"
+
+namespace srsepc {
+
+
+    mme_statelearner *mme_statelearner::m_instance = NULL;
+    pthread_mutex_t mme_statelearner_instance_mutex = PTHREAD_MUTEX_INITIALIZER;
+    pthread_mutex_t mme_statelearner_reset_state_mutex = PTHREAD_MUTEX_INITIALIZER;
+
+
+    mme_statelearner::mme_statelearner(): thread("MME_STATELEARNER"){
+        running = false;
+        statelearner_connected       = false;
+        mme_statelearner_reset_state = false;
+        return;
+    }
+
+    mme_statelearner::~mme_statelearner() {
+    }
+
+    mme_statelearner*
+    mme_statelearner::get_instance(void) {
+        pthread_mutex_lock(&mme_statelearner_instance_mutex);
+        if (NULL == m_instance) {
+            m_instance = new mme_statelearner();
+        }
+        pthread_mutex_unlock(&mme_statelearner_instance_mutex);
+        return (m_instance);
+    }
+
+
+    bool
+    mme_statelearner::init(s1ap_interface_mme_statelearner* s1ap_) {
+        m_s1ap = s1ap_;
+        printf("mme-statelearner initialized\n");
+        return true;
+    }
+
+
+    int
+    mme_statelearner::statelearner_listen() {
+        //This function sets up the TCP socket for MME to connect to StateLearner
+        int sock_fd, err;
+        struct sockaddr_in mmelearnlib_server_addr;
+
+        printf("mme-statelearner Server Initializing\n");
+        // socket create and verification
+        sock_fd = socket(AF_INET, SOCK_STREAM, 0);
+        if (sock_fd == -1) {
+            printf("S1-statelearner erver socket creation failed...\n");
+            return -1;
+        }
+
+        bzero(&mmelearnlib_server_addr, sizeof(mmelearnlib_server_addr));
+        // assign IP, PORT
+        mmelearnlib_server_addr.sin_family = AF_INET;
+        mmelearnlib_server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
+        inet_pton(AF_INET, "127.0.0.1", &(mmelearnlib_server_addr.sin_addr));
+        mmelearnlib_server_addr.sin_port = htons(60000);
+        err = bind(sock_fd, (struct sockaddr *) &mmelearnlib_server_addr, sizeof(mmelearnlib_server_addr));
+        if (err != 0) {
+            close(sock_fd);
+            printf("Error binding TCP socket for s1ap-learnlib server\n");
+            return -1;
+        }
+
+        //Listen for connections
+        err = listen(sock_fd, SOMAXCONN);
+        if (err != 0) {
+            close(sock_fd);
+            printf("Error in s1ap-learnlib TCP socket listen\n");
+            return -1;
+        }
+
+        printf("Listen done ....\n");
+        return sock_fd;
+    }
+
+    void mme_statelearner::run_thread() {
+
+        printf("The mme_statelearner thread has been started...\n");
+
+        int sock_fd, err;
+        struct sockaddr_in mmelearnlib_server_addr;
+
+
+        // socket create and verification
+        sock_fd = socket(AF_INET, SOCK_STREAM, 0);
+        if (sock_fd == -1) {
+            printf("S1-statelearner erver socket creation failed...\n");
+            return ;
+        }
+
+        bzero(&mmelearnlib_server_addr, sizeof(mmelearnlib_server_addr));
+        // assign IP, PORT
+        mmelearnlib_server_addr.sin_family = AF_INET;
+        mmelearnlib_server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
+        inet_pton(AF_INET, "127.0.0.1", &(mmelearnlib_server_addr.sin_addr));
+        mmelearnlib_server_addr.sin_port = htons(60000);
+        err = bind(sock_fd, (struct sockaddr *) &mmelearnlib_server_addr, sizeof(mmelearnlib_server_addr));
+        if (err != 0) {
+            close(sock_fd);
+            printf("Error binding TCP socket for s1ap-learnlib server\n");
+            return;
+        }
+        //Listen for connections
+        err = listen(sock_fd, SOMAXCONN);
+        if (err != 0) {
+            close(sock_fd);
+            printf("Error in s1ap-learnlib TCP socket listen\n");
+            return;
+        }
+
+        srsran::unique_byte_buffer_t pdu_buffer = srsran::make_byte_buffer("mme_statelearner::run_thread");
+        if (pdu_buffer == nullptr) {
+            printf("Couldn't allocate PDU in %s().", __FUNCTION__);
+            return;
+        }
+        srsran::byte_buffer_t* pdu = pdu_buffer.get();
+
+        uint32_t sz = SRSRAN_MAX_BUFFER_SIZE_BYTES - SRSRAN_BUFFER_HEADER_OFFSET;
+
+        m_mme_statelearner_sock = accept(sock_fd, (struct sockaddr *)NULL, (socklen_t *)NULL);
+        if(m_mme_statelearner_sock<0){
+            perror("Client accept failed\n");
+            return;
+        }
+        printf("Statelearner is connected\n");
+        running = true;
+        int rd_sz;
+
+        // Connect to MME
+        // statelearner rx loop
+        bool ret;
+        while (running) {
+            pdu->clear();
+            rd_sz = recv(m_mme_statelearner_sock, pdu->msg, sz, 0);
+
+            if(rd_sz == -1)
+            {
+            }
+            if(rd_sz == 0){
+                printf("Client Disconnected. Need to run SRSEPC again.\n");
+                return;
+            }
+            else{
+                pdu->N_bytes = rd_sz;
+                pdu->msg[pdu->N_bytes] = '\0';
+
+                if(memcmp(pdu->msg, "Hello\n", pdu->N_bytes) == 0) {
+                    printf("### Received the expected HELLO message ###\n");
+                    if (send(m_mme_statelearner_sock, "ACK\n", 5, 0) < 0)
+                    {
+                        perror("Error in Send to Statelearner");
+                        exit(7);
+                    }
+                }
+                else{
+                    
+                    ret = m_s1ap->send_query(pdu->msg, pdu->N_bytes);
+
+                    if (ret == false) // FIXME: handle no return
+                    {
+                        printf("Sending NULL_ACTION to statelearner!");
+                        uint8_t response[13] = "null_action\n";
+                        uint8_t size = 13;
+                        //notify_response(response, size);
+                        uint8_t* messageStr = handleNullAction();
+                        uint16_t len = static_cast<uint16_t>(strlen((char*)messageStr));
+                        notify_response(messageStr, len);
+                        delete[] messageStr;
+                    }
+                }
+
+            }
+        }
+    }
+
+    void
+    mme_statelearner::stop() {
+
+        if (m_mme_statelearner_sock != -1){
+            close(m_mme_statelearner_sock);
+        }
+
+        return;
+
+    }
+
+    void
+    mme_statelearner::cleanup(void) {
+        pthread_mutex_lock(&mme_statelearner_instance_mutex);
+        if (NULL != m_instance) {
+            delete m_instance;
+            m_instance = NULL;
+        }
+        pthread_mutex_unlock(&mme_statelearner_instance_mutex);
+    }
+
+    bool mme_statelearner::notify_response(uint8_t *msg, uint16_t len) {
+        printf("Sending response to statelearner %s\n",msg);
+        
+        if (send(m_mme_statelearner_sock, msg, len, 0) < 0)
+        {
+            perror("Error in Send to Statelearner");
+            exit(7);
+        }
+        return true;
+    }
+
+
+    void mme_statelearner::set_mme_statelearner_reset_state() {
+        pthread_mutex_lock(&mme_statelearner_reset_state_mutex);
+        mme_statelearner_reset_state = true;
+        pthread_mutex_unlock(&mme_statelearner_reset_state_mutex);
+    }
+
+    void mme_statelearner::reset_mme_statelearner_reset_state() {
+        pthread_mutex_lock(&mme_statelearner_reset_state_mutex);
+        mme_statelearner_reset_state = false;
+        pthread_mutex_unlock(&mme_statelearner_reset_state_mutex);
+    }
+
+    bool mme_statelearner::get_mme_statelearner_reset_state() {
+        return mme_statelearner_reset_state;
+    }
+
+}
\ No newline at end of file
diff --git a/srsepc/src/mme/nas.cc b/srsepc/src/mme/nas.cc
old mode 100644
new mode 100755
index 7e9834d06..217a11153
--- a/srsepc/src/mme/nas.cc
+++ b/srsepc/src/mme/nas.cc
@@ -29,8 +29,12 @@
 #include <sys/timerfd.h>
 #include <time.h>
 
-namespace srsepc {
+//fuzzing
+#include "srsepc/hdr/mme/parse_cmd.h"
+#include "srsran/common/fuzzing.h"
 
+namespace srsepc {
+uint32 msg_type_global = FUZZING_MSG_TYPE_EOL;
 nas::nas(const nas_init_t& args, const nas_if_t& itf) :
   m_gtpc(itf.gtpc),
   m_s1ap(itf.s1ap),
@@ -47,13 +51,46 @@ nas::nas(const nas_init_t& args, const nas_if_t& itf) :
   m_short_net_name(args.short_net_name),
   m_t3413(args.paging_timer),
   m_request_imeisv(args.request_imeisv),
-  m_lac(args.lac)
+  m_lac(args.lac),
+  // fuzzing
+  m_ue_under_test_imsi(args.ue_under_test_imsi),
+  m_enable_ue_state_fuzzing(args.enable_ue_state_fuzzing) 
 {
   m_sec_ctx.integ_algo  = args.integ_algo;
   m_sec_ctx.cipher_algo = args.cipher_algo;
   m_logger.debug("NAS Context Initialized. MCC: 0x%x, MNC 0x%x", m_mcc, m_mnc);
 }
 
+// helper functions and variables for fuzzing
+srsran::unique_byte_buffer_t identity_replay_buffer;
+srsran::unique_byte_buffer_t auth_replay_buffer;
+srsran::unique_byte_buffer_t smd_replay_buffer;
+srsran::unique_byte_buffer_t smd_ns_replay_buffer;
+srsran::unique_byte_buffer_t guti_replay_buffer;
+srsran::unique_byte_buffer_t dl_replay_buffer;
+srsran::unique_byte_buffer_t attach_accept_replay_buffer;
+srsran::unique_byte_buffer_t guti_reallocation_replay_buffer;
+bool sm_complete_flag = false;
+
+void key_set(uint8_t* key)
+{
+  printf("setting!!\n");
+  uint8_t copy[4] = {0, 0, 0, 0};
+  key[0] = 0;
+  key[1] = 0;
+  key[2] = 0;
+  key[3] = 0;
+}
+
+bool check(uint8_t* key)
+{
+  if (key[0] == 0 && key[1] == 0 && key[2] == 0) {
+    printf(" caught!!\n ");
+    return true;
+  }
+  return false;
+}
+
 void nas::reset()
 {
   m_emm_ctx = {};
@@ -86,6 +123,18 @@ bool nas::handle_attach_request(uint32_t                enb_ue_s1ap_id,
   LIBLTE_MME_PDN_CONNECTIVITY_REQUEST_MSG_STRUCT pdn_con_req = {};
   auto&                                          nas_logger  = srslog::fetch_basic_logger("NAS");
 
+
+  // reset replay buffers
+  identity_replay_buffer.reset();
+  auth_replay_buffer.reset();
+  smd_replay_buffer.reset();
+  smd_ns_replay_buffer.reset();
+  guti_replay_buffer.reset();
+  dl_replay_buffer.reset();
+  attach_accept_replay_buffer.reset();
+  guti_reallocation_replay_buffer.reset();
+  sm_complete_flag = false;
+
   // Interfaces
   s1ap_interface_nas* s1ap = itf.s1ap;
   hss_interface_nas*  hss  = itf.hss;
@@ -181,8 +230,25 @@ bool nas::handle_attach_request(uint32_t                enb_ue_s1ap_id,
     // Get attach type from attach request
     if (attach_req.eps_mobile_id.type_of_id == LIBLTE_MME_EPS_MOBILE_ID_TYPE_IMSI) {
       nas::handle_imsi_attach_request_unknown_ue(enb_ue_s1ap_id, enb_sri, attach_req, pdn_con_req, args, itf);
+
+      if (s1ap->get_mme_statelearner_reset_state()==false && args.enable_ue_state_fuzzing== true) {
+        srsran::console("Response: attach_request 5\n");
+        uint8_t* messageStr = handleAttachRequest(0);
+        uint16_t len = static_cast<uint16_t>(strlen((char*)messageStr));
+        s1ap->notify_response(messageStr, len);
+        delete[] messageStr;
+        return true;
+      }
     } else if (attach_req.eps_mobile_id.type_of_id == LIBLTE_MME_EPS_MOBILE_ID_TYPE_GUTI) {
       nas::handle_guti_attach_request_unknown_ue(enb_ue_s1ap_id, enb_sri, attach_req, pdn_con_req, args, itf);
+
+      if (s1ap->get_mme_statelearner_reset_state()==false && args.enable_ue_state_fuzzing== true) {
+        srsran::console("Response: attach_request_guti\n");
+        uint8_t* messageStr = handleAttachRequestGUTI();
+        uint16_t len = static_cast<uint16_t>(strlen((char*)messageStr));
+        s1ap->notify_response(messageStr, len);
+        delete[] messageStr;
+      } 
     } else {
       return false;
     }
@@ -192,9 +258,28 @@ bool nas::handle_attach_request(uint32_t                enb_ue_s1ap_id,
     if (attach_req.eps_mobile_id.type_of_id == LIBLTE_MME_EPS_MOBILE_ID_TYPE_IMSI) {
       nas::handle_imsi_attach_request_known_ue(
           nas_ctx, enb_ue_s1ap_id, enb_sri, attach_req, pdn_con_req, nas_rx, args, itf);
+
+      if (s1ap->get_mme_statelearner_reset_state()==false && args.enable_ue_state_fuzzing== true) {
+        srsran::console("Response: attach_request\n");
+        key_set(&nas_ctx->m_sec_ctx.k_nas_enc[16]);
+        uint8_t* messageStr = handleAttachRequest(0);
+        uint16_t len = static_cast<uint16_t>(strlen((char*)messageStr));
+        s1ap->notify_response(messageStr, len);
+        delete[] messageStr;
+      }
     } else if (attach_req.eps_mobile_id.type_of_id == LIBLTE_MME_EPS_MOBILE_ID_TYPE_GUTI) {
       nas::handle_guti_attach_request_known_ue(
           nas_ctx, enb_ue_s1ap_id, enb_sri, attach_req, pdn_con_req, nas_rx, args, itf);
+
+      if (s1ap->get_mme_statelearner_reset_state()==false && args.enable_ue_state_fuzzing== true) {
+        srsran::console("Response: attach_request_guti\n");
+        printf("isuueeeeeeeeeeeeeeee is here\n");
+        key_set(&nas_ctx->m_sec_ctx.k_nas_enc[16]);
+        uint8_t* messageStr = handleAttachRequestGUTI();
+        uint16_t len = static_cast<uint16_t>(strlen((char*)messageStr));
+        s1ap->notify_response(messageStr, len);
+        delete[] messageStr;
+      }
     } else {
       return false;
     }
@@ -213,6 +298,16 @@ bool nas::handle_imsi_attach_request_unknown_ue(uint32_t
   srsran::unique_byte_buffer_t nas_tx;
   auto&                        nas_logger = srslog::fetch_basic_logger("NAS");
 
+  // reset replay buffers
+  identity_replay_buffer.reset();
+  auth_replay_buffer.reset();
+  smd_replay_buffer.reset();
+  smd_ns_replay_buffer.reset();
+  guti_replay_buffer.reset();
+  dl_replay_buffer.reset();
+  attach_accept_replay_buffer.reset();
+  guti_reallocation_replay_buffer.reset();
+
   // Interfaces
   s1ap_interface_nas* s1ap = itf.s1ap;
   hss_interface_nas*  hss  = itf.hss;
@@ -265,15 +360,17 @@ bool nas::handle_imsi_attach_request_unknown_ue(uint32_t
   // Save attach request type
   nas_ctx->m_emm_ctx.attach_type = attach_req.eps_attach_type;
 
-  // Get Authentication Vectors from HSS
-  if (!hss->gen_auth_info_answer(nas_ctx->m_emm_ctx.imsi,
-                                 nas_ctx->m_sec_ctx.k_asme,
-                                 nas_ctx->m_sec_ctx.autn,
-                                 nas_ctx->m_sec_ctx.rand,
-                                 nas_ctx->m_sec_ctx.xres)) {
-    srsran::console("User not found. IMSI %015" PRIu64 "\n", nas_ctx->m_emm_ctx.imsi);
-    nas_logger.info("User not found. IMSI %015" PRIu64 "", nas_ctx->m_emm_ctx.imsi);
-    return false;
+  if (args.enable_ue_state_fuzzing == false) {
+    // Get Authentication Vectors from HSS
+    if (!hss->gen_auth_info_answer(nas_ctx->m_emm_ctx.imsi,
+                                  nas_ctx->m_sec_ctx.k_asme,
+                                  nas_ctx->m_sec_ctx.autn,
+                                  nas_ctx->m_sec_ctx.rand,
+                                  nas_ctx->m_sec_ctx.xres)) {
+      srsran::console("User not found. IMSI %015" PRIu64 "\n", nas_ctx->m_emm_ctx.imsi);
+      nas_logger.info("User not found. IMSI %015" PRIu64 "", nas_ctx->m_emm_ctx.imsi);
+      return false;
+    }
   }
 
   // Allocate eKSI for this authentication vector
@@ -285,20 +382,22 @@ bool nas::handle_imsi_attach_request_unknown_ue(uint32_t
   s1ap->add_nas_ctx_to_mme_ue_s1ap_id_map(nas_ctx);
   s1ap->add_ue_to_enb_set(enb_sri->sinfo_assoc_id, nas_ctx->m_ecm_ctx.mme_ue_s1ap_id);
 
-  // Pack NAS Authentication Request in Downlink NAS Transport msg
-  nas_tx = srsran::make_byte_buffer();
-  if (nas_tx == nullptr) {
-    nas_logger.error("Couldn't allocate PDU in %s().", __FUNCTION__);
-    return false;
-  }
-  nas_ctx->pack_authentication_request(nas_tx.get());
+  if (args.enable_ue_state_fuzzing == false) {
+    // Pack NAS Authentication Request in Downlink NAS Transport msg
+    nas_tx = srsran::make_byte_buffer();
+    if (nas_tx == nullptr) {
+      nas_logger.error("Couldn't allocate PDU in %s().", __FUNCTION__);
+      return false;
+    }
+    nas_ctx->pack_authentication_request(nas_tx.get());
 
-  // Send reply to eNB
-  s1ap->send_downlink_nas_transport(
-      nas_ctx->m_ecm_ctx.enb_ue_s1ap_id, nas_ctx->m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), nas_ctx->m_ecm_ctx.enb_sri);
+    // Send reply to eNB
+    s1ap->send_downlink_nas_transport(
+        nas_ctx->m_ecm_ctx.enb_ue_s1ap_id, nas_ctx->m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), nas_ctx->m_ecm_ctx.enb_sri);
 
-  nas_logger.info("Downlink NAS: Sending Authentication Request");
-  srsran::console("Downlink NAS: Sending Authentication Request\n");
+    nas_logger.info("Downlink NAS: Sending Authentication Request");
+    srsran::console("Downlink NAS: Sending Authentication Request\n");
+  }
   return true;
 }
 
@@ -314,6 +413,16 @@ bool nas::handle_imsi_attach_request_known_ue(nas*
   bool  err;
   auto& nas_logger = srslog::fetch_basic_logger("NAS");
 
+  // reset replay buffers
+  identity_replay_buffer.reset();
+  auth_replay_buffer.reset();
+  smd_replay_buffer.reset();
+  smd_ns_replay_buffer.reset();
+  guti_replay_buffer.reset();
+  dl_replay_buffer.reset();
+  attach_accept_replay_buffer.reset();
+  guti_reallocation_replay_buffer.reset();
+
   // Interfaces
   s1ap_interface_nas* s1ap = itf.s1ap;
   hss_interface_nas*  hss  = itf.hss;
@@ -345,6 +454,16 @@ bool nas::handle_guti_attach_request_unknown_ue(uint32_t
   nas*                         nas_ctx;
   srsran::unique_byte_buffer_t nas_tx;
 
+  // reset replay buffers
+  identity_replay_buffer.reset();
+  auth_replay_buffer.reset();
+  smd_replay_buffer.reset();
+  smd_ns_replay_buffer.reset();
+  guti_replay_buffer.reset();
+  dl_replay_buffer.reset();
+  attach_accept_replay_buffer.reset();
+  guti_reallocation_replay_buffer.reset();
+
   // Interfaces
   s1ap_interface_nas* s1ap = itf.s1ap;
   hss_interface_nas*  hss  = itf.hss;
@@ -357,6 +476,9 @@ bool nas::handle_guti_attach_request_unknown_ue(uint32_t
   // The IMSI will be set when the identity response is received
   // Set EMM ctx
   nas_ctx->m_emm_ctx.imsi  = 0;
+  if (args.enable_ue_state_fuzzing == true)
+    nas_ctx->m_emm_ctx.imsi = args.ue_under_test_imsi;
+
   nas_ctx->m_emm_ctx.state = EMM_STATE_DEREGISTERED;
 
   // Save UE network capabilities
@@ -394,19 +516,26 @@ bool nas::handle_guti_attach_request_unknown_ue(uint32_t
     nas_ctx->m_esm_ctx[i].erab_id = i;
   }
 
+  // Fuzzing
+  if (args.enable_ue_state_fuzzing == true) { 
+    s1ap->add_nas_ctx_to_imsi_map(nas_ctx);   
+  }
+
   // Store temporary ue context
   s1ap->add_nas_ctx_to_mme_ue_s1ap_id_map(nas_ctx);
   s1ap->add_ue_to_enb_set(enb_sri->sinfo_assoc_id, nas_ctx->m_ecm_ctx.mme_ue_s1ap_id);
 
-  // Send Identity Request
-  nas_tx = srsran::make_byte_buffer();
-  if (nas_tx == nullptr) {
-    srslog::fetch_basic_logger("NAS").error("Couldn't allocate PDU in %s().", __FUNCTION__);
-    return false;
+  if (args.enable_ue_state_fuzzing == false) {
+    // Send Identity Request
+    nas_tx = srsran::make_byte_buffer();
+    if (nas_tx == nullptr) {
+      srslog::fetch_basic_logger("NAS").error("Couldn't allocate PDU in %s().", __FUNCTION__);
+      return false;
+    }
+    nas_ctx->pack_identity_request(nas_tx.get());
+    s1ap->send_downlink_nas_transport(
+        nas_ctx->m_ecm_ctx.enb_ue_s1ap_id, nas_ctx->m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), nas_ctx->m_ecm_ctx.enb_sri);
   }
-  nas_ctx->pack_identity_request(nas_tx.get());
-  s1ap->send_downlink_nas_transport(
-      nas_ctx->m_ecm_ctx.enb_ue_s1ap_id, nas_ctx->m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), nas_ctx->m_ecm_ctx.enb_sri);
 
   return true;
 }
@@ -428,6 +557,16 @@ bool nas::handle_guti_attach_request_known_ue(nas*
   ecm_ctx_t* ecm_ctx = &nas_ctx->m_ecm_ctx;
   sec_ctx_t* sec_ctx = &nas_ctx->m_sec_ctx;
 
+  // reset replay buffers
+  identity_replay_buffer.reset();
+  auth_replay_buffer.reset();
+  smd_replay_buffer.reset();
+  smd_ns_replay_buffer.reset();
+  guti_replay_buffer.reset();
+  dl_replay_buffer.reset();
+  attach_accept_replay_buffer.reset();
+  guti_reallocation_replay_buffer.reset();
+
   // Interfaces
   s1ap_interface_nas* s1ap = itf.s1ap;
   hss_interface_nas*  hss  = itf.hss;
@@ -478,24 +617,26 @@ bool nas::handle_guti_attach_request_known_ue(nas*
     srsran::console("Generating KeNB with UL NAS COUNT: %d\n", sec_ctx->ul_nas_count);
     nas_logger.info(sec_ctx->k_enb, 32, "Key eNodeB (k_enb)");
 
-    // Send reply
-    nas_tx = srsran::make_byte_buffer();
-    if (nas_tx == nullptr) {
-      nas_logger.error("Couldn't allocate PDU in %s().", __FUNCTION__);
-      return false;
-    }
-    if (ecm_ctx->eit) {
-      srsran::console("Secure ESM information transfer requested.\n");
-      nas_logger.info("Secure ESM information transfer requested.");
-      nas_ctx->pack_esm_information_request(nas_tx.get());
-      s1ap->send_downlink_nas_transport(ecm_ctx->enb_ue_s1ap_id, ecm_ctx->mme_ue_s1ap_id, nas_tx.get(), *enb_sri);
-    } else {
-      // Get subscriber info from HSS
-      uint8_t default_bearer = 5;
-      hss->gen_update_loc_answer(emm_ctx->imsi, &nas_ctx->m_esm_ctx[default_bearer].qci);
-      nas_logger.debug("Getting subscription information -- QCI %d", nas_ctx->m_esm_ctx[default_bearer].qci);
-      srsran::console("Getting subscription information -- QCI %d\n", nas_ctx->m_esm_ctx[default_bearer].qci);
-      gtpc->send_create_session_request(emm_ctx->imsi);
+    if (args.enable_ue_state_fuzzing == false) {
+      // Send reply
+      nas_tx = srsran::make_byte_buffer();
+      if (nas_tx == nullptr) {
+        nas_logger.error("Couldn't allocate PDU in %s().", __FUNCTION__);
+        return false;
+      }
+      if (ecm_ctx->eit) {
+        srsran::console("Secure ESM information transfer requested.\n");
+        nas_logger.info("Secure ESM information transfer requested.");
+        nas_ctx->pack_esm_information_request(nas_tx.get());
+        s1ap->send_downlink_nas_transport(ecm_ctx->enb_ue_s1ap_id, ecm_ctx->mme_ue_s1ap_id, nas_tx.get(), *enb_sri);
+      } else {
+        // Get subscriber info from HSS
+        uint8_t default_bearer = 5;
+        hss->gen_update_loc_answer(emm_ctx->imsi, &nas_ctx->m_esm_ctx[default_bearer].qci);
+        nas_logger.debug("Getting subscription information -- QCI %d", nas_ctx->m_esm_ctx[default_bearer].qci);
+        srsran::console("Getting subscription information -- QCI %d\n", nas_ctx->m_esm_ctx[default_bearer].qci);
+        gtpc->send_create_session_request(emm_ctx->imsi);
+      }
     }
     sec_ctx->ul_nas_count++;
     return true;
@@ -517,9 +658,11 @@ bool nas::handle_guti_attach_request_known_ue(nas*
     // Create new MME UE S1AP Identity
     uint32_t new_mme_ue_s1ap_id = s1ap->get_next_mme_ue_s1ap_id();
 
-    // Make sure context from previous NAS connections is not present
-    if (ecm_ctx->mme_ue_s1ap_id != 0) {
-      s1ap->release_ue_ecm_ctx(ecm_ctx->mme_ue_s1ap_id);
+    if (args.enable_ue_state_fuzzing == false) {
+      // Make sure context from previous NAS connections is not present
+      if (ecm_ctx->mme_ue_s1ap_id != 0) {
+        s1ap->release_ue_ecm_ctx(ecm_ctx->mme_ue_s1ap_id);
+      }
     }
     ecm_ctx->mme_ue_s1ap_id = s1ap->get_next_mme_ue_s1ap_id();
 
@@ -543,30 +686,40 @@ bool nas::handle_guti_attach_request_known_ue(nas*
     s1ap->add_nas_ctx_to_mme_ue_s1ap_id_map(nas_ctx);
     s1ap->add_ue_to_enb_set(enb_sri->sinfo_assoc_id, ecm_ctx->mme_ue_s1ap_id);
 
-    // NAS integrity failed. Re-start authentication process.
-    srsran::console("GUTI Attach request NAS integrity failed.\n");
-    srsran::console("RE-starting authentication procedure.\n");
-
-    // Get Authentication Vectors from HSS
-    if (!hss->gen_auth_info_answer(emm_ctx->imsi, sec_ctx->k_asme, sec_ctx->autn, sec_ctx->rand, sec_ctx->xres)) {
-      srsran::console("User not found. IMSI %015" PRIu64 "\n", emm_ctx->imsi);
-      nas_logger.info("User not found. IMSI %015" PRIu64 "", emm_ctx->imsi);
-      return false;
+    if (args.enable_ue_state_fuzzing == true) {
+      // Re-generate K_eNB
+      srsran::security_generate_k_enb(sec_ctx->k_asme, sec_ctx->ul_nas_count, sec_ctx->k_enb);
+      nas_logger.info("Generating KeNB with UL NAS COUNT: %d\n", sec_ctx->ul_nas_count);
+      srsran::console("Generating KeNB with UL NAS COUNT: %d\n", sec_ctx->ul_nas_count);
+      nas_logger.info(sec_ctx->k_enb, 32, "Key eNodeB (k_enb)\n");
     }
 
-    // Restarting security context. Reseting eKSI to 0.
-    sec_ctx->eksi = 0;
-    nas_tx        = srsran::make_byte_buffer();
-    if (nas_tx == nullptr) {
-      nas_logger.error("Couldn't allocate PDU in %s().", __FUNCTION__);
-      return false;
-    }
-    nas_ctx->pack_authentication_request(nas_tx.get());
+    if (args.enable_ue_state_fuzzing == false) {
+      // NAS integrity failed. Re-start authentication process.
+      srsran::console("GUTI Attach request NAS integrity failed.\n");
+      srsran::console("RE-starting authentication procedure.\n");
 
-    // Send reply to eNB
-    s1ap->send_downlink_nas_transport(ecm_ctx->enb_ue_s1ap_id, ecm_ctx->mme_ue_s1ap_id, nas_tx.get(), *enb_sri);
-    nas_logger.info("Downlink NAS: Sent Authentication Request");
-    srsran::console("Downlink NAS: Sent Authentication Request\n");
+      // Get Authentication Vectors from HSS
+      if (!hss->gen_auth_info_answer(emm_ctx->imsi, sec_ctx->k_asme, sec_ctx->autn, sec_ctx->rand, sec_ctx->xres)) {
+        srsran::console("User not found. IMSI %015" PRIu64 "\n", emm_ctx->imsi);
+        nas_logger.info("User not found. IMSI %015" PRIu64 "", emm_ctx->imsi);
+        return false;
+      }
+
+      // Restarting security context. Reseting eKSI to 0.
+      sec_ctx->eksi = 0;
+      nas_tx        = srsran::make_byte_buffer();
+      if (nas_tx == nullptr) {
+        nas_logger.error("Couldn't allocate PDU in %s().", __FUNCTION__);
+        return false;
+      }
+      nas_ctx->pack_authentication_request(nas_tx.get());
+
+      // Send reply to eNB
+      s1ap->send_downlink_nas_transport(ecm_ctx->enb_ue_s1ap_id, ecm_ctx->mme_ue_s1ap_id, nas_tx.get(), *enb_sri);
+      nas_logger.info("Downlink NAS: Sent Authentication Request");
+      srsran::console("Downlink NAS: Sent Authentication Request\n");
+    }
     return true;
   }
 }
@@ -602,6 +755,11 @@ bool nas::handle_service_request(uint32_t                m_tmsi,
   }
 
   uint64_t imsi = s1ap->find_imsi_from_m_tmsi(m_tmsi);
+
+  if (imsi == 0 && args.enable_ue_state_fuzzing == true) {
+    imsi = args.ue_under_test_imsi;
+  }
+
   if (imsi == 0) {
     srsran::console("Could not find IMSI from M-TMSI. M-TMSI 0x%x\n", m_tmsi);
     nas_logger.error("Could not find IMSI from M-TMSI. M-TMSI 0x%x", m_tmsi);
@@ -609,14 +767,24 @@ bool nas::handle_service_request(uint32_t                m_tmsi,
     nas_tmp.m_ecm_ctx.enb_ue_s1ap_id = enb_ue_s1ap_id;
     nas_tmp.m_ecm_ctx.mme_ue_s1ap_id = s1ap->get_next_mme_ue_s1ap_id();
 
-    srsran::unique_byte_buffer_t nas_tx = srsran::make_byte_buffer();
-    if (nas_tx == nullptr) {
-      nas_logger.error("Couldn't allocate PDU in %s().", __FUNCTION__);
-      return false;
+    if (args.enable_ue_state_fuzzing == false) {
+      srsran::unique_byte_buffer_t nas_tx = srsran::make_byte_buffer();
+      if (nas_tx == nullptr) {
+        nas_logger.error("Couldn't allocate PDU in %s().", __FUNCTION__);
+        return false;
+      }
+      nas_tmp.pack_service_reject(nas_tx.get(), LIBLTE_MME_EMM_CAUSE_IMPLICITLY_DETACHED);
+      s1ap->send_downlink_nas_transport(enb_ue_s1ap_id, nas_tmp.m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), *enb_sri);
     }
-    nas_tmp.pack_service_reject(nas_tx.get(), LIBLTE_MME_EMM_CAUSE_IMPLICITLY_DETACHED);
-    s1ap->send_downlink_nas_transport(enb_ue_s1ap_id, nas_tmp.m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), *enb_sri);
-    return true;
+
+    if (s1ap->get_mme_statelearner_reset_state() == false && args.enable_ue_state_fuzzing == true) {
+      srsran::console("Response: service_request 1\n");
+      uint8_t* messageStr = handleServiceRequest();
+      uint16_t len = static_cast<uint16_t>(strlen((char*)messageStr));
+      s1ap->notify_response(messageStr, len);
+      delete[] messageStr;
+    } 
+      return true;
   }
 
   nas* nas_ctx = s1ap->find_nas_ctx_from_imsi(imsi);
@@ -627,13 +795,22 @@ bool nas::handle_service_request(uint32_t                m_tmsi,
     nas_tmp.m_ecm_ctx.enb_ue_s1ap_id = enb_ue_s1ap_id;
     nas_tmp.m_ecm_ctx.mme_ue_s1ap_id = s1ap->get_next_mme_ue_s1ap_id();
 
-    srsran::unique_byte_buffer_t nas_tx = srsran::make_byte_buffer();
-    if (nas_tx == nullptr) {
-      nas_logger.error("Couldn't allocate PDU in %s().", __FUNCTION__);
-      return false;
+    if (args.enable_ue_state_fuzzing == false) {
+      srsran::unique_byte_buffer_t nas_tx = srsran::make_byte_buffer();
+      if (nas_tx == nullptr) {
+        nas_logger.error("Couldn't allocate PDU in %s().", __FUNCTION__);
+        return false;
+      }
+      nas_tmp.pack_service_reject(nas_tx.get(), LIBLTE_MME_EMM_CAUSE_IMPLICITLY_DETACHED);
+      s1ap->send_downlink_nas_transport(enb_ue_s1ap_id, nas_tmp.m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), *enb_sri);
     }
-    nas_tmp.pack_service_reject(nas_tx.get(), LIBLTE_MME_EMM_CAUSE_IMPLICITLY_DETACHED);
-    s1ap->send_downlink_nas_transport(enb_ue_s1ap_id, nas_tmp.m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), *enb_sri);
+    if (s1ap->get_mme_statelearner_reset_state() == false && args.enable_ue_state_fuzzing == true) {
+      srsran::console("Response: service_request 2\n");
+      uint8_t* messageStr = handleServiceRequest();
+      uint16_t len = static_cast<uint16_t>(strlen((char*)messageStr));
+      s1ap->notify_response(messageStr, len);
+      delete[] messageStr;
+    } 
     return true;
   }
   emm_ctx_t* emm_ctx = &nas_ctx->m_emm_ctx;
@@ -711,17 +888,28 @@ bool nas::handle_service_request(uint32_t                m_tmsi,
     ecm_ctx->mme_ue_s1ap_id = s1ap->get_next_mme_ue_s1ap_id();
     s1ap->add_nas_ctx_to_mme_ue_s1ap_id_map(nas_ctx);
     s1ap->add_ue_to_enb_set(enb_sri->sinfo_assoc_id, nas_ctx->m_ecm_ctx.mme_ue_s1ap_id);
-    srsran::unique_byte_buffer_t nas_tx = srsran::make_byte_buffer();
-    if (nas_tx == nullptr) {
-      nas_logger.error("Couldn't allocate PDU in %s().", __FUNCTION__);
-      return false;
+
+    if (args.enable_ue_state_fuzzing == false) {
+      srsran::unique_byte_buffer_t nas_tx = srsran::make_byte_buffer();
+      if (nas_tx == nullptr) {
+        nas_logger.error("Couldn't allocate PDU in %s().", __FUNCTION__);
+        return false;
+      }
+      nas_ctx->pack_service_reject(nas_tx.get(), LIBLTE_MME_EMM_CAUSE_UE_IDENTITY_CANNOT_BE_DERIVED_BY_THE_NETWORK);
+      s1ap->send_downlink_nas_transport(ecm_ctx->enb_ue_s1ap_id, ecm_ctx->mme_ue_s1ap_id, nas_tx.get(), *enb_sri);
+
+      srsran::console("Service Request -- Short MAC invalid. Sending service reject.\n");
+      nas_logger.warning("Service Request -- Short MAC invalid. Sending service reject.");
+      nas_logger.info("Service Reject -- eNB_UE_S1AP_ID %d MME_UE_S1AP_ID %d.", enb_ue_s1ap_id, ecm_ctx->mme_ue_s1ap_id);
     }
-    nas_ctx->pack_service_reject(nas_tx.get(), LIBLTE_MME_EMM_CAUSE_UE_IDENTITY_CANNOT_BE_DERIVED_BY_THE_NETWORK);
-    s1ap->send_downlink_nas_transport(ecm_ctx->enb_ue_s1ap_id, ecm_ctx->mme_ue_s1ap_id, nas_tx.get(), *enb_sri);
 
-    srsran::console("Service Request -- Short MAC invalid. Sending service reject.\n");
-    nas_logger.warning("Service Request -- Short MAC invalid. Sending service reject.");
-    nas_logger.info("Service Reject -- eNB_UE_S1AP_ID %d MME_UE_S1AP_ID %d.", enb_ue_s1ap_id, ecm_ctx->mme_ue_s1ap_id);
+    if (s1ap->get_mme_statelearner_reset_state() == false && args.enable_ue_state_fuzzing == true) {
+      srsran::console("Response: service_request 3\n");
+      uint8_t* messageStr = handleServiceRequest();
+      uint16_t len = static_cast<uint16_t>(strlen((char*)messageStr));
+      s1ap->notify_response(messageStr, len);
+      delete[] messageStr;
+    } 
   }
   return true;
 }
@@ -844,13 +1032,23 @@ bool nas::handle_tracking_area_update_request(uint32_t                m_tmsi,
   nas_tmp.m_ecm_ctx.enb_ue_s1ap_id = enb_ue_s1ap_id;
   nas_tmp.m_ecm_ctx.mme_ue_s1ap_id = s1ap->get_next_mme_ue_s1ap_id();
 
-  srsran::unique_byte_buffer_t nas_tx = srsran::make_byte_buffer();
-  if (nas_tx == nullptr) {
-    nas_logger.error("Couldn't allocate PDU in %s().", __FUNCTION__);
-    return false;
+  if (args.enable_ue_state_fuzzing == false) {
+    srsran::unique_byte_buffer_t nas_tx = srsran::make_byte_buffer();
+    if (nas_tx == nullptr) {
+      nas_logger.error("Couldn't allocate PDU in %s().", __FUNCTION__);
+      return false;
+    }
+    nas_tmp.pack_tracking_area_update_reject(nas_tx.get(), LIBLTE_MME_EMM_CAUSE_IMPLICITLY_DETACHED);
+    s1ap->send_downlink_nas_transport(enb_ue_s1ap_id, nas_tmp.m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), *enb_sri);
+  }
+
+  if (s1ap->get_mme_statelearner_reset_state() == false && args.enable_ue_state_fuzzing == true) {
+    srsran::console("Response: tau_request\n");
+    uint8_t* messageStr = handleTauRequest();
+    uint16_t len = static_cast<uint16_t>(strlen((char*)messageStr));
+    s1ap->notify_response(messageStr, len);
+    delete[] messageStr;
   }
-  nas_tmp.pack_tracking_area_update_reject(nas_tx.get(), LIBLTE_MME_EMM_CAUSE_IMPLICITLY_DETACHED);
-  s1ap->send_downlink_nas_transport(enb_ue_s1ap_id, nas_tmp.m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), *enb_sri);
   return true;
 }
 
@@ -935,35 +1133,57 @@ bool nas::handle_attach_request(srsran::byte_buffer_t* nas_rx)
     // Save attach request type
     m_emm_ctx.attach_type = attach_req.eps_attach_type;
 
-    // Get Authentication Vectors from HSS
-    if (!m_hss->gen_auth_info_answer(
-            m_emm_ctx.imsi, m_sec_ctx.k_asme, m_sec_ctx.autn, m_sec_ctx.rand, m_sec_ctx.xres)) {
-      srsran::console("User not found. IMSI %015" PRIu64 "\n", m_emm_ctx.imsi);
-      m_logger.info("User not found. IMSI %015" PRIu64 "", m_emm_ctx.imsi);
-      return false;
-    }
+    if (m_enable_ue_state_fuzzing == false) {
+      // Get Authentication Vectors from HSS
+      if (!m_hss->gen_auth_info_answer(
+              m_emm_ctx.imsi, m_sec_ctx.k_asme, m_sec_ctx.autn, m_sec_ctx.rand, m_sec_ctx.xres)) {
+        srsran::console("User not found. IMSI %015" PRIu64 "\n", m_emm_ctx.imsi);
+        m_logger.info("User not found. IMSI %015" PRIu64 "", m_emm_ctx.imsi);
+        return false;
+      }
 
-    // Allocate eKSI for this authentication vector
-    // Here we assume a new security context thus a new eKSI
-    m_sec_ctx.eksi = 0;
+      // Allocate eKSI for this authentication vector
+      // Here we assume a new security context thus a new eKSI
+      m_sec_ctx.eksi = 0;
 
-    // Save the UE context
-    m_s1ap->add_nas_ctx_to_imsi_map(this);
+      // Save the UE context
+      m_s1ap->add_nas_ctx_to_imsi_map(this);
 
-    // Pack NAS Authentication Request in Downlink NAS Transport msg
-    srsran::unique_byte_buffer_t nas_tx = srsran::make_byte_buffer();
-    if (nas_tx == nullptr) {
-      m_logger.error("Couldn't allocate PDU in %s().", __FUNCTION__);
-      return false;
+      // Pack NAS Authentication Request in Downlink NAS Transport msg
+      srsran::unique_byte_buffer_t nas_tx = srsran::make_byte_buffer();
+      if (nas_tx == nullptr) {
+        m_logger.error("Couldn't allocate PDU in %s().", __FUNCTION__);
+        return false;
+      }
+      pack_authentication_request(nas_tx.get());
+
+      // Send reply to eNB
+      m_s1ap->send_downlink_nas_transport(
+          m_ecm_ctx.enb_ue_s1ap_id, m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), m_ecm_ctx.enb_sri);
+
+      m_logger.info("DL NAS: Sending Authentication Request");
+      srsran::console("DL NAS: Sending Authentication Request\n");
     }
-    pack_authentication_request(nas_tx.get());
 
-    // Send reply to eNB
-    m_s1ap->send_downlink_nas_transport(
-        m_ecm_ctx.enb_ue_s1ap_id, m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), m_ecm_ctx.enb_sri);
+    if (m_s1ap->get_mme_statelearner_reset_state() == false && m_enable_ue_state_fuzzing == true) {
+      nas* nas_ctx = m_s1ap->find_nas_ctx_from_imsi(imsi);
+      if (attach_req.eps_mobile_id.type_of_id == LIBLTE_MME_EPS_MOBILE_ID_TYPE_IMSI) {
+        srsran::console("Response: attach_request 1\n");
+        key_set(&nas_ctx->m_sec_ctx.k_nas_enc[16]);
+        uint8_t* messageStr = handleAttachRequest(0);
+        uint16_t len = static_cast<uint16_t>(strlen((char*)messageStr));
+        m_s1ap->notify_response(messageStr, len);
+        delete[] messageStr;
+      } else {
+        srsran::console("Response: attach_request_guti\n");
+        key_set(&nas_ctx->m_sec_ctx.k_nas_enc[16]);
+        uint8_t* messageStr = handleAttachRequestGUTI();
+        uint16_t len = static_cast<uint16_t>(strlen((char*)messageStr));
+        m_s1ap->notify_response(messageStr, len);
+        delete[] messageStr;
+      }
+    }
 
-    m_logger.info("DL NAS: Sending Authentication Request");
-    srsran::console("DL NAS: Sending Authentication Request\n");
     return true;
   } else {
     m_logger.error("Attach request from known UE");
@@ -983,36 +1203,38 @@ bool nas::handle_pdn_connectivity_request(srsran::byte_buffer_t* nas_rx)
     return false;
   }
 
-  // Send PDN connectivity reject
-  srsran::unique_byte_buffer_t nas_tx = srsran::make_byte_buffer();
-  if (nas_tx == nullptr) {
-    m_logger.error("Couldn't allocate PDU in %s().", __FUNCTION__);
-    return false;
-  }
+  if (m_enable_ue_state_fuzzing == false) {
+    // Send PDN connectivity reject
+    srsran::unique_byte_buffer_t nas_tx = srsran::make_byte_buffer();
+    if (nas_tx == nullptr) {
+      m_logger.error("Couldn't allocate PDU in %s().", __FUNCTION__);
+      return false;
+    }
 
-  LIBLTE_MME_PDN_CONNECTIVITY_REJECT_MSG_STRUCT pdn_con_reject = {};
-  pdn_con_reject.eps_bearer_id                                 = pdn_con_req.eps_bearer_id;
-  pdn_con_reject.proc_transaction_id                           = pdn_con_req.proc_transaction_id;
-  pdn_con_reject.esm_cause                                     = LIBLTE_MME_ESM_CAUSE_SERVICE_OPTION_NOT_SUPPORTED;
+    LIBLTE_MME_PDN_CONNECTIVITY_REJECT_MSG_STRUCT pdn_con_reject = {};
+    pdn_con_reject.eps_bearer_id                                 = pdn_con_req.eps_bearer_id;
+    pdn_con_reject.proc_transaction_id                           = pdn_con_req.proc_transaction_id;
+    pdn_con_reject.esm_cause                                     = LIBLTE_MME_ESM_CAUSE_SERVICE_OPTION_NOT_SUPPORTED;
 
-  err = liblte_mme_pack_pdn_connectivity_reject_msg(&pdn_con_reject, (LIBLTE_BYTE_MSG_STRUCT*)nas_tx.get());
-  if (err != LIBLTE_SUCCESS) {
-    m_logger.error("Error packing PDN connectivity reject");
-    srsran::console("Error packing PDN connectivity reject\n");
-    return false;
-  }
+    err = liblte_mme_pack_pdn_connectivity_reject_msg(&pdn_con_reject, (LIBLTE_BYTE_MSG_STRUCT*)nas_tx.get());
+    if (err != LIBLTE_SUCCESS) {
+      m_logger.error("Error packing PDN connectivity reject");
+      srsran::console("Error packing PDN connectivity reject\n");
+      return false;
+    }
 
-  // Send reply to eNB
-  m_s1ap->send_downlink_nas_transport(
-      m_ecm_ctx.enb_ue_s1ap_id, m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), m_ecm_ctx.enb_sri);
+    // Send reply to eNB
+    m_s1ap->send_downlink_nas_transport(
+        m_ecm_ctx.enb_ue_s1ap_id, m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), m_ecm_ctx.enb_sri);
 
-  m_logger.info("DL NAS: Sending PDN Connectivity Reject");
-  srsran::console("DL NAS: Sending PDN Connectivity Reject\n");
+    m_logger.info("DL NAS: Sending PDN Connectivity Reject");
+    srsran::console("DL NAS: Sending PDN Connectivity Reject\n");
+  }
 
   return true;
 }
 
-bool nas::handle_authentication_response(srsran::byte_buffer_t* nas_rx)
+bool nas::handle_authentication_response(srsran::byte_buffer_t* nas_rx, int flag)
 {
   LIBLTE_MME_AUTHENTICATION_RESPONSE_MSG_STRUCT auth_resp = {};
   bool                                          ue_valid  = true;
@@ -1030,45 +1252,84 @@ bool nas::handle_authentication_response(srsran::byte_buffer_t* nas_rx)
   m_logger.info(auth_resp.res, 8, "Authentication response -- RES");
   m_logger.info(m_sec_ctx.xres, 8, "Authentication response -- XRES");
 
-  // Check UE authentication
-  for (int i = 0; i < 8; i++) {
-    if (auth_resp.res[i] != m_sec_ctx.xres[i]) {
-      ue_valid = false;
+  srsran::unique_byte_buffer_t nas_tx = srsran::make_byte_buffer();
+
+  if (m_enable_ue_state_fuzzing == false) {
+    // Check UE authentication
+    for (int i = 0; i < 8; i++) {
+      if (auth_resp.res[i] != m_sec_ctx.xres[i]) {
+        ue_valid = false;
+      }
+    }
+    if (nas_tx == nullptr) {
+      m_logger.error("Couldn't allocate PDU in %s().", __FUNCTION__);
+      return false;
+    }
+  } else {
+    for (int i = 0; i < 32; i++) {
+      m_sec_ctx.k_asme[i] = m_sec_ctx.k_asme_tmp[i];
     }
-  }
 
-  srsran::unique_byte_buffer_t nas_tx = srsran::make_byte_buffer();
-  if (nas_tx == nullptr) {
-    m_logger.error("Couldn't allocate PDU in %s().", __FUNCTION__);
-    return false;
+    ue_valid = true;
   }
   if (!ue_valid) {
     // Authentication rejected
     srsran::console("UE Authentication Rejected.\n");
     m_logger.warning("UE Authentication Rejected.");
 
-    // Send back Athentication Reject
-    pack_authentication_reject(nas_tx.get());
-    m_logger.info("Downlink NAS: Sending Authentication Reject.");
+    if (m_enable_ue_state_fuzzing == false) {
+      // Send back Athentication Reject
+      pack_authentication_reject(nas_tx.get());
+      m_logger.info("Downlink NAS: Sending Authentication Reject.");
+    }
+    if (m_s1ap->get_mme_statelearner_reset_state() == false && m_enable_ue_state_fuzzing == true) {
+      srsran::console("Response: auth_response_rejected\n");
+      uint8_t* messageStr = handleAuthResponseRejected();
+      uint16_t len = static_cast<uint16_t>(strlen((char*)messageStr));
+      m_s1ap->notify_response(messageStr, len);
+      delete[] messageStr;
+    }
   } else {
     // Authentication accepted
     srsran::console("UE Authentication Accepted.\n");
     m_logger.info("UE Authentication Accepted.");
 
-    // Send Security Mode Command
-    m_sec_ctx.ul_nas_count = 0; // Reset the NAS uplink counter for the right key k_enb derivation
-    pack_security_mode_command(nas_tx.get());
-    srsran::console("Downlink NAS: Sending NAS Security Mode Command.\n");
+    if (m_enable_ue_state_fuzzing == false) {
+      // Send Security Mode Command
+      m_sec_ctx.ul_nas_count = 0; // Reset the NAS uplink counter for the right key k_enb derivation
+      pack_security_mode_command(nas_tx.get());
+      srsran::console("Downlink NAS: Sending NAS Security Mode Command.\n");
+    }
+    if (m_s1ap->get_mme_statelearner_reset_state() == false && m_enable_ue_state_fuzzing == true) {
+      if (flag == true) {
+        srsran::console("Response: auth_response\n");
+        uint8_t* messageStr = handleAuthenticationResponse();
+        uint16_t len = static_cast<uint16_t>(strlen((char*)messageStr));
+        m_s1ap->notify_response(messageStr, len);
+        delete[] messageStr;
+      } else {
+        m_sec_ctx.ul_nas_count = 0;
+        srsran::console("Response: auth_response\n");
+        uint8_t* messageStr = handleAuthenticationResponse();
+        uint16_t len = static_cast<uint16_t>(strlen((char*)messageStr));
+        m_s1ap->notify_response(messageStr, len);
+        delete[] messageStr;
+      }
+    }
   }
 
-  // Send reply
-  m_s1ap->send_downlink_nas_transport(
-      m_ecm_ctx.enb_ue_s1ap_id, m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), m_ecm_ctx.enb_sri);
+  if (m_enable_ue_state_fuzzing == false) {
+    // Send reply
+    m_s1ap->send_downlink_nas_transport(
+        m_ecm_ctx.enb_ue_s1ap_id, m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), m_ecm_ctx.enb_sri);
+  }
   return true;
 }
 
+
 bool nas::handle_security_mode_complete(srsran::byte_buffer_t* nas_rx)
 {
+  srsran::console("enter handle_security_mode_complete\n");
   LIBLTE_MME_SECURITY_MODE_COMPLETE_MSG_STRUCT sm_comp = {};
 
   // Get NAS security mode complete
@@ -1082,30 +1343,95 @@ bool nas::handle_security_mode_complete(srsran::byte_buffer_t* nas_rx)
   m_logger.info("Security Mode Command Complete -- IMSI: %015" PRIu64 "", m_emm_ctx.imsi);
   srsran::console("Security Mode Command Complete -- IMSI: %015" PRIu64 "\n", m_emm_ctx.imsi);
 
-  // Check wether secure ESM information transfer is required
-  srsran::unique_byte_buffer_t nas_tx = srsran::make_byte_buffer();
-  if (nas_tx == nullptr) {
-    m_logger.error("Couldn't allocate PDU in %s().", __FUNCTION__);
+  if (m_enable_ue_state_fuzzing == false) {
+    // Check wether secure ESM information transfer is required
+    srsran::unique_byte_buffer_t nas_tx = srsran::make_byte_buffer();
+    if (nas_tx == nullptr) {
+      m_logger.error("Couldn't allocate PDU in %s().", __FUNCTION__);
+      return false;
+    }
+    if (m_ecm_ctx.eit == true) {
+      // Secure ESM information transfer is required
+      srsran::console("Sending ESM information request\n");
+      m_logger.info("Sending ESM information request");
+
+      // Packing ESM information request
+      pack_esm_information_request(nas_tx.get());
+      m_s1ap->send_downlink_nas_transport(
+          m_ecm_ctx.enb_ue_s1ap_id, m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), m_ecm_ctx.enb_sri);
+    } else {
+      // Secure ESM information transfer not necessary
+      // Sending create session request to SP-GW.
+      uint8_t default_bearer = 5;
+      m_hss->gen_update_loc_answer(m_emm_ctx.imsi, &m_esm_ctx[default_bearer].qci);
+      m_logger.debug("Getting subscription information -- QCI %d", m_esm_ctx[default_bearer].qci);
+      srsran::console("Getting subscription information -- QCI %d\n", m_esm_ctx[default_bearer].qci);
+      m_gtpc->send_create_session_request(m_emm_ctx.imsi);
+    }
+  }
+
+  if (m_enable_ue_state_fuzzing == true) {
+    uint8_t key_enb[32];
+    srsran::security_generate_k_enb(m_sec_ctx.k_asme, m_sec_ctx.ul_nas_count, m_sec_ctx.k_enb);
+    // srsran::security_generate_k_enb(m_sec_ctx.k_asme, 0, m_sec_ctx.k_enb);
+    m_logger.info("Generating KeNB with UL NAS COUNT: %d\n", m_sec_ctx.ul_nas_count);
+    srsran::console("Generating KeNB with UL NAS COUNT: %d\n", m_sec_ctx.ul_nas_count);
+    m_logger.info(m_sec_ctx.k_enb, 32, "Key eNodeB (k_enb)\n");
+
+    srsran::unique_byte_buffer_t nas_tx = srsran::make_byte_buffer();
+
+    if (m_ecm_ctx.eit == true) {
+      // Secure ESM information transfer is required
+      srsran::console("Sending ESM information request\n");
+      m_logger.info("Sending ESM information request");
+
+      // Packing ESM information request
+      pack_esm_information_request(nas_tx.get());
+      m_s1ap->send_downlink_nas_transport(
+          m_ecm_ctx.enb_ue_s1ap_id, m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), m_ecm_ctx.enb_sri);
+    }
+
+  }
+  if (m_s1ap->get_mme_statelearner_reset_state() == false && m_enable_ue_state_fuzzing == true) {
+    srsran::console("Response: security_mode_complete\n");
+    uint8_t* messageStr = handleSecurityModeComplete(0); //mark to do
+    uint16_t len = static_cast<uint16_t>(strlen((char*)messageStr));
+    m_s1ap->notify_response(messageStr, len);
+    delete[] messageStr;
+  } 
+  sm_complete_flag = true;
+  nas* nas_ctx = m_s1ap->find_nas_ctx_from_imsi(m_emm_ctx.imsi);
+  
+  m_s1ap->add_nas_ctx_to_mme_ue_s1ap_id_map(nas_ctx);
+  m_s1ap->send_initial_context_setup_request(m_emm_ctx.imsi, 5); // send k_enb to enb
+
+  return true;
+
+
+}
+
+// fuzzing
+bool nas::handle_security_mode_reject(srsran::byte_buffer_t* nas_rx)
+{
+  LIBLTE_MME_SECURITY_MODE_REJECT_MSG_STRUCT sm_reject;
+
+  // Get NAS security mode reject
+  LIBLTE_ERROR_ENUM err = liblte_mme_unpack_security_mode_reject_msg((LIBLTE_BYTE_MSG_STRUCT*)nas_rx, &sm_reject);
+  if (err != LIBLTE_SUCCESS) {
+    m_logger.error("Error unpacking NAS security mode reject. Error: %s\n", liblte_error_text[err]);
     return false;
   }
-  if (m_ecm_ctx.eit == true) {
-    // Secure ESM information transfer is required
-    srsran::console("Sending ESM information request\n");
-    m_logger.info("Sending ESM information request");
+  m_logger.info("Security Mode Command Reject -- IMSI: %lu\n", m_ue_under_test_imsi);
+  srsran::console("Security Mode Command Reject -- IMSI: %lu\n", m_ue_under_test_imsi);
 
-    // Packing ESM information request
-    pack_esm_information_request(nas_tx.get());
-    m_s1ap->send_downlink_nas_transport(
-        m_ecm_ctx.enb_ue_s1ap_id, m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), m_ecm_ctx.enb_sri);
-  } else {
-    // Secure ESM information transfer not necessary
-    // Sending create session request to SP-GW.
-    uint8_t default_bearer = 5;
-    m_hss->gen_update_loc_answer(m_emm_ctx.imsi, &m_esm_ctx[default_bearer].qci);
-    m_logger.debug("Getting subscription information -- QCI %d", m_esm_ctx[default_bearer].qci);
-    srsran::console("Getting subscription information -- QCI %d\n", m_esm_ctx[default_bearer].qci);
-    m_gtpc->send_create_session_request(m_emm_ctx.imsi);
+  if (m_s1ap->get_mme_statelearner_reset_state() == false && m_enable_ue_state_fuzzing == true) {
+    srsran::console("Response: security_mode_reject\n");
+    uint8_t* messageStr = handleSecurityModeReject(sm_reject.emm_cause);
+    uint16_t len = static_cast<uint16_t>(strlen((char*)messageStr));
+    m_s1ap->notify_response(messageStr, len);
+    delete[] messageStr;
   }
+
   return true;
 }
 
@@ -1142,21 +1468,77 @@ bool nas::handle_attach_complete(srsran::byte_buffer_t* nas_rx)
     m_gtpc->send_modify_bearer_request(
         m_emm_ctx.imsi, act_bearer.eps_bearer_id, &m_esm_ctx[act_bearer.eps_bearer_id].enb_fteid);
 
-    // Send reply to EMM Info to UE
-    srsran::unique_byte_buffer_t nas_tx = srsran::make_byte_buffer();
-    if (nas_tx == nullptr) {
-      m_logger.error("Couldn't allocate PDU in %s().", __FUNCTION__);
-      return false;
-    }
-    pack_emm_information(nas_tx.get());
-
-    m_s1ap->send_downlink_nas_transport(
-        m_ecm_ctx.enb_ue_s1ap_id, m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), m_ecm_ctx.enb_sri);
+    if (m_enable_ue_state_fuzzing == false) {
+      // Send reply to EMM Info to UE
+      srsran::unique_byte_buffer_t nas_tx = srsran::make_byte_buffer();
+      if (nas_tx == nullptr) {
+        m_logger.error("Couldn't allocate PDU in %s().", __FUNCTION__);
+        return false;
+      }
+      pack_emm_information(nas_tx.get());
+
+      m_s1ap->send_downlink_nas_transport(
+          m_ecm_ctx.enb_ue_s1ap_id, m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), m_ecm_ctx.enb_sri);
+
+      srsran::console("Sending EMM Information\n");
+      m_logger.info("Sending EMM Information");
+    }
+  }
+  m_emm_ctx.state = EMM_STATE_REGISTERED;
+
+  if (m_s1ap->get_mme_statelearner_reset_state() == false && m_enable_ue_state_fuzzing == true) {
+    srsran::console("Response: attach_complete\n");
+    uint8_t* messageStr = handleAttachComplete();
+    uint16_t len = static_cast<uint16_t>(strlen((char*)messageStr));
+    m_s1ap->notify_response(messageStr, len);
+    delete[] messageStr;
+  }
+
+  return true;
+}
+
+bool nas::handle_tracking_area_update_complete(srsran::byte_buffer_t* nas_rx)
+{
+  LIBLTE_MME_TRACKING_AREA_UPDATE_COMPLETE_MSG_STRUCT              tau_comp;
+  uint8_t                                                          pd, msg_type;
+  LIBLTE_MME_ACTIVATE_DEFAULT_EPS_BEARER_CONTEXT_ACCEPT_MSG_STRUCT act_bearer;
+
+  LIBLTE_ERROR_ENUM err =
+      liblte_mme_unpack_tracking_area_update_complete_msg((LIBLTE_BYTE_MSG_STRUCT*)nas_rx, &tau_comp);
+  if (err != LIBLTE_SUCCESS) {
+    m_logger.error("Error unpacking NAS TAU COMPLETES. Error: %s\n", liblte_error_text[err]);
+    return false;
+  }
+
+  if (m_emm_ctx.state == EMM_STATE_DEREGISTERED) {
+    // Attach requested from attach request
+    // m_gtpc->send_modify_bearer_request(
+    //     m_emm_ctx.imsi, act_bearer.eps_bearer_id, &m_esm_ctx[act_bearer.eps_bearer_id].enb_fteid); // fuzzing: seems don't need this
+
+    if (m_enable_ue_state_fuzzing == false) {
+      // Send reply to EMM Info to UE
+      srsran::unique_byte_buffer_t nas_tx = srsran::make_byte_buffer();
+      pack_emm_information(nas_tx.get());
+
+      m_s1ap->send_downlink_nas_transport(
+          m_ecm_ctx.enb_ue_s1ap_id, m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), m_ecm_ctx.enb_sri);
 
-    srsran::console("Sending EMM Information\n");
-    m_logger.info("Sending EMM Information");
+      srsran::console("Sending EMM Information\n");
+      m_logger.info("Sending EMM Information\n");
+    }
   }
+
   m_emm_ctx.state = EMM_STATE_REGISTERED;
+
+  
+  if (m_s1ap->get_mme_statelearner_reset_state() == false && m_enable_ue_state_fuzzing == true) {
+    srsran::console("Response: tau_complete\n");
+    uint8_t* messageStr = handleTauComplete();
+    uint16_t len = static_cast<uint16_t>(strlen((char*)messageStr));
+    m_s1ap->notify_response(messageStr, len);
+    delete[] messageStr;
+  }
+  
   return true;
 }
 
@@ -1182,15 +1564,26 @@ bool nas::handle_esm_information_response(srsran::byte_buffer_t* nas_rx)
     srsran::console("ESM Info: %d Protocol Configuration Options\n", esm_info_resp.protocol_cnfg_opts.N_opts);
   }
 
-  // Get subscriber info from HSS
-  uint8_t default_bearer = 5;
-  m_hss->gen_update_loc_answer(m_emm_ctx.imsi, &m_esm_ctx[default_bearer].qci);
-  m_logger.debug("Getting subscription information -- QCI %d", m_esm_ctx[default_bearer].qci);
-  srsran::console("Getting subscription information -- QCI %d\n", m_esm_ctx[default_bearer].qci);
+  // if (m_enable_ue_state_fuzzing == false) {
+    // Get subscriber info from HSS
+    uint8_t default_bearer = 5;
+    m_hss->gen_update_loc_answer(m_emm_ctx.imsi, &m_esm_ctx[default_bearer].qci);
+    m_logger.debug("Getting subscription information -- QCI %d", m_esm_ctx[default_bearer].qci);
+    srsran::console("Getting subscription information -- QCI %d\n", m_esm_ctx[default_bearer].qci);
+
+    // TODO The packging of GTP-C messages is not ready.
+    // This means that GTP-U tunnels are created with function calls, as opposed to GTP-C.
+    m_gtpc->send_create_session_request(m_emm_ctx.imsi);
+  // }
+
+  // if (m_s1ap->get_mme_statelearner_reset_state() == false && m_enable_ue_state_fuzzing == true) {
+  //   srsran::console("Response: esm_info_response\n");
+  //   uint8_t* messageStr = handleEsmInfoResponse();
+  //   uint16_t len = static_cast<uint16_t>(strlen((char*)messageStr));
+  //   m_s1ap->notify_response(messageStr, len);
+  //   delete[] messageStr;
+  // }
 
-  // TODO The packging of GTP-C messages is not ready.
-  // This means that GTP-U tunnels are created with function calls, as opposed to GTP-C.
-  m_gtpc->send_create_session_request(m_emm_ctx.imsi);
   return true;
 }
 
@@ -1216,39 +1609,67 @@ bool nas::handle_identity_response(srsran::byte_buffer_t* nas_rx)
   // Set UE's IMSI
   m_emm_ctx.imsi = imsi;
 
-  // Get Authentication Vectors from HSS
-  if (!m_hss->gen_auth_info_answer(imsi, m_sec_ctx.k_asme, m_sec_ctx.autn, m_sec_ctx.rand, m_sec_ctx.xres)) {
-    srsran::console("User not found. IMSI %015" PRIu64 "\n", imsi);
-    m_logger.info("User not found. IMSI %015" PRIu64 "", imsi);
-    return false;
-  }
-  // Identity reponse from unknown GUTI atach. Assigning new eKSI.
-  m_sec_ctx.eksi = 0;
+  if (m_enable_ue_state_fuzzing == false) {
+    // Get Authentication Vectors from HSS
+    if (!m_hss->gen_auth_info_answer(imsi, m_sec_ctx.k_asme, m_sec_ctx.autn, m_sec_ctx.rand, m_sec_ctx.xres)) {
+      srsran::console("User not found. IMSI %015" PRIu64 "\n", imsi);
+      m_logger.info("User not found. IMSI %015" PRIu64 "", imsi);
+      return false;
+    }
+    // Identity reponse from unknown GUTI atach. Assigning new eKSI.
+    m_sec_ctx.eksi = 0;
 
-  // Make sure UE context was not previously stored in IMSI map
-  nas* nas_ctx = m_s1ap->find_nas_ctx_from_imsi(imsi);
-  if (nas_ctx != nullptr) {
-    m_logger.warning("UE context already exists.");
-    m_s1ap->delete_ue_ctx(imsi);
-  }
+    // Make sure UE context was not previously stored in IMSI map
+    nas* nas_ctx = m_s1ap->find_nas_ctx_from_imsi(imsi);
+    if (nas_ctx != nullptr) {
+      m_logger.warning("UE context already exists.");
+      m_s1ap->delete_ue_ctx(imsi);
+    }
 
-  // Store UE context im IMSI map
-  m_s1ap->add_nas_ctx_to_imsi_map(this);
+    // Store UE context im IMSI map
+    m_s1ap->add_nas_ctx_to_imsi_map(this);
 
-  // Pack NAS Authentication Request in Downlink NAS Transport msg
-  nas_tx = srsran::make_byte_buffer();
-  if (nas_tx == nullptr) {
-    m_logger.error("Couldn't allocate PDU in %s().", __FUNCTION__);
-    return false;
+    // Pack NAS Authentication Request in Downlink NAS Transport msg
+    nas_tx = srsran::make_byte_buffer();
+    if (nas_tx == nullptr) {
+      m_logger.error("Couldn't allocate PDU in %s().", __FUNCTION__);
+      return false;
+    }
+    pack_authentication_request(nas_tx.get());
+
+    // Send reply to eNB
+    m_s1ap->send_downlink_nas_transport(
+        m_ecm_ctx.enb_ue_s1ap_id, m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), m_ecm_ctx.enb_sri);
+
+    m_logger.info("Downlink NAS: Sent Authentication Request");
+    srsran::console("Downlink NAS: Sent Authentication Request\n");
   }
-  pack_authentication_request(nas_tx.get());
 
-  // Send reply to eNB
-  m_s1ap->send_downlink_nas_transport(
-      m_ecm_ctx.enb_ue_s1ap_id, m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), m_ecm_ctx.enb_sri);
+  if (m_s1ap->get_mme_statelearner_reset_state() == false && m_enable_ue_state_fuzzing == true) {
+    srsran::console("Response: identity_response\n");
+    uint8_t* messageStr = handleIdentityResponse();
+    uint16_t len = static_cast<uint16_t>(strlen((char*)messageStr));
+    m_s1ap->notify_response(messageStr, len);
+    delete[] messageStr;
+  }
+  return true;
+}
 
-  m_logger.info("Downlink NAS: Sent Authentication Request");
-  srsran::console("Downlink NAS: Sent Authentication Request\n");
+bool nas::handle_uplink_nas_transport(srsran::byte_buffer_t* nas_rx)
+{
+  srsran::console("Received uplink nas transport\n");
+  LIBLTE_MME_UPLINK_NAS_TRANSPORT_MSG_STRUCT ul_nas_transport;
+  LIBLTE_ERROR_ENUM                          err =
+      liblte_mme_unpack_uplink_nas_transport_msg((LIBLTE_BYTE_MSG_STRUCT*)nas_rx, &ul_nas_transport);
+  
+  if (m_s1ap->get_mme_statelearner_reset_state() == false && m_enable_ue_state_fuzzing == true) {
+    srsran::console("Response: ul_nas_transport\n");
+    uint8_t* messageStr = handleUlNasTransport();
+    uint16_t len = static_cast<uint16_t>(strlen((char*)messageStr));
+    m_s1ap->notify_response(messageStr, len);
+    delete[] messageStr;
+  }
+  
   return true;
 }
 
@@ -1259,18 +1680,28 @@ bool nas::handle_tracking_area_update_request(srsran::byte_buffer_t* nas_rx)
 
   srsran::unique_byte_buffer_t nas_tx;
 
-  /* TAU handling unsupported, therefore send TAU reject with cause IMPLICITLY DETACHED.
-   * this will trigger full re-attach by the UE, instead of going to a TAU request loop */
-  nas_tx = srsran::make_byte_buffer();
-  if (nas_tx == nullptr) {
-    m_logger.error("Couldn't allocate PDU in %s().", __FUNCTION__);
-    return false;
+  if (m_enable_ue_state_fuzzing == false) {
+    /* TAU handling unsupported, therefore send TAU reject with cause IMPLICITLY DETACHED.
+    * this will trigger full re-attach by the UE, instead of going to a TAU request loop */
+    nas_tx = srsran::make_byte_buffer();
+    if (nas_tx == nullptr) {
+      m_logger.error("Couldn't allocate PDU in %s().", __FUNCTION__);
+      return false;
+    }
+    // TODO we could enable integrity protection in some cases, but UE should comply anyway
+    pack_tracking_area_update_reject(nas_tx.get(), LIBLTE_MME_EMM_CAUSE_IMPLICITLY_DETACHED);
+    // Send reply
+    m_s1ap->send_downlink_nas_transport(
+        m_ecm_ctx.enb_ue_s1ap_id, m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), m_ecm_ctx.enb_sri);
   }
-  // TODO we could enable integrity protection in some cases, but UE should comply anyway
-  pack_tracking_area_update_reject(nas_tx.get(), LIBLTE_MME_EMM_CAUSE_IMPLICITLY_DETACHED);
-  // Send reply
-  m_s1ap->send_downlink_nas_transport(
-      m_ecm_ctx.enb_ue_s1ap_id, m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), m_ecm_ctx.enb_sri);
+
+  if (m_s1ap->get_mme_statelearner_reset_state() == false && m_enable_ue_state_fuzzing == true) {
+    srsran::console("Response: tau_request\n");
+    uint8_t* messageStr = handleTauRequest();
+    uint16_t len = static_cast<uint16_t>(strlen((char*)messageStr));
+    m_s1ap->notify_response(messageStr, len);
+    delete[] messageStr;
+  } 
 
   return true;
 }
@@ -1289,6 +1720,13 @@ bool nas::handle_authentication_failure(srsran::byte_buffer_t* nas_rx)
     return false;
   }
 
+  if (m_s1ap->get_mme_statelearner_reset_state() == false && m_enable_ue_state_fuzzing == true) {
+    uint8_t* messageStr = handleAuthenticationFailure(auth_fail.emm_cause);
+    uint16_t len = static_cast<uint16_t>(strlen((char*)messageStr));
+    m_s1ap->notify_response(messageStr, len);
+    delete[] messageStr;
+  }
+
   switch (auth_fail.emm_cause) {
     case 20:
       srsran::console("MAC code failure\n");
@@ -1310,32 +1748,34 @@ bool nas::handle_authentication_failure(srsran::byte_buffer_t* nas_rx)
         m_logger.info("Resynchronization failed. IMSI %015" PRIu64 "", m_emm_ctx.imsi);
         return false;
       }
-      // Get Authentication Vectors from HSS
-      if (!m_hss->gen_auth_info_answer(
-              m_emm_ctx.imsi, m_sec_ctx.k_asme, m_sec_ctx.autn, m_sec_ctx.rand, m_sec_ctx.xres)) {
-        srsran::console("User not found. IMSI %015" PRIu64 "\n", m_emm_ctx.imsi);
-        m_logger.info("User not found. IMSI %015" PRIu64 "", m_emm_ctx.imsi);
-        return false;
-      }
-
-      // Making sure eKSI is different from previous eKSI.
-      m_sec_ctx.eksi = (m_sec_ctx.eksi + 1) % 6;
-
-      // Pack NAS Authentication Request in Downlink NAS Transport msg
-      nas_tx = srsran::make_byte_buffer();
-      if (nas_tx == nullptr) {
-        m_logger.error("Couldn't allocate PDU in %s().", __FUNCTION__);
-        return false;
+      if (m_enable_ue_state_fuzzing == false) {
+        // Get Authentication Vectors from HSS
+        if (!m_hss->gen_auth_info_answer(
+                m_emm_ctx.imsi, m_sec_ctx.k_asme, m_sec_ctx.autn, m_sec_ctx.rand, m_sec_ctx.xres)) {
+          srsran::console("User not found. IMSI %015" PRIu64 "\n", m_emm_ctx.imsi);
+          m_logger.info("User not found. IMSI %015" PRIu64 "", m_emm_ctx.imsi);
+          return false;
+        }
+
+        // Making sure eKSI is different from previous eKSI.
+        m_sec_ctx.eksi = (m_sec_ctx.eksi + 1) % 6;
+
+        // Pack NAS Authentication Request in Downlink NAS Transport msg
+        nas_tx = srsran::make_byte_buffer();
+        if (nas_tx == nullptr) {
+          m_logger.error("Couldn't allocate PDU in %s().", __FUNCTION__);
+          return false;
+        }
+        pack_authentication_request(nas_tx.get());
+
+        // Send reply to eNB
+        m_s1ap->send_downlink_nas_transport(
+            m_ecm_ctx.enb_ue_s1ap_id, m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), m_ecm_ctx.enb_sri);
+
+        m_logger.info("Downlink NAS: Sent Authentication Request");
+        srsran::console("Downlink NAS: Sent Authentication Request\n");
+        // TODO Start T3460 Timer!
       }
-      pack_authentication_request(nas_tx.get());
-
-      // Send reply to eNB
-      m_s1ap->send_downlink_nas_transport(
-          m_ecm_ctx.enb_ue_s1ap_id, m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), m_ecm_ctx.enb_sri);
-
-      m_logger.info("Downlink NAS: Sent Authentication Request");
-      srsran::console("Downlink NAS: Sent Authentication Request\n");
-      // TODO Start T3460 Timer!
       break;
   }
   return true;
@@ -1364,6 +1804,63 @@ bool nas::handle_detach_request(srsran::byte_buffer_t* nas_msg)
   if (m_ecm_ctx.mme_ue_s1ap_id != 0) {
     m_s1ap->send_ue_context_release_command(m_ecm_ctx.mme_ue_s1ap_id);
   }
+
+  if (m_s1ap->get_mme_statelearner_reset_state() == false && m_enable_ue_state_fuzzing == true) {
+    uint8_t* messageStr = handleDetachRequest();
+    uint16_t len = static_cast<uint16_t>(strlen((char*)messageStr));
+    m_s1ap->notify_response(messageStr, len);
+    delete[] messageStr;
+  }
+
+  return true;
+}
+
+bool nas::handle_nas_emm_status(srsran::byte_buffer_t* nas_msg)
+{
+  LIBLTE_MME_EMM_STATUS_MSG_STRUCT emm_status;
+
+  // Get NAS authentication response
+  LIBLTE_ERROR_ENUM err = liblte_mme_unpack_emm_status_msg((LIBLTE_BYTE_MSG_STRUCT*)nas_msg, &emm_status);
+  if (err != LIBLTE_SUCCESS) {
+    m_logger.error("Error unpacking NAS emm status. Error: %s\n", liblte_error_text[err]);
+    return false;
+  }
+
+  m_logger.info("EMM Status -- IMSI: %lu\n", m_ue_under_test_imsi);
+
+  if (m_s1ap->get_mme_statelearner_reset_state() == false && m_enable_ue_state_fuzzing == true) {
+    srsran::console("Response: emm_status\n");
+    uint8_t* messageStr = handleEmmStatus();
+    uint16_t len = static_cast<uint16_t>(strlen((char*)messageStr));
+    m_s1ap->notify_response(messageStr, len);
+    delete[] messageStr;
+  }
+
+  return true;
+}
+
+bool nas::handle_guti_reallocation_complete(srsran::byte_buffer_t* nas_msg)
+{
+  LIBLTE_MME_GUTI_REALLOCATION_COMPLETE_MSG_STRUCT guti_reallocation_complete;
+
+  // Get NAS authentication response
+  LIBLTE_ERROR_ENUM err =
+      liblte_mme_unpack_guti_reallocation_complete_msg((LIBLTE_BYTE_MSG_STRUCT*)nas_msg, &guti_reallocation_complete);
+  if (err != LIBLTE_SUCCESS) {
+    m_logger.error("Error unpacking NAS emm status. Error: %s\n", liblte_error_text[err]);
+    return false;
+  }
+
+  m_logger.info("EMM Status -- IMSI: %lu\n", m_ue_under_test_imsi);
+
+  if (m_s1ap->get_mme_statelearner_reset_state() == false && m_enable_ue_state_fuzzing == true) {
+    srsran::console("Response: GUTI Reallocation Complete\n");
+    uint8_t* messageStr = handleGutiReallocationComplete();
+    uint16_t len = static_cast<uint16_t>(strlen((char*)messageStr));
+    m_s1ap->notify_response(messageStr, len);
+    delete[] messageStr;
+  }
+
   return true;
 }
 
@@ -1379,7 +1876,7 @@ bool nas::pack_authentication_request(srsran::byte_buffer_t* nas_buffer)
   auth_req.nas_ksi.tsc_flag = LIBLTE_MME_TYPE_OF_SECURITY_CONTEXT_FLAG_NATIVE;
   auth_req.nas_ksi.nas_ksi  = m_sec_ctx.eksi;
 
-  LIBLTE_ERROR_ENUM err = liblte_mme_pack_authentication_request_msg(&auth_req, (LIBLTE_BYTE_MSG_STRUCT*)nas_buffer);
+  LIBLTE_ERROR_ENUM err = liblte_mme_pack_authentication_request_msg(&auth_req, (LIBLTE_BYTE_MSG_STRUCT*)nas_buffer, 0);
   if (err != LIBLTE_SUCCESS) {
     m_logger.error("Error packing Authentication Request");
     srsran::console("Error packing Authentication Request\n");
@@ -2008,6 +2505,56 @@ void nas::cipher_encrypt(srsran::byte_buffer_t* pdu)
   }
 }
 
+// fuzzing
+void nas::cipher_encrypt_null(srsran::byte_buffer_t* pdu)
+{
+
+  srsran::byte_buffer_t pdu_tmp;
+  switch (m_sec_ctx.cipher_algo) {
+    case srsran::CIPHERING_ALGORITHM_ID_EEA0:
+      break;
+    case srsran::CIPHERING_ALGORITHM_ID_128_EEA1:
+      srsran::security_128_eea1(&m_sec_ctx.k_nas_enc[16],
+                                pdu->msg[5],
+                                0, // Bearer always 0 for NAS
+                                srsran::SECURITY_DIRECTION_DOWNLINK,
+                                &pdu->msg[6],
+                                pdu->N_bytes - 6,
+                                &pdu_tmp.msg[6]);
+      pdu_tmp.msg = 0;
+      memcpy(&pdu->msg[6], &pdu_tmp.msg[6], pdu->N_bytes - 6);
+      m_logger.debug(pdu_tmp.msg, pdu->N_bytes, "Encrypted");
+      break;
+    case srsran::CIPHERING_ALGORITHM_ID_128_EEA2:
+      srsran::security_128_eea2(&m_sec_ctx.k_nas_enc[16],
+                                pdu->msg[5],
+                                0, // Bearer always 0 for NAS
+                                srsran::SECURITY_DIRECTION_DOWNLINK,
+                                &pdu->msg[6],
+                                pdu->N_bytes - 6,
+                                &pdu_tmp.msg[6]);
+      pdu_tmp.msg = 0;
+      memcpy(&pdu->msg[6], &pdu_tmp.msg[6], pdu->N_bytes - 6);
+      m_logger.debug(pdu_tmp.msg, pdu->N_bytes, "Encrypted");
+      break;
+    case srsran::CIPHERING_ALGORITHM_ID_128_EEA3:
+      srsran::security_128_eea3(&m_sec_ctx.k_nas_enc[16],
+                                pdu->msg[5],
+                                0, // Bearer always 0 for NAS
+                                srsran::SECURITY_DIRECTION_DOWNLINK,
+                                &pdu->msg[6],
+                                pdu->N_bytes - 6,
+                                &pdu_tmp.msg[6]);
+      pdu_tmp.msg = 0;
+      memcpy(&pdu->msg[6], &pdu_tmp.msg[6], pdu->N_bytes - 6);
+      m_logger.debug(pdu_tmp.msg, pdu->N_bytes, "Encrypted");
+      break;      
+    default:
+      m_logger.error("Ciphering algorithm not known\n");
+      break;
+  }
+}
+
 /**************************
  *
  * Timer related functions
@@ -2085,4 +2632,1073 @@ bool nas::expire_t3413()
   return true;
 }
 
+
+// LTEAttacker fuzzing
+
+bool nas::handle_statelearner_query_identity_request_custom(int cipher, int integrity, int replay, int identification_parameter, int security_header_type)
+{
+  if (replay == 1){
+    if (identity_replay_buffer.get() == NULL) {
+      srsran::console("********replayed identity  request not sending!!************\n");
+      return true;
+    } else {
+      m_s1ap->send_downlink_nas_transport(
+          m_ecm_ctx.enb_ue_s1ap_id, m_ecm_ctx.mme_ue_s1ap_id, identity_replay_buffer.get(), m_ecm_ctx.enb_sri);
+      return true;
+    }
+  }
+  if(cipher == 1 || integrity ==1){
+    if (check(&m_sec_ctx.k_nas_enc[16])) {
+      if (m_s1ap->get_mme_statelearner_reset_state() == false && m_enable_ue_state_fuzzing == true) {
+        srsran::console("********protected identity request not sending!!************\n");
+        return true;
+      }
+    } 
+  }
+  srsran::unique_byte_buffer_t                 nas_tx;
+  bool                   ret = false;
+  nas_tx = srsran::make_byte_buffer();
+  pack_identity_request_custom(nas_tx.get(), cipher, integrity, replay, identification_parameter, security_header_type);
+
+  m_s1ap->send_downlink_nas_transport(m_ecm_ctx.enb_ue_s1ap_id, m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), m_ecm_ctx.enb_sri);
+
+  if(cipher == 0 && integrity == 0 && replay == 0 && identification_parameter == 1 && security_header_type == 0){
+    identity_replay_buffer = std::move(nas_tx);
+  }
+
+  return true;
+}
+
+bool nas::handle_statelearner_query_authentication_request_custom(int cipher, int integrity, int replay, int seperation_bit, int sqn, int security_header_type)
+{
+  srsran::console("*******2656 authentication request!************\n");
+
+  if (replay == 1){
+    if (auth_replay_buffer.get() == NULL) {
+      srsran::console("*******Replayed authentication request not sending!************\n");
+      return true;
+    } else {
+      // Send reply to eNB
+      m_s1ap->send_downlink_nas_transport(
+          m_ecm_ctx.enb_ue_s1ap_id, m_ecm_ctx.mme_ue_s1ap_id, auth_replay_buffer.get(), m_ecm_ctx.enb_sri);
+
+      m_logger.info("Downlink NAS: Sending Authentication Request Replayed\n");
+      srsran::console("Downlink NAS: Sending Authentication Request Replayed\n");
+      return true;
+    }
+  }
+
+  if(cipher == 1 || integrity ==1){
+    if (check(&m_sec_ctx.k_nas_enc[16])) {
+      if (m_s1ap->get_mme_statelearner_reset_state() == false && m_enable_ue_state_fuzzing == true) {
+        srsran::console("********portected auth_request not sending!!************\n");
+        return true;
+      }
+    }
+  }
+
+  if (!m_hss->gen_auth_info_answer(
+    m_emm_ctx.imsi, m_sec_ctx.k_asme_tmp, m_sec_ctx.autn, m_sec_ctx.rand, m_sec_ctx.xres)) {
+  srsran::console("User not found. IMSI %015" PRIu64 "\n", m_emm_ctx.imsi);
+  m_logger.info("User not found. IMSI %015" PRIu64 "\n", m_emm_ctx.imsi);
+  return false;
+  }
+  // Allocate eKSI for this authentication vector
+  // Here we assume a new security context thus a new eKSI
+  m_sec_ctx.eksi = 0;
+
+  // Save the UE context
+  m_s1ap->add_nas_ctx_to_imsi_map(this);
+  m_s1ap->add_nas_ctx_to_mme_ue_s1ap_id_map(this);
+  m_s1ap->add_ue_to_enb_set(m_ecm_ctx.enb_sri.sinfo_assoc_id, m_ecm_ctx.mme_ue_s1ap_id);
+
+  srsran::unique_byte_buffer_t                 nas_tx;
+  bool                   ret = false;
+  // Pack NAS Authentication Request in Downlink NAS Transport msg
+  nas_tx = srsran::make_byte_buffer();
+
+  srsran::console("2699 %d\n", security_header_type);
+
+  pack_authentication_request_custom(nas_tx.get(), cipher, integrity, replay, seperation_bit, sqn, security_header_type);
+
+  // Send reply to eNB
+  m_s1ap->send_downlink_nas_transport(m_ecm_ctx.enb_ue_s1ap_id, m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), m_ecm_ctx.enb_sri);
+    
+  if(cipher == 0 && integrity == 0 && replay == 0 && seperation_bit == 1 && security_header_type == 0){
+    auth_replay_buffer = std::move(nas_tx);
+  }
+
+  m_logger.info("Downlink NAS: Sending Authentication Request\n");
+  srsran::console("Downlink NAS: Sending Authentication Request\n");
+  return true;
+}
+
+bool nas::handle_statelearner_query_security_mode_command_custom(int cipher, int integrity, int replay, int auth_parameter, int eia, int eea, int security_header_type)
+{
+  printf("smc_custom!!!\n");
+
+  if (replay == 1){
+    if (smd_replay_buffer.get() == NULL) {
+   
+      srsran::console("********replayed smd NS not sending!!************\n");
+      return true;
+    } else {
+      bool ret = false;
+
+      m_s1ap->send_downlink_nas_transport(
+          m_ecm_ctx.enb_ue_s1ap_id, m_ecm_ctx.mme_ue_s1ap_id, smd_replay_buffer.get(), m_ecm_ctx.enb_sri);
+      return true;
+    }
+  }
+ 
+  srsran::unique_byte_buffer_t                 nas_tx;
+  bool                   ret = false;
+
+  nas_tx                 = srsran::make_byte_buffer();
+  if (sm_complete_flag == true) {
+    m_sec_ctx.dl_nas_count++; // increase the NAS uplink counter
+  } else{
+    m_sec_ctx.dl_nas_count = 0; // Reset the NAS uplink counter for the right key k_enb derivation
+  }
+  pack_security_mode_command_custom(nas_tx.get(), cipher, integrity, replay, auth_parameter, eia, eea, security_header_type);
+
+  if(cipher == 1 || integrity ==1){
+    if (check(&m_sec_ctx.k_nas_enc[16])) {
+      if (m_s1ap->get_mme_statelearner_reset_state() == false && m_enable_ue_state_fuzzing == true) {
+
+        srsran::console("********protected smd not sending!!************\n");
+        return true;
+      }
+    } 
+}
+
+
+    for(int i = 0; i < 31; i++){
+    srsran::console("k_nas_int: %d\n", m_sec_ctx.k_nas_int[i]);
+  }
+
+  m_s1ap->send_downlink_nas_transport(m_ecm_ctx.enb_ue_s1ap_id, m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), m_ecm_ctx.enb_sri);
+
+  if(cipher == 0 && integrity == 1 && replay == 0 && auth_parameter == 1 && eia == 1 && security_header_type == 3){
+    // smd_replay_buffer = (srsran::unique_byte_buffer_t*)malloc(nas_tx->N_bytes);
+    smd_replay_buffer = std::move(nas_tx);
+    srsran::console("********2759************\n");
+    // smd_replay_buffer = m_pool ->
+    // smd_replay_buffer = nas_tx;
+  }
+
+  m_logger.info("Downlink NAS: Sending NAS Security Mode Command\n");
+  srsran::console("Downlink NAS: Sending NAS Security Mode Command\n");
+
+  return true;
+}
+
+bool nas::handle_statelearner_query_detach_request_custom(int integrity, int cipher, int security_header_type){
+  srsran::unique_byte_buffer_t                 nas_tx;
+  bool                   ret = false;
+
+  nas_tx = srsran::make_byte_buffer();
+  pack_detach_request(nas_tx.get()); //protected msg
+
+  m_s1ap->send_downlink_nas_transport(m_ecm_ctx.enb_ue_s1ap_id, m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), m_ecm_ctx.enb_sri);
+
+  m_logger.info("Downlink NAS: Sending NAS Detach Request\n");
+  srsran::console("Downlink NAS: Sending NAS Detach Request\n");
+
+  return true;
+
+}
+
+bool nas::handle_statelearner_query_attach_accept_custom(int cipher, int integrity, int replay, int security_header_type)
+{
+  if (replay == 1) {
+    if (attach_accept_replay_buffer.get() == NULL) {
+      srsran::console("*******Replayed authentication request not sending!************\n");
+      return true;
+    } else {
+      // Send reply to eNB
+      m_s1ap->send_downlink_nas_transport(
+          m_ecm_ctx.enb_ue_s1ap_id, m_ecm_ctx.mme_ue_s1ap_id, auth_replay_buffer.get(), m_ecm_ctx.enb_sri);
+
+      m_logger.info("Downlink NAS: Sending Attach Accept Replayed\n");
+      srsran::console("Downlink NAS: Sending Attach Accept Replayed\n");
+      return true;
+    }
+  }
+
+  if(cipher == 1 || integrity ==1){
+    if (check(&m_sec_ctx.k_nas_enc[16])) {
+      if (m_s1ap->get_mme_statelearner_reset_state() == false && m_enable_ue_state_fuzzing == true) {
+        srsran::console("********portected auth_request not sending!!************\n");
+        return true;
+      }
+    }
+  }
+
+  srsran::unique_byte_buffer_t                 nas_tx;
+  bool                   ret = false;
+
+
+  nas_tx = srsran::make_byte_buffer();
+  pack_attach_accept_custom(nas_tx.get(), cipher, integrity, replay, security_header_type);
+
+  for(int i = 0; i < 31; i++){
+    srsran::console("k_nas_int: %d\n", m_sec_ctx.k_nas_int[i]);
+  }
+
+  m_s1ap->send_downlink_nas_transport(m_ecm_ctx.enb_ue_s1ap_id, m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), m_ecm_ctx.enb_sri);
+
+  if(integrity == 1 && replay == 0 && security_header_type == 2){
+    attach_accept_replay_buffer = std::move(nas_tx);
+  }
+
+  return true;
+}
+
+bool nas::handle_statelearner_query_guti_rellocation_custom(int cipher, int integrity, int replay, int security_header_type)
+{
+  if (replay == 1){
+    if (guti_reallocation_replay_buffer.get() == NULL) {
+      srsran::console("*******Replayed GUTI Reallocation request not sending!************\n");
+      return true;
+    } else {
+      // Send reply to eNB
+      m_s1ap->send_downlink_nas_transport(
+          m_ecm_ctx.enb_ue_s1ap_id, m_ecm_ctx.mme_ue_s1ap_id, guti_reallocation_replay_buffer.get(), m_ecm_ctx.enb_sri);
+
+      m_logger.info("Downlink NAS: Sending GUTI Reallocation Request Replayed\n");
+      srsran::console("Downlink NAS: Sending GUTI Reallocation Request Replayed\n");
+      return true;
+    }
+  }
+
+  if(cipher == 1 || integrity ==1){
+    if (check(&m_sec_ctx.k_nas_enc[16])) {
+      if (m_s1ap->get_mme_statelearner_reset_state() == false && m_enable_ue_state_fuzzing == true) {
+        srsran::console("********portected GUTI Reallocation Request not sending!!************\n");
+        return true;
+      }
+    }
+  }
+  srsran::unique_byte_buffer_t                 nas_tx;
+  bool                   ret = false;
+
+  nas_tx = srsran::make_byte_buffer();
+  pack_guti_reallocation_request_custom(nas_tx.get(), cipher, integrity, replay, security_header_type);
+
+  srsran::console("Downlink NAS: Sending NAS GUTI REALLOCATION Message.\n");
+  m_s1ap->send_downlink_nas_transport(m_ecm_ctx.enb_ue_s1ap_id, m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), m_ecm_ctx.enb_sri);
+
+  if(integrity == 1 && replay == 0 && security_header_type == 2){
+    guti_reallocation_replay_buffer = std::move(nas_tx);
+  }
+
+  m_logger.info("Downlink NAS: Sending GUTI REALLOCATION Request\n");
+  srsran::console("Downlink NAS: Sending GUTI REALLOCATION Request\n");
+  return true;
+}
+
+bool nas::handle_statelearner_query_dl_nas_transport_custom(int cipher, int integrity, int replay, int security_header_type)
+{
+
+  if (replay == 1){
+    if (dl_replay_buffer.get() == NULL) {
+      srsran::console("*******Replayed dl_nas_transport not sending!************\n");
+      return true;
+    } else {
+      // Send reply to eNB
+      m_s1ap->send_downlink_nas_transport(
+          m_ecm_ctx.enb_ue_s1ap_id, m_ecm_ctx.mme_ue_s1ap_id, dl_replay_buffer.get(), m_ecm_ctx.enb_sri);
+
+      m_logger.info("Downlink NAS: Sending dl_nas_transport Replayed\n");
+      srsran::console("Downlink NAS: Sending dl_nas_transport Replayed\n");
+      return true;
+    }
+  }
+
+  if(cipher == 1 || integrity == 1){
+    if (check(&m_sec_ctx.k_nas_enc[16])) {
+      if (m_s1ap->get_mme_statelearner_reset_state() == false && m_enable_ue_state_fuzzing == true) {
+        srsran::console("********portected auth_request not sending!!************\n");
+        return true;
+      }
+    }
+  }
+  srsran::unique_byte_buffer_t                 nas_tx;
+  bool                   ret = false;
+
+  nas_tx = srsran::make_byte_buffer();
+  pack_dl_nas_transport_custom(nas_tx.get(), cipher, integrity, replay, security_header_type);
+
+  m_s1ap->send_downlink_nas_transport(m_ecm_ctx.enb_ue_s1ap_id, m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), m_ecm_ctx.enb_sri);
+
+  if(integrity == 1 && replay == 0 && security_header_type == 2){
+    dl_replay_buffer = std::move(nas_tx);
+  }
+
+  m_logger.info("Downlink NAS: Sending dl_nas_transport \n");
+  srsran::console("Downlink NAS: Sending dl_nas_transport \n");
+  return true;
+}
+
+bool nas::handle_statelearner_query_service_reject_custom(int emm_cause, int security_header_type)
+{
+  srsran::unique_byte_buffer_t            nas_tx;
+  bool ret = false;
+
+  nas_tx = srsran::make_byte_buffer();
+  pack_service_reject_custom(nas_tx.get(), emm_cause, security_header_type);
+
+  // Send reply
+  m_s1ap->send_downlink_nas_transport(m_ecm_ctx.enb_ue_s1ap_id, m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), m_ecm_ctx.enb_sri);
+
+  m_logger.info("Downlink NAS: Sending Service Reject\n");
+  srsran::console("Downlink NAS: Sending Service Reject\n");
+  return true;
+}
+
+bool nas::handle_statelearner_query_attach_reject_custom(int emm_cause)
+{
+  srsran::unique_byte_buffer_t                 nas_tx;
+  bool                   ret = false;
+
+  nas_tx = srsran::make_byte_buffer();
+  pack_attach_reject_custom(nas_tx.get(), emm_cause);
+
+  // Send reply
+  m_s1ap->send_downlink_nas_transport(m_ecm_ctx.enb_ue_s1ap_id, m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), m_ecm_ctx.enb_sri);
+  return true;
+}
+
+bool nas::handle_statelearner_query_authentication_reject_custom()
+{
+  srsran::unique_byte_buffer_t                 nas_tx;
+  bool                   ret = false;
+
+  nas_tx = srsran::make_byte_buffer();
+  pack_authentication_reject(nas_tx.get());
+
+  // Send reply
+  m_s1ap->send_downlink_nas_transport(m_ecm_ctx.enb_ue_s1ap_id, m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), m_ecm_ctx.enb_sri);
+  return true;
+}
+
+// Fuzzing: pack functions
+bool nas::pack_authentication_request_custom(srsran::byte_buffer_t* nas_buffer,int cipher, int integrity, int replay, int seperation_bit, int sqn, int security_header_type)
+{
+  printf("authentication_request_custom\n");
+  m_logger.info("Packing Authentication Request\n");
+
+  // Pack NAS msg
+  LIBLTE_MME_AUTHENTICATION_REQUEST_MSG_STRUCT auth_req;
+  memcpy(auth_req.autn, m_sec_ctx.autn, 16);
+  memcpy(auth_req.rand, m_sec_ctx.rand, 16);
+  if(seperation_bit == 0){
+    auth_req.autn[6] = 0;
+    auth_req.autn[7] = 0;
+  }
+
+  auth_req.nas_ksi.tsc_flag = LIBLTE_MME_TYPE_OF_SECURITY_CONTEXT_FLAG_NATIVE;
+  auth_req.nas_ksi.nas_ksi  = m_sec_ctx.eksi;
+
+  uint8_t           sec_hdr_type = security_header_type;
+  srsran::console("2958 sec_hdr_type %d\n", sec_hdr_type);
+
+  if (integrity == 1 || integrity == 3){
+    m_sec_ctx.dl_nas_count++;
+    if (sqn == 0){
+      uint32_t value = (1 << 24) + 1;
+      LIBLTE_ERROR_ENUM err = liblte_mme_pack_authentication_request_msg_mac(
+        &auth_req, (LIBLTE_BYTE_MSG_STRUCT*)nas_buffer, sec_hdr_type, value);
+      if (err != LIBLTE_SUCCESS) {
+      m_logger.error("Error packing Authentication Request\n");
+      srsran::console("Error packing Authentication Request\n");
+      return false;
+    }
+    if(cipher == 1){
+      cipher_encrypt(nas_buffer);
+    }
+
+    uint8_t mac[4];
+    integrity_generate(nas_buffer, mac);
+    if(integrity == 3){ //for wrong mac
+      mac[0] = 0;
+      mac[1] = 0;
+      mac[2] = 0;
+      mac[3] = 0;
+    }
+    memcpy(&nas_buffer->msg[1], mac, 4);
+
+    }else{ //for sqn not out of range
+    LIBLTE_ERROR_ENUM err = liblte_mme_pack_authentication_request_msg_mac(
+        &auth_req, (LIBLTE_BYTE_MSG_STRUCT*)nas_buffer, m_sec_ctx.dl_nas_count, sec_hdr_type);
+    if (err != LIBLTE_SUCCESS) {
+      m_logger.error("Error packing Authentication Request\n");
+      srsran::console("Error packing Authentication Request\n");
+      return false;
+    }
+    if(cipher == 1){
+      cipher_encrypt(nas_buffer);
+    }
+    uint8_t mac[4];
+    integrity_generate(nas_buffer, mac);
+    memcpy(&nas_buffer->msg[1], mac, 4);}
+  }
+  else{ //for no mac
+    LIBLTE_ERROR_ENUM err = liblte_mme_pack_authentication_request_msg(
+        &auth_req, (LIBLTE_BYTE_MSG_STRUCT*)nas_buffer, sec_hdr_type);
+    if (err != LIBLTE_SUCCESS) {
+      m_logger.error("Error packing Authentication Request\n");
+      srsran::console("Error packing Authentication Request\n");
+      return false;
+    }
+    if(cipher == 1){
+      cipher_encrypt(nas_buffer);
+    }
+  }
+  return true;
+}
+
+// TODO: implement auth_parameter
+bool nas::pack_security_mode_command_custom(srsran::byte_buffer_t* nas_buffer, int cipher, int integrity, int replay, int auth_parameter, int eia, int eea, int security_header_type)
+{
+  m_logger.info("Packing Security Mode Command\n");
+
+  // Pack NAS PDU
+  LIBLTE_MME_SECURITY_MODE_COMMAND_MSG_STRUCT sm_cmd;
+  if(eia == 1){
+    sm_cmd.selected_nas_sec_algs.type_of_eia = (LIBLTE_MME_TYPE_OF_INTEGRITY_ALGORITHM_ENUM)m_sec_ctx.integ_algo;
+  } 
+  else if(eia == 2){
+    eia = rand() % 5 + 3;
+    sm_cmd.selected_nas_sec_algs.type_of_eia = (LIBLTE_MME_TYPE_OF_INTEGRITY_ALGORITHM_ENUM)eia;
+  }
+  else {
+    sm_cmd.selected_nas_sec_algs.type_of_eia = (LIBLTE_MME_TYPE_OF_INTEGRITY_ALGORITHM_ENUM)eia;
+  }
+
+  if(eea == 1){
+    sm_cmd.selected_nas_sec_algs.type_of_eea = (LIBLTE_MME_TYPE_OF_CIPHERING_ALGORITHM_ENUM)m_sec_ctx.cipher_algo;
+  } 
+  else if(eea == 2){
+    eea = rand() % 5 + 3;
+    sm_cmd.selected_nas_sec_algs.type_of_eea = (LIBLTE_MME_TYPE_OF_CIPHERING_ALGORITHM_ENUM)eea;
+  }
+  else {
+    sm_cmd.selected_nas_sec_algs.type_of_eea = (LIBLTE_MME_TYPE_OF_CIPHERING_ALGORITHM_ENUM)eea;
+  }
+
+  
+  sm_cmd.nas_ksi.tsc_flag = LIBLTE_MME_TYPE_OF_SECURITY_CONTEXT_FLAG_NATIVE;
+  sm_cmd.nas_ksi.nas_ksi  = m_sec_ctx.eksi;
+
+  // Replay UE security cap
+  memcpy(sm_cmd.ue_security_cap.eea, m_sec_ctx.ue_network_cap.eea, 8 * sizeof(bool));
+  memcpy(sm_cmd.ue_security_cap.eia, m_sec_ctx.ue_network_cap.eia, 8 * sizeof(bool));
+
+  sm_cmd.ue_security_cap.uea_present = m_sec_ctx.ue_network_cap.uea_present;
+  memcpy(sm_cmd.ue_security_cap.uea, m_sec_ctx.ue_network_cap.uea, 8 * sizeof(bool));
+
+  sm_cmd.ue_security_cap.uia_present = m_sec_ctx.ue_network_cap.uia_present;
+  memcpy(sm_cmd.ue_security_cap.uia, m_sec_ctx.ue_network_cap.uia, 8 * sizeof(bool));
+
+  sm_cmd.ue_security_cap.gea_present = m_sec_ctx.ms_network_cap_present;
+  memcpy(sm_cmd.ue_security_cap.gea, m_sec_ctx.ms_network_cap.gea, 8 * sizeof(bool));
+
+  sm_cmd.imeisv_req_present = false;
+  sm_cmd.nonce_ue_present   = false;
+  sm_cmd.nonce_mme_present  = false;
+
+  uint8_t sec_hdr_type = security_header_type;
+
+  if(integrity == 1||integrity == 3){
+      LIBLTE_ERROR_ENUM err          = liblte_mme_pack_security_mode_command_msg_mac(
+      &sm_cmd, sec_hdr_type, m_sec_ctx.dl_nas_count, (LIBLTE_BYTE_MSG_STRUCT*)nas_buffer);
+    if (err != LIBLTE_SUCCESS) {
+      srsran::console("Error packing security_mode_command\n");
+      return false;
+    }
+  }else{
+      LIBLTE_ERROR_ENUM err          = liblte_mme_pack_security_mode_command_msg(
+      &sm_cmd, sec_hdr_type, m_sec_ctx.dl_nas_count, (LIBLTE_BYTE_MSG_STRUCT*)nas_buffer);
+      if (err != LIBLTE_SUCCESS) {
+      srsran::console("Error packing security_mode_command\n");
+      return false;
+    }
+  }
+
+
+  // Generate EPS security context
+  srsran::security_generate_k_nas(
+      m_sec_ctx.k_asme, m_sec_ctx.cipher_algo, m_sec_ctx.integ_algo, m_sec_ctx.k_nas_enc, m_sec_ctx.k_nas_int);
+
+  m_logger.info(m_sec_ctx.k_nas_enc, 32, "Key NAS Encryption (k_nas_enc)\n");
+  m_logger.info(m_sec_ctx.k_nas_int, 32, "Key NAS Integrity (k_nas_int)\n");
+
+  if (m_enable_ue_state_fuzzing == false) {
+    uint8_t key_enb[32];
+    srsran::security_generate_k_enb(m_sec_ctx.k_asme, m_sec_ctx.ul_nas_count, m_sec_ctx.k_enb);
+    m_logger.info("Generating KeNB with UL NAS COUNT: %d\n", m_sec_ctx.ul_nas_count);
+    srsran::console("Generating KeNB with UL NAS COUNT: %d\n", m_sec_ctx.ul_nas_count);
+    m_logger.info(m_sec_ctx.k_enb, 32, "Key eNodeB (k_enb)\n");
+  }
+
+
+  if(cipher == 1){
+    cipher_encrypt(nas_buffer);
+  }
+  else if(cipher == 2){
+    cipher_encrypt_null(nas_buffer);
+  }
+
+  if(integrity == 0){
+      uint8_t mac[4];
+      mac[0] = 0;
+      mac[1] = 0;
+      mac[2] = 0;
+      mac[3] = 0;
+      memcpy(&nas_buffer->msg[1], mac, 4);
+  }
+
+  if(integrity == 1 || integrity == 3){
+    // Generate MAC for integrity protection
+
+    uint8_t mac[4];
+    integrity_generate(nas_buffer, mac);
+    if(integrity == 3){
+      mac[0] = 0;
+      mac[1] = 0;
+      mac[2] = 0;
+      mac[3] = 0;
+    }
+    memcpy(&nas_buffer->msg[1], mac, 4);
+  }
+ 
+  return true;
+}
+
+int gflag = 1;
+
+bool nas::pack_guti_reallocation_request_custom(srsran::byte_buffer_t* nas_buffer, int cipher, int integrity, int replay, int security_header_type)
+{
+  m_logger.info("Packing GUTI Reallocation Request\n");
+
+  LIBLTE_MME_GUTI_REALLOCATION_COMMAND_MSG_STRUCT                   guti_reallocation_request;
+  LIBLTE_MME_ACTIVATE_DEFAULT_EPS_BEARER_CONTEXT_REQUEST_MSG_STRUCT act_def_eps_bearer_context_req;
+
+  // Get decimal MCC and MNC
+  uint32_t mcc = 0;
+  mcc += 0x000F & m_mcc;
+  mcc += 10 * ((0x00F0 & m_mcc) >> 4);
+  mcc += 100 * ((0x0F00 & m_mcc) >> 8);
+
+  uint32_t mnc = 0;
+  if (0xFF00 == (m_mnc & 0xFF00)) {
+    // Two digit MNC
+    mnc += 0x000F & m_mnc;
+    mnc += 10 * ((0x00F0 & m_mnc) >> 4);
+  } else {
+    // Three digit MNC
+    mnc += 0x000F & m_mnc;
+    mnc += 10 * ((0x00F0 & m_mnc) >> 4);
+    mnc += 100 * ((0x0F00 & m_mnc) >> 8);
+  }
+
+  guti_reallocation_request.tai_list_present    = true;
+  guti_reallocation_request.tai_list.N_tais     = 1;
+  guti_reallocation_request.tai_list.tai[0].mcc = mcc;
+  guti_reallocation_request.tai_list.tai[0].mnc = mnc;
+  guti_reallocation_request.tai_list.tai[0].tac = m_tac;
+
+  // Allocate a GUTI ot the UE
+  guti_reallocation_request.guti.type_of_id        = 6; // 110 -> GUTI
+  guti_reallocation_request.guti.guti.mcc          = mcc;
+  guti_reallocation_request.guti.guti.mnc          = mnc;
+  guti_reallocation_request.guti.guti.mme_group_id = m_mme_group;
+  guti_reallocation_request.guti.guti.mme_code     = m_mme_code;
+  guti_reallocation_request.guti.guti.m_tmsi       = m_s1ap->allocate_m_tmsi(m_emm_ctx.imsi);
+
+  memcpy(&m_sec_ctx.guti, &guti_reallocation_request.guti, sizeof(LIBLTE_MME_EPS_MOBILE_ID_GUTI_STRUCT));
+
+  
+  uint8_t sec_hdr_type = security_header_type;
+  if (integrity == 1 || integrity == 3){
+    m_sec_ctx.dl_nas_count++;
+  }
+  gflag++;
+
+  if(integrity == 1 || integrity == 3){
+    liblte_mme_pack_guti_reallocation_command_msg_mac(
+        &guti_reallocation_request, sec_hdr_type, m_sec_ctx.dl_nas_count, (LIBLTE_BYTE_MSG_STRUCT*)nas_buffer);
+  }else{
+    liblte_mme_pack_guti_reallocation_command_msg(
+        &guti_reallocation_request, sec_hdr_type, m_sec_ctx.dl_nas_count, (LIBLTE_BYTE_MSG_STRUCT*)nas_buffer);
+  }
+
+
+  if(cipher == 1){
+    cipher_encrypt(nas_buffer);
+  }
+  
+  if(integrity == 1 || integrity == 3){
+    // Generate MAC for integrity protection
+
+    uint8_t mac[4];
+    integrity_generate(nas_buffer, mac);
+    if(integrity == 3){
+      mac[0] = 0;
+      mac[1] = 0;
+      mac[2] = 0;
+      mac[3] = 0;
+    }
+    memcpy(&nas_buffer->msg[1], mac, 4);
+  }
+  // Log attach accept info
+  srsran::console("Packed GUTI Reallocation request\n");
+  printf("dl_nas_count for GUTI Reallocation: %d\n",m_sec_ctx.dl_nas_count);
+  return true;
+}
+
+bool nas::pack_identity_request_custom(srsran::byte_buffer_t* nas_buffer, int cipher, int integrity, int replay, int identification_parameter, int security_header_type)
+{
+  m_logger.info("Packing Identity Request\n");
+
+  LIBLTE_MME_ID_REQUEST_MSG_STRUCT id_req;
+  if(identification_parameter == 0)
+    id_req.id_type        = LIBLTE_MME_ID_TYPE_2_IMEI;
+  else if(identification_parameter == 1)
+    id_req.id_type        = LIBLTE_MME_ID_TYPE_2_IMSI;
+  else if(identification_parameter == 2)
+    id_req.id_type        = LIBLTE_MME_ID_TYPE_2_IMEISV;
+  else if(identification_parameter == 3)
+    id_req.id_type        = LIBLTE_MME_ID_TYPE_2_TMSI;
+  
+  uint8_t           sec_hdr_type = security_header_type;
+
+  if(integrity == 1 || integrity == 3){
+    m_sec_ctx.dl_nas_count++;
+    LIBLTE_ERROR_ENUM err          = liblte_mme_pack_identity_request_msg_mac(
+        &id_req, (LIBLTE_BYTE_MSG_STRUCT*)nas_buffer, m_sec_ctx.dl_nas_count, sec_hdr_type);
+    if (err != LIBLTE_SUCCESS) {
+      m_logger.error("Error packing Identity Request\n");
+      srsran::console("Error packing Identity REquest\n");
+      return false;
+    }
+    if(cipher == 1){
+      cipher_encrypt(nas_buffer);
+    }
+
+    uint8_t mac[4];
+    integrity_generate(nas_buffer, mac);
+    if(integrity == 3){ //for wrong mac
+      mac[0] = 0;
+      mac[1] = 0;
+      mac[2] = 0;
+      mac[3] = 0;
+    }
+    memcpy(&nas_buffer->msg[1], mac, 4);
+
+
+  }
+  else{
+    LIBLTE_ERROR_ENUM err = liblte_mme_pack_identity_request_msg(&id_req, (LIBLTE_BYTE_MSG_STRUCT*)nas_buffer);
+    if (err != LIBLTE_SUCCESS) {
+      m_logger.error("Error packing Identity Request\n");
+      srsran::console("Error packing Identity REquest\n");
+      return false;
+    }
+    if(cipher == 1){
+      cipher_encrypt(nas_buffer);
+    }
+  }
+ 
+  return true;
+}
+
+bool nas::pack_dl_nas_transport_custom(srsran::byte_buffer_t* nas_buffer, int cipher, int integrity, int replay, int security_header_type)
+{
+  m_logger.info("Packing DL NAS Transport Request\n");
+
+  LIBLTE_MME_DOWNLINK_NAS_TRANSPORT_MSG_STRUCT dl_nas_transport;
+  int                                          size = 35;
+  uint8_t                                      msg[size];
+  msg[0] = 0x9;
+  printf("Timestamp: %d\n", (int)time(NULL));
+  int t  = (int)time(NULL);
+  msg[1] = 0x0001;
+  msg[2] = 0x20;
+  msg[3] = 0x1;
+  msg[4] = 0x1;
+  msg[5] = 0x7;
+  msg[6] = 0x91;
+  msg[7]  = 0x21;
+  msg[8]  = 0x60;
+  msg[9]  = 0x13;
+  msg[10] = 0x03;
+  msg[11] = 0x50;
+  msg[12] = 0xf7;
+  msg[13] = 0x0;
+  msg[14] = 0x14;
+  msg[15] = 0x04;
+  msg[16] = 0xb;
+  msg[17] = 0x11;
+  msg[18] = 0x71;
+  msg[19] = 0x56;
+  msg[20] = 0x04;
+  msg[21] = 0x79;
+  msg[22] = 0x30;
+  msg[23] = 0xf8;
+  msg[24] = 0x0;
+  msg[25] = 0x0;
+  msg[26] = 0x91;
+  msg[27] = 0x90;
+  msg[28] = 0x82;
+  msg[29] = 0x10;
+  msg[30] = 0x45;
+  msg[31] = 0x11;
+  msg[32] = 0xa;
+  msg[33] = 0x1;
+  msg[34] = '1';
+
+  dl_nas_transport.nas_msg.N_bytes = size;
+  memcpy(&dl_nas_transport.nas_msg.msg, msg, size);
+  // liblte_mme_pack_nas_message_container_ie(&dl_nas_transport.nas_msg, &msg);
+  uint8_t sec_hdr_type = security_header_type;
+
+  if (integrity == 1 || integrity == 3){
+    m_sec_ctx.dl_nas_count++;
+  }
+
+
+  if(integrity == 1 || integrity == 3){
+    LIBLTE_ERROR_ENUM err = liblte_mme_pack_downlink_nas_transport_msg_mac(
+        &dl_nas_transport, sec_hdr_type, m_sec_ctx.dl_nas_count, (LIBLTE_BYTE_MSG_STRUCT*)nas_buffer);
+  }else{
+    LIBLTE_ERROR_ENUM err = liblte_mme_pack_downlink_nas_transport_msg(
+        &dl_nas_transport, sec_hdr_type, m_sec_ctx.dl_nas_count, (LIBLTE_BYTE_MSG_STRUCT*)nas_buffer);
+  }
+
+
+  if(cipher == 1){
+    cipher_encrypt(nas_buffer);
+  }
+  
+  if(integrity == 1 || integrity == 3){
+    // Generate MAC for integrity protection
+
+    uint8_t mac[4];
+    integrity_generate(nas_buffer, mac);
+    if(integrity == 3){
+      mac[0] = 0;
+      mac[1] = 0;
+      mac[2] = 0;
+      mac[3] = 0;
+    }
+    memcpy(&nas_buffer->msg[1], mac, 4);
+  }
+
+
+
+  // if (err != LIBLTE_SUCCESS) {
+  //   m_logger.error("Error packing dl_nas_transport\n");
+  //   srsran::console("Error packing dl_nas_transport\n");
+  //   return false;
+  // }
+
+
+  return true;
+}
+
+
+bool nas::pack_detach_request(srsran::byte_buffer_t* nas_buffer)
+{
+  LIBLTE_MME_DETACH_REQUEST_NET_MSG_STRUCT detach_req;
+  detach_req.detach_type.type_of_detach = LIBLTE_MME_TOD_DL_REATTACH_REQUIRED;
+  detach_req.detach_type.switch_off     = 0; // The network shall set this bit to zero
+
+  uint8_t sec_hdr_type = LIBLTE_MME_SECURITY_HDR_TYPE_INTEGRITY_AND_CIPHERED;
+  m_sec_ctx.dl_nas_count++;
+  LIBLTE_ERROR_ENUM err = liblte_mme_pack_detach_request_net_msg(
+      &detach_req, sec_hdr_type, m_sec_ctx.dl_nas_count, (LIBLTE_BYTE_MSG_STRUCT*)nas_buffer);
+  if (err != LIBLTE_SUCCESS) {
+    // m_nas_log->error("Error packing Detach Request (UE terminated)\n");
+    // m_nas_log->console("Error packing Detach Request (UE terminated)\n");
+    return false;
+  }
+
+  // Encrypt NAS message
+  cipher_encrypt(nas_buffer);
+
+  // Integrity protect NAS message
+  uint8_t mac[4];
+  integrity_generate(nas_buffer, mac);
+  memcpy(&nas_buffer->msg[1], mac, 4);
+
+  return true;
+}
+
+bool nas::pack_attach_accept_custom(srsran::byte_buffer_t* nas_buffer, int cipher, int integrity, int replay, int security_header_type)
+{
+  m_logger.info("Packing Attach Accept\n");
+
+  LIBLTE_MME_ATTACH_ACCEPT_MSG_STRUCT                               attach_accept;
+  LIBLTE_MME_ACTIVATE_DEFAULT_EPS_BEARER_CONTEXT_REQUEST_MSG_STRUCT act_def_eps_bearer_context_req;
+
+  // Get decimal MCC and MNC
+  uint32_t mcc = 0;
+  mcc += 0x000F & m_mcc;
+  mcc += 10 * ((0x00F0 & m_mcc) >> 4);
+  mcc += 100 * ((0x0F00 & m_mcc) >> 8);
+
+  uint32_t mnc = 0;
+  if (0xFF00 == (m_mnc & 0xFF00)) {
+    // Two digit MNC
+    mnc += 0x000F & m_mnc;
+    mnc += 10 * ((0x00F0 & m_mnc) >> 4);
+  } else {
+    // Three digit MNC
+    mnc += 0x000F & m_mnc;
+    mnc += 10 * ((0x00F0 & m_mnc) >> 4);
+    mnc += 100 * ((0x0F00 & m_mnc) >> 8);
+  }
+
+  // Attach accept
+  attach_accept.eps_attach_result = m_emm_ctx.attach_type;
+
+  attach_accept.t3412.unit  = LIBLTE_MME_GPRS_TIMER_UNIT_1_MINUTE; // GPRS 1 minute unit
+  attach_accept.t3412.value = 30;                                  // 30 minute periodic timer
+
+  attach_accept.tai_list.N_tais     = 1;
+  attach_accept.tai_list.tai[0].mcc = mcc;
+  attach_accept.tai_list.tai[0].mnc = mnc;
+  attach_accept.tai_list.tai[0].tac = m_tac;
+
+  m_logger.info("Attach Accept -- MCC 0x%x, MNC 0x%x\n", m_mcc, m_mnc);
+
+  // Allocate a GUTI ot the UE
+  attach_accept.guti_present           = true;
+  attach_accept.guti.type_of_id        = 6; // 110 -> GUTI
+  attach_accept.guti.guti.mcc          = mcc;
+  attach_accept.guti.guti.mnc          = mnc;
+  attach_accept.guti.guti.mme_group_id = m_mme_group;
+  attach_accept.guti.guti.mme_code     = m_mme_code;
+  attach_accept.guti.guti.m_tmsi       = m_s1ap->allocate_m_tmsi(m_emm_ctx.imsi);
+  m_logger.debug("Allocated GUTI: MCC %d, MNC %d, MME Group Id %d, MME Code 0x%x, M-TMSI 0x%x\n",
+                   attach_accept.guti.guti.mcc,
+                   attach_accept.guti.guti.mnc,
+                   attach_accept.guti.guti.mme_group_id,
+                   attach_accept.guti.guti.mme_code,
+                   attach_accept.guti.guti.m_tmsi);
+
+  memcpy(&m_sec_ctx.guti, &attach_accept.guti, sizeof(LIBLTE_MME_EPS_MOBILE_ID_GUTI_STRUCT));
+
+  // Set up LAI for combined EPS/IMSI attach
+  attach_accept.lai_present = true;
+  attach_accept.lai.mcc     = mcc;
+  attach_accept.lai.mnc     = mnc;
+  attach_accept.lai.lac     = 001;
+
+  attach_accept.ms_id_present    = true;
+  attach_accept.ms_id.type_of_id = LIBLTE_MME_MOBILE_ID_TYPE_TMSI;
+  attach_accept.ms_id.tmsi       = attach_accept.guti.guti.m_tmsi;
+
+  // Make sure all unused options are set to false
+  attach_accept.emm_cause_present                   = false;
+  attach_accept.t3402_present                       = false;
+  attach_accept.t3423_present                       = false;
+  attach_accept.equivalent_plmns_present            = false;
+  attach_accept.emerg_num_list_present              = false;
+  attach_accept.eps_network_feature_support_present = false;
+  attach_accept.additional_update_result_present    = false;
+  attach_accept.t3412_ext_present                   = false;
+
+  // Set activate default eps bearer (esm_ms)
+  // Set pdn_addr
+  act_def_eps_bearer_context_req.pdn_addr.pdn_type = LIBLTE_MME_PDN_TYPE_IPV4;
+  memcpy(act_def_eps_bearer_context_req.pdn_addr.addr, &m_emm_ctx.ue_ip.s_addr, 4);
+  // Set eps bearer id
+  act_def_eps_bearer_context_req.eps_bearer_id          = 5;
+  act_def_eps_bearer_context_req.transaction_id_present = false;
+  // set eps_qos
+  act_def_eps_bearer_context_req.eps_qos.qci            = m_esm_ctx[5].qci;
+  act_def_eps_bearer_context_req.eps_qos.br_present     = false;
+  act_def_eps_bearer_context_req.eps_qos.br_ext_present = false;
+
+  // set apn
+  strncpy(act_def_eps_bearer_context_req.apn.apn, m_apn.c_str(), LIBLTE_STRING_LEN - 1);
+  act_def_eps_bearer_context_req.proc_transaction_id = m_emm_ctx.procedure_transaction_id;
+
+  // Set DNS server
+  act_def_eps_bearer_context_req.protocol_cnfg_opts_present    = true;
+  act_def_eps_bearer_context_req.protocol_cnfg_opts.N_opts     = 1;
+  act_def_eps_bearer_context_req.protocol_cnfg_opts.opt[0].id  = 0x0d;
+  act_def_eps_bearer_context_req.protocol_cnfg_opts.opt[0].len = 4;
+
+  struct sockaddr_in dns_addr;
+  inet_pton(AF_INET, m_dns.c_str(), &(dns_addr.sin_addr));
+  memcpy(act_def_eps_bearer_context_req.protocol_cnfg_opts.opt[0].contents, &dns_addr.sin_addr.s_addr, 4);
+
+  // Make sure all unused options are set to false
+  act_def_eps_bearer_context_req.negotiated_qos_present    = false;
+  act_def_eps_bearer_context_req.llc_sapi_present          = false;
+  act_def_eps_bearer_context_req.radio_prio_present        = false;
+  act_def_eps_bearer_context_req.packet_flow_id_present    = false;
+  act_def_eps_bearer_context_req.apn_ambr_present          = false;
+  act_def_eps_bearer_context_req.esm_cause_present         = false;
+  act_def_eps_bearer_context_req.connectivity_type_present = false;
+
+  uint8_t sec_hdr_type = security_header_type;
+  if (integrity ==1 || integrity == 3){
+    m_sec_ctx.dl_nas_count++;
+  }
+  liblte_mme_pack_activate_default_eps_bearer_context_request_msg(&act_def_eps_bearer_context_req,
+                                                                  &attach_accept.esm_msg);
+
+  if(integrity == 1 || integrity == 3){
+      liblte_mme_pack_attach_accept_msg_mac(
+      &attach_accept, sec_hdr_type, m_sec_ctx.dl_nas_count, (LIBLTE_BYTE_MSG_STRUCT*)nas_buffer);
+  }else{
+      liblte_mme_pack_attach_accept_msg( //no mac
+      &attach_accept, sec_hdr_type, m_sec_ctx.dl_nas_count, (LIBLTE_BYTE_MSG_STRUCT*)nas_buffer);
+  }
+
+  if(cipher == 1){
+    cipher_encrypt(nas_buffer);
+  }
+  // else if(cipher == 2){
+  //   cipher_encrypt_null(nas_buffer);
+  // }
+  
+  if(integrity == 1){
+    // Generate MAC for integrity protection
+    uint8_t mac[4];
+    integrity_generate(nas_buffer, mac);
+    memcpy(&nas_buffer->msg[1], mac, 4);
+  } else if(integrity == 3){
+      uint8_t mac[4];
+      mac[0] = 0;
+      mac[1] = 0;
+      mac[2] = 0;
+      mac[3] = 0;
+      memcpy(&nas_buffer->msg[1], mac, 4);
+    }
+
+
+  // Log attach accept info
+  m_logger.info("Packed Attach Accept\n");
+  return true;
+}
+
+// TODO: implement integrity
+bool nas::pack_service_reject_custom(srsran::byte_buffer_t* nas_buffer, uint8_t emm_cause, int security_header_type)
+{
+  LIBLTE_MME_SERVICE_REJECT_MSG_STRUCT service_rej;
+  service_rej.t3442_present = true;
+  service_rej.t3442.unit    = LIBLTE_MME_GPRS_TIMER_DEACTIVATED;
+  service_rej.t3442.value   = 0;
+  service_rej.t3446_present = true;
+  service_rej.t3446         = 0;
+  service_rej.emm_cause     = emm_cause;
+
+  uint8_t sec_hdr_type = security_header_type;
+  LIBLTE_ERROR_ENUM err = liblte_mme_pack_service_reject_msg(
+      &service_rej, sec_hdr_type, 0, (LIBLTE_BYTE_MSG_STRUCT*)nas_buffer);
+  if (err != LIBLTE_SUCCESS) {
+    m_logger.error("Error packing Service Reject\n");
+    srsran::console("Error packing Service Reject\n");
+    return false;
+  }
+  return true;
+}
+
+bool nas::pack_attach_reject_custom(srsran::byte_buffer_t* nas_buffer, uint8_t emm_cause)
+{
+
+  m_logger.info("Packing Attach Reject\n");
+
+  LIBLTE_MME_ATTACH_REJECT_MSG_STRUCT attach_rej;
+  attach_rej.emm_cause           = emm_cause;
+  attach_rej.esm_msg_present     = false;
+  attach_rej.t3446_value_present = false;
+
+  LIBLTE_ERROR_ENUM err = liblte_mme_pack_attach_reject_msg(&attach_rej, (LIBLTE_BYTE_MSG_STRUCT*)nas_buffer);
+
+  if (err != LIBLTE_SUCCESS) {
+    m_logger.error("Error packing Attach Reject\n");
+    return false;
+  }
+  return true;
+}
+
+bool nas::handle_statelearner_query_emm_information()
+{
+  srsran::unique_byte_buffer_t  nas_tx;
+
+  nas_tx = srsran::make_byte_buffer();
+
+  pack_emm_information(nas_tx.get());
+  m_s1ap->send_downlink_nas_transport(m_ecm_ctx.enb_ue_s1ap_id, m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), m_ecm_ctx.enb_sri);
+
+  return true;
+}
+
+bool nas::handle_statelearner_query_reset_attach_accept_setup()
+{
+  msg_type_global = FUZZING_MSG_TYPE_EOL;
+  return true;
+}
+
+bool nas::handle_statelearner_query_authentication_request()
+{
+
+  srsran::unique_byte_buffer_t  nas_tx;
+  // Get Authentication Vectors from HSS
+  
+  if (!m_hss->gen_auth_info_answer(
+      m_emm_ctx.imsi, m_sec_ctx.k_asme_tmp, m_sec_ctx.autn, m_sec_ctx.rand, m_sec_ctx.xres)) {
+    srsran::console("User not found. IMSI %015" PRIu64 "\n", m_emm_ctx.imsi);
+    m_logger.info("User not found. IMSI %015" PRIu64 "\n", m_emm_ctx.imsi);
+    return false;
+  }
+
+  // Allocate eKSI for this authentication vector
+  // Here we assume a new security context thus a new eKSI
+  m_sec_ctx.eksi = 0;
+
+  // Save the UE context
+  m_s1ap->add_nas_ctx_to_imsi_map(this);
+  m_s1ap->add_nas_ctx_to_mme_ue_s1ap_id_map(this);
+  m_s1ap->add_ue_to_enb_set(m_ecm_ctx.enb_sri.sinfo_assoc_id, m_ecm_ctx.mme_ue_s1ap_id);
+
+  // Pack NAS Authentication Request in Downlink NAS Transport msg
+  nas_tx = srsran::make_byte_buffer();
+
+  pack_authentication_request(nas_tx.get());
+
+  // Send reply to eNB
+  m_s1ap->send_downlink_nas_transport(m_ecm_ctx.enb_ue_s1ap_id, m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), m_ecm_ctx.enb_sri);
+  
+  auth_replay_buffer = std::move(nas_tx);
+
+  m_logger.info("Downlink NAS: Sending Authentication Request\n");
+  srsran::console("Downlink NAS: Sending Authentication Request\n");
+  return true;
+}
+
+bool nas::handle_statelearner_query_security_mode_command()
+{
+
+  srsran::unique_byte_buffer_t  nas_tx;
+  bool                          ret = false;
+
+  nas_tx                 = srsran::make_byte_buffer();
+  m_sec_ctx.dl_nas_count = 0; // Reset the NAS uplink counter for the right key k_enb derivation
+  pack_security_mode_command(nas_tx.get());
+
+  m_s1ap->send_downlink_nas_transport(m_ecm_ctx.enb_ue_s1ap_id, m_ecm_ctx.mme_ue_s1ap_id, nas_tx.get(), m_ecm_ctx.enb_sri);
+
+  smd_replay_buffer = std::move(nas_tx);
+  return true;
+}
+
 } // namespace srsepc
diff --git a/srsepc/src/mme/parse_cmd.cc b/srsepc/src/mme/parse_cmd.cc
new file mode 100755
index 000000000..8b5a2abfa
--- /dev/null
+++ b/srsepc/src/mme/parse_cmd.cc
@@ -0,0 +1,554 @@
+// //
+// // Created by ishtiaq on 9/19/23.
+// //
+
+#include "srsepc/hdr/mme/nas.h"
+// message_parser.cc
+
+#include "srsepc/hdr/mme/parse_cmd.h"
+#include <string>
+#include <unistd.h>
+#include <sstream>
+#include <iostream>
+#include <cstring>
+#include <cstdint>
+#include <algorithm>
+
+Message parseMessage(const uint8_t *data, size_t length) {
+    Message message = {};  // Zero-initialize the struct
+    std::string input(data, data + length);  // Convert uint8_t* to std::string
+    std::stringstream ss(input);
+
+    // Parse the message name
+    std::string temp;
+    std::getline(ss, temp, ':');
+    if (ss.fail() || temp.empty()) {
+        std::cerr << "Debug: Missing ':' or message name." << std::endl;
+        return message;  // Return an empty message
+    }
+
+    strncpy(message.messageName, temp.c_str(), sizeof(message.messageName) - 1);  // Copy message name with safety
+
+    // If the right side is missing or only contains spaces, just return the message with the name
+    if (ss.peek() == EOF || std::all_of(std::istreambuf_iterator<char>(ss), std::istreambuf_iterator<char>(), ::isspace)) {
+        return message;  // Return message with only the name
+    }
+
+    // Parse each field-value pair
+    std::string fieldStr;
+    while (std::getline(ss, fieldStr, '&') && message.numberOfFields < 10) {
+        MessageField field = {};  // Zero-initialize
+        
+        // Clean up spaces
+        fieldStr = fieldStr.substr(fieldStr.find_first_not_of(' '), fieldStr.find_last_not_of(' ') - fieldStr.find_first_not_of(' ') + 1);
+
+        // Split the fieldStr into name and value using "==" as delimiter
+        size_t delimiterPos = fieldStr.find("==");
+        if (delimiterPos == std::string::npos) {
+            std::cerr << "Debug: Missing '==' in field definition: " << fieldStr << std::endl;
+            continue;  // Skip this field and continue with the next
+        }
+        // Extract and trim field name and value
+        std::string fieldName = fieldStr.substr(0, delimiterPos);
+        fieldName = fieldName.substr(fieldName.find_first_not_of(' '), fieldName.find_last_not_of(' ') - fieldName.find_first_not_of(' ') + 1);
+        strncpy(field.messageFieldName, fieldName.c_str(), sizeof(field.messageFieldName) - 1);  // Copy field name with safety
+
+        std::string valueStr = fieldStr.substr(delimiterPos + 2);
+        field.messageFieldValue = std::stoi(valueStr.substr(valueStr.find_first_not_of(' ')));
+
+        message.messageFields[message.numberOfFields] = field;
+        message.numberOfFields++;
+    }
+    return message;
+}
+
+
+
+void printMessage(const Message& message) {
+    std::cout << "Message Name: " << message.messageName << std::endl;
+    
+    for (int i = 0; i < message.numberOfFields; i++) {
+        std::cout << "\tField Name: " << message.messageFields[i].messageFieldName 
+                  << " Value: " << message.messageFields[i].messageFieldValue << std::endl;
+    }
+}
+
+void handleMessageCmd(Message message, srsepc::nas* myNasInstance){
+    bool ret = false;
+    // example access to parse dmessage
+    if(strcmp(message.messageName, "authentication_request") == 0){
+        int cipher = 0;
+        int integrity = 0;
+        int replay = 0;
+        int separation_bit = 1;
+        int sqn = 0;
+        int security_header_type = 0;
+
+        
+
+        for(int i=0; i<message.numberOfFields; i++){
+            if (strcmp(message.messageFields[i].messageFieldName, "cipher") == 0) {
+                cipher = message.messageFields[i].messageFieldValue;
+            }
+            else if(strcmp(message.messageFields[i].messageFieldName, "integrity") == 0){
+                integrity =  message.messageFields[i].messageFieldValue;
+            }
+            else if(strcmp(message.messageFields[i].messageFieldName, "replay") == 0){
+                replay =  message.messageFields[i].messageFieldValue;
+            }
+            else if(strcmp(message.messageFields[i].messageFieldName, "separation_bit") == 0){
+                separation_bit =  message.messageFields[i].messageFieldValue;
+            }
+            else if(strcmp(message.messageFields[i].messageFieldName, "sqn") == 0){
+                sqn =  message.messageFields[i].messageFieldValue;
+            }
+            else if(strcmp(message.messageFields[i].messageFieldName, "security_header_type") == 0){
+                security_header_type =  message.messageFields[i].messageFieldValue;
+                if (security_header_type == 4) {
+                    security_header_type = 5 + rand()%11;
+                }
+            }
+        }
+        std::cout << "cipher: " << cipher << std::endl;
+        std::cout << "integrity: " << integrity << std::endl;
+        std::cout << "replay: " << replay << std::endl;
+        std::cout << "separation_bit: " << separation_bit << std::endl;
+        std::cout << "sqn: " << sqn << std::endl;
+        std::cout << "security_header_type: " << security_header_type << std::endl;
+
+        ret = myNasInstance->handle_statelearner_query_authentication_request_custom(integrity, integrity, replay, separation_bit, sqn, security_header_type);
+    }
+     else if(strcmp(message.messageName, "auth_request_plain_text") == 0){
+        ret = myNasInstance->handle_statelearner_query_authentication_request();
+    }
+    else if(strcmp(message.messageName, "identity_request") == 0){
+        int cipher = 0;
+        int integrity = 0;
+        int replay = 0;
+        int identity_type = 1;
+        int security_header_type = 0;
+ 
+
+        for(int i=0; i<message.numberOfFields; i++){
+            if(strcmp(message.messageFields[i].messageFieldName, "cipher") == 0){
+                cipher = message.messageFields[i].messageFieldValue;
+            }
+            else if(strcmp(message.messageFields[i].messageFieldName, "integrity") == 0){
+                integrity = message.messageFields[i].messageFieldValue;
+            }
+            else if(strcmp(message.messageFields[i].messageFieldName, "replay") == 0){
+                replay = message.messageFields[i].messageFieldValue;
+            }
+            else if(strcmp(message.messageFields[i].messageFieldName, "identity_type") == 0){
+                identity_type = message.messageFields[i].messageFieldValue;
+            }
+            else if(strcmp(message.messageFields[i].messageFieldName, "security_header_type") == 0){
+                security_header_type = message.messageFields[i].messageFieldValue;
+                if (security_header_type == 4) {
+                    security_header_type = 5 + rand()%11;
+                }
+            }
+        }
+
+        ret = myNasInstance->handle_statelearner_query_identity_request_custom(cipher, integrity, replay, identity_type, security_header_type);
+    }
+    else if(strcmp(message.messageName, "security_mode_command") == 0){
+        int cipher = 0;
+        int integrity = 1;
+        int replay = 0;
+        int auth_parameter = 1;
+        int EIA = 1;
+        int EEA = 1;
+        int security_header_type = 3;
+ 
+
+        for(int i=0; i<message.numberOfFields; i++){
+            if(strcmp(message.messageFields[i].messageFieldName, "cipher") == 0){
+                cipher = message.messageFields[i].messageFieldValue;
+            }
+            else if(strcmp(message.messageFields[i].messageFieldName, "integrity") == 0){
+                integrity = message.messageFields[i].messageFieldValue;
+            }
+            else if(strcmp(message.messageFields[i].messageFieldName, "replay") == 0){
+                replay = message.messageFields[i].messageFieldValue;
+            }
+            else if(strcmp(message.messageFields[i].messageFieldName, "auth_parameter") == 0){
+                auth_parameter = message.messageFields[i].messageFieldValue;
+            }
+            else if(strcmp(message.messageFields[i].messageFieldName, "EIA") == 0){
+                EIA = message.messageFields[i].messageFieldValue;
+            }
+            else if(strcmp(message.messageFields[i].messageFieldName, "EEA") == 0){
+                EEA = message.messageFields[i].messageFieldValue;
+            }
+            else if(strcmp(message.messageFields[i].messageFieldName, "security_header_type") == 0){
+                security_header_type = message.messageFields[i].messageFieldValue;
+                if (security_header_type == 4) {
+                    security_header_type = 5 + rand()%11;
+                }
+            }
+        }
+
+        ret = myNasInstance->handle_statelearner_query_security_mode_command_custom(cipher, integrity, replay, auth_parameter, EIA, EEA, security_header_type);
+    }
+    else if(strcmp(message.messageName, "attach_accept") == 0){
+        int cipher = 1;
+        int integrity = 1;
+        int replay = 0;
+        int security_header_type = 2;
+
+        printf("received attach_accept!\n");
+ 
+
+        for(int i=0; i<message.numberOfFields; i++){
+            if(strcmp(message.messageFields[i].messageFieldName, "cipher") == 0){
+                cipher = message.messageFields[i].messageFieldValue;
+            }
+            else if(strcmp(message.messageFields[i].messageFieldName, "integrity") == 0){
+                integrity = message.messageFields[i].messageFieldValue;
+            }
+            else if(strcmp(message.messageFields[i].messageFieldName, "replay") == 0){
+                replay = message.messageFields[i].messageFieldValue;
+            }
+            else if(strcmp(message.messageFields[i].messageFieldName, "security_header_type") == 0){
+                security_header_type = message.messageFields[i].messageFieldValue;
+                if (security_header_type == 4) {
+                    security_header_type = 5 + rand()%11;
+                }       
+            }
+        }
+
+       ret = myNasInstance->handle_statelearner_query_attach_accept_custom(cipher, integrity, replay, security_header_type);
+    }
+    else if(strcmp(message.messageName, "GUTI_reallocation") == 0){
+        int cipher = 1;
+        int integrity = 1;
+        int replay = 0;
+        int security_header_type = 2;
+ 
+
+        for(int i=0; i<message.numberOfFields; i++){
+            if(strcmp(message.messageFields[i].messageFieldName, "cipher") == 0){
+                cipher = message.messageFields[i].messageFieldValue;
+            }
+            else if(strcmp(message.messageFields[i].messageFieldName, "integrity") == 0){
+                integrity = message.messageFields[i].messageFieldValue;
+            }
+            else if(strcmp(message.messageFields[i].messageFieldName, "replay") == 0){
+                replay = message.messageFields[i].messageFieldValue;
+            }
+            else if(strcmp(message.messageFields[i].messageFieldName, "security_header_type") == 0){
+                security_header_type = message.messageFields[i].messageFieldValue;
+                if (security_header_type == 4) {
+                    security_header_type = 5 + rand()%11;
+                }
+            }
+        }
+
+        ret = myNasInstance->handle_statelearner_query_guti_rellocation_custom(cipher, integrity, replay, security_header_type);
+    }
+    else if(strcmp(message.messageName, "dl_nas_transport") == 0){
+        int cipher = 1;
+        int integrity = 1;
+        int replay = 0;
+        int security_header_type = 2;
+ 
+
+        for(int i=0; i<message.numberOfFields; i++){
+            if(strcmp(message.messageFields[i].messageFieldName, "cipher") == 0){
+                cipher = message.messageFields[i].messageFieldValue;
+            }
+            else if(strcmp(message.messageFields[i].messageFieldName, "integrity") == 0){
+                integrity = message.messageFields[i].messageFieldValue;
+            }
+            else if(strcmp(message.messageFields[i].messageFieldName, "replay") == 0){
+                replay = message.messageFields[i].messageFieldValue;
+            }
+            else if(strcmp(message.messageFields[i].messageFieldName, "security_header_type") == 0){
+                security_header_type = message.messageFields[i].messageFieldValue;
+                if (security_header_type == 4) {
+                    security_header_type = 5 + rand()%11;
+                }
+            }
+        }
+        if(cipher == -1 || integrity == -1 || replay == -1 || security_header_type == -1){
+            printf("Undefined value!!!\n");
+            exit(1);
+        }
+        ret = myNasInstance->handle_statelearner_query_dl_nas_transport_custom(cipher, integrity, replay, security_header_type);
+    }
+    else if(strcmp(message.messageName, "service_reject") == 0){
+        int emm_cause = 10; //LIBLTE_MME_EMM_CAUSE_IMPLICITLY_DETACHED
+        int security_header_type = 0;
+ 
+
+        for(int i=0; i<message.numberOfFields; i++){
+            if(strcmp(message.messageFields[i].messageFieldName, "emm_cause") == 0){
+                emm_cause = message.messageFields[i].messageFieldValue;
+            }
+            else if(strcmp(message.messageFields[i].messageFieldName, "security_header_type") == 0){
+                security_header_type = message.messageFields[i].messageFieldValue;
+                if (security_header_type == 4) {
+                    security_header_type = 5 + rand()%11;
+                }
+            }
+        }
+
+        ret = myNasInstance->handle_statelearner_query_service_reject_custom(emm_cause, security_header_type);
+    }
+    else if(strcmp(message.messageName, "attach_reject") == 0){
+        int emm_cause = 11;  //LIBLTE_MME_EMM_CAUSE_PLMN_NOT_ALLOWED
+
+ 
+        for(int i=0; i<message.numberOfFields; i++){
+            if(strcmp(message.messageFields[i].messageFieldName, "emm_cause") == 0){
+                emm_cause = message.messageFields[i].messageFieldValue;
+            }
+        }
+
+        ret = myNasInstance->handle_statelearner_query_attach_reject_custom(emm_cause);
+    }
+    else if(strcmp(message.messageName, "auth_reject") == 0){
+
+        ret = myNasInstance->handle_statelearner_query_authentication_reject_custom();
+
+    }
+    else if(strcmp(message.messageName, "emm_information") == 0){
+
+        ret = myNasInstance->handle_statelearner_query_emm_information();
+
+    }
+    else if(strcmp(message.messageName, "detach_request") == 0){
+        // not defined in srsran
+        int integrity = 1;
+        int cipher = 1;
+        int reattach_required = -1;
+        int security_header_type = 2;
+        int emm_cause = -1;
+ 
+
+        for(int i=0; i<message.numberOfFields; i++){
+            if(strcmp(message.messageFields[i].messageFieldName, "integrity") == 0){
+                integrity = message.messageFields[i].messageFieldValue;
+            }
+            else if(strcmp(message.messageFields[i].messageFieldName, "cipher") == 0){
+                cipher = message.messageFields[i].messageFieldValue;
+            }
+            else if(strcmp(message.messageFields[i].messageFieldName, "reattach_required") == 0){
+                reattach_required = message.messageFields[i].messageFieldValue;
+            }
+            else if(strcmp(message.messageFields[i].messageFieldName, "security_header_type") == 0){
+                security_header_type = message.messageFields[i].messageFieldValue;
+                if (security_header_type == 4) {
+                    security_header_type = 5 + rand()%11;
+                }
+            }
+            else if(strcmp(message.messageFields[i].messageFieldName, "emm_cause") == 0){
+                emm_cause = message.messageFields[i].messageFieldValue;
+            }
+        }
+
+        // TODO: enable this
+        myNasInstance->handle_statelearner_query_detach_request_custom(integrity, cipher,  security_header_type);
+    }
+    else if(strcmp(message.messageName, "wait") == 0){
+
+       int time = 10;
+      
+ 
+
+        for(int i=0; i<message.numberOfFields; i++){
+            if(strcmp(message.messageFields[i].messageFieldName, "time") == 0){
+                time = message.messageFields[i].messageFieldValue;
+            }
+        }
+
+        printf("Waiting for %d minutes\n", time);
+        sleep(60*time);
+    }
+    
+
+}
+
+uint8_t* constructMessage(const char* messageName, const MessageField* fields, int numFields) {
+    std::ostringstream oss;
+    oss << messageName << ":";
+
+    if (fields && numFields > 0) {
+        for (int i = 0; i < numFields; ++i) {
+            oss << " " << fields[i].messageFieldName << " == " << fields[i].messageFieldValue;
+            if (i != numFields - 1) {  // not the last field
+                oss << " &";
+            }
+        }
+    }
+    
+    std::string resultStr = oss.str();
+    uint8_t* result = new uint8_t[resultStr.length() + 1];  // +1 for null terminator
+    std::copy(resultStr.begin(), resultStr.end(), result);
+    result[resultStr.length()] = '\0';  // null-terminate
+
+    return result;
+}
+
+
+uint8_t* handleSecurityModeComplete(int nas_msg_container_IE){
+    uint8_t* message = constructMessage("security_mode_complete", nullptr, 0);
+    std::cout << message << std::endl;
+    return message;
+    // int numberOfFields = 1;
+    // MessageField fields[1];
+    // strcpy(fields[0].messageFieldName, "nas_msg_container_IE");
+    // fields[0].messageFieldValue = nas_msg_container_IE;
+    // uint8_t* message = constructMessage("security_mode_complete", fields, numberOfFields);
+    // std::cout << message << std::endl;
+    // return message;  // delete[] message;
+}
+
+
+uint8_t* handleAuthenticationFailure(int emm_cause){
+    int numberOfFields = 1;
+    MessageField fields[1];
+    strcpy(fields[0].messageFieldName, "emm_cause");
+    fields[0].messageFieldValue = emm_cause;
+    uint8_t* message = constructMessage("authentication_failure", fields, numberOfFields);
+    std::cout << message << std::endl;
+    return message;  // delete[] message;
+}
+
+
+uint8_t* handleAuthenticationResponse(){
+    uint8_t* message = constructMessage("authentication_response", nullptr, 0);
+    std::cout << message << std::endl;
+    return message;
+}
+
+
+uint8_t* handleAttachRequest(int emergency){
+
+    uint8_t* message = constructMessage("attach_request", nullptr, 0);
+    std::cout << message << std::endl;
+    return message;
+    // int numberOfFields = 1;
+    // MessageField fields[1];
+    // strcpy(fields[0].messageFieldName, "emergency");
+    // fields[0].messageFieldValue = emergency;
+    // uint8_t* message = constructMessage("attach_request", fields, numberOfFields);
+    // std::cout << message << std::endl;
+    // return message;
+}
+
+uint8_t* handleAttachComplete(){
+    uint8_t* message = constructMessage("attach_complete", nullptr, 0);
+    std::cout << message << std::endl;
+    return message;
+}
+
+uint8_t *handleUlNasTransport(){
+    uint8_t* message = constructMessage("ul_nas_transport", nullptr, 0);
+    std::cout << message << std::endl;
+    return message;
+}
+
+uint8_t *handleGutiReallocationComplete(){
+    uint8_t* message = constructMessage("GUTI_reallocation_complete", nullptr, 0);
+    std::cout << message << std::endl;
+    return message;
+}
+
+uint8_t *handleEmmStatus(){
+    uint8_t* message = constructMessage("emm_status", nullptr, 0);
+    std::cout << message << std::endl;
+    return message;
+}
+
+uint8_t *handleDetachRequest(){
+    uint8_t* message = constructMessage("detach_request", nullptr, 0);
+    std::cout << message << std::endl;
+    return message;
+}
+
+uint8_t *handleDetachAccept(){
+    uint8_t* message = constructMessage("detach_accept", nullptr, 0);
+    std::cout << message << std::endl;
+    return message;
+}
+
+uint8_t* handleSecurityModeReject(int emm_cause){
+    int numberOfFields = 1;
+    MessageField fields[1];
+    strcpy(fields[0].messageFieldName, "emm_cause");
+    fields[0].messageFieldValue = emm_cause;
+    uint8_t* message = constructMessage("security_mode_reject", fields, numberOfFields);
+    std::cout << message << std::endl;
+    return message;  // delete[] message;
+}
+
+uint8_t* handleAttachRequestGUTI(){
+    uint8_t* message = constructMessage("attach_request_guti", nullptr, 0);
+    std::cout << message << std::endl;
+    return message;
+}
+
+uint8_t* handleServiceRequest(){
+    uint8_t* message = constructMessage("service_request", nullptr, 0);
+    std::cout << message << std::endl;
+    return message;
+}
+
+uint8_t* handleTauRequest(){
+    uint8_t* message = constructMessage("tau_request", nullptr, 0);
+    std::cout << message << std::endl;
+    return message;
+}
+
+uint8_t* handleAuthResponseRejected(){
+    uint8_t* message = constructMessage("auth_response_rejected", nullptr, 0);
+    std::cout << message << std::endl;
+    return message;
+}
+
+uint8_t* handleTauComplete(){
+    uint8_t* message = constructMessage("tau_complete", nullptr, 0);
+    std::cout << message << std::endl;
+    return message;
+}
+
+uint8_t* handleEsmInfoResponse(){
+    uint8_t* message = constructMessage("esm_info_request", nullptr, 0);
+    std::cout << message << std::endl;
+    return message;
+}
+
+uint8_t* handleIdentityResponse(){
+    uint8_t* message = constructMessage("identity_response", nullptr, 0);
+    std::cout << message << std::endl;
+    return message;
+}
+
+uint8_t* handleNullAction(){
+    uint8_t* message = constructMessage("null_action", nullptr, 0);
+    std::cout << message << std::endl;
+    return message;
+}
+
+
+
+uint8_t* handleRRCSecurityModeComplete(){
+    uint8_t* message = constructMessage("rrc_security_mode_complete", nullptr, 0);
+    std::cout << message << std::endl;
+    return message;
+}
+
+uint8_t* handleRRCUECapInfo(){
+    uint8_t* message = constructMessage("rrc_ue_cap_info", nullptr, 0);
+    std::cout << message << std::endl;
+    return message;
+}
+
+uint8_t* handleRRCReconfComplete(){
+    uint8_t* message = constructMessage("rrc_reconf_complete", nullptr, 0);
+    std::cout << message << std::endl;
+    return message;
+}
+
diff --git a/srsepc/src/mme/s1ap.cc b/srsepc/src/mme/s1ap.cc
old mode 100644
new mode 100755
index ae07fb21c..dce368f99
--- a/srsepc/src/mme/s1ap.cc
+++ b/srsepc/src/mme/s1ap.cc
@@ -28,6 +28,9 @@
 #include <inttypes.h> // for printing uint64_t
 #include <random>
 
+// fuzzing
+#include "srsepc/hdr/mme/parse_cmd.h"
+
 namespace srsepc {
 
 s1ap*           s1ap::m_instance    = NULL;
@@ -60,7 +63,7 @@ void s1ap::cleanup(void)
   pthread_mutex_unlock(&s1ap_instance_mutex);
 }
 
-int s1ap::init(const s1ap_args_t& s1ap_args)
+int s1ap::init(const s1ap_args_t& s1ap_args, mme_statelearner_interface_s1ap *mme_statelearner_)
 {
   m_s1ap_args = s1ap_args;
   srsran::s1ap_mccmnc_to_plmn(s1ap_args.mcc, s1ap_args.mnc, &m_plmn);
@@ -73,11 +76,13 @@ int s1ap::init(const s1ap_args_t& s1ap_args)
   // Get pointer to the HSS
   m_hss = hss::get_instance();
 
+  m_mme_statelearner = mme_statelearner_; // Fuzzing
+
   // Init message handlers
   m_s1ap_mngmt_proc = s1ap_mngmt_proc::get_instance(); // Managment procedures
   m_s1ap_mngmt_proc->init();
   m_s1ap_nas_transport = s1ap_nas_transport::get_instance(); // NAS Transport procedures
-  m_s1ap_nas_transport->init();
+  m_s1ap_nas_transport->init(mme_statelearner_); // fuzzing
   m_s1ap_ctx_mngmt_proc = s1ap_ctx_mngmt_proc::get_instance(); // Context Management Procedures
   m_s1ap_ctx_mngmt_proc->init();
   m_s1ap_erab_mngmt_proc = s1ap_erab_mngmt_proc::get_instance(); // E-RAB Management Procedures
@@ -630,10 +635,12 @@ bool s1ap::send_ue_context_release_command(uint32_t mme_ue_s1ap_id)
 {
   nas* nas_ctx = find_nas_ctx_from_mme_ue_s1ap_id(mme_ue_s1ap_id);
   if (nas_ctx == NULL) {
+    srsran::console("638 Error finding NAS context when sending UE Context Setup Release\n");
     m_logger.error("Error finding NAS context when sending UE Context Setup Release");
     return false;
   }
   m_s1ap_ctx_mngmt_proc->send_ue_context_release_command(nas_ctx);
+  srsran::console("643 Sending UE context release command\n");
   return true;
 }
 
@@ -675,4 +682,73 @@ bool s1ap::expire_nas_timer(enum nas_timer_type type, uint64_t imsi)
   return err;
 }
 
+// fuzzing
+bool s1ap::send_query(uint8_t *msg, uint16_t len) {
+
+    bool ret = false;
+    // std::string rcvd_msg(reinterpret_cast<char*>(msg), len);
+    if (memcmp(msg,"rrc_sercurity_mode_command",strlen("rrc_sercurity_mode_command")) == 0 || memcmp(msg,"rrc_reconf",strlen("rrc_reconf")) == 0 ||
+    memcmp(msg,"counter_check",strlen("counter_check")) == 0 || memcmp(msg,"ue_information_request",strlen("ue_information_request")) == 0
+    || memcmp(msg,"ue_capability_enquiry",strlen("ue_capability_enquiry")) == 0)
+      return false;
+    
+    
+
+    if(memcmp(msg, "RESET", 5) == 0){
+      printf("RESET!!!!!!\n");
+      Message cmd = parseMessage(msg,len);
+      pthread_mutex_lock(&s1ap_instance_mutex);
+
+      m_mme_statelearner->set_mme_statelearner_reset_state();
+      srsran::console("MME_STATE = RESET START\n");
+      srsran::console("# query: RESET #\n");
+
+      ret = m_s1ap_nas_transport->handle_statelearner_query(cmd, FUZZING_MSG_TYPE_RESET_UL_NAS_COUNT);
+      nas *nas_ctx = find_nas_ctx_from_imsi(m_s1ap_args.ue_under_test_imsi);
+      
+      if(nas_ctx != NULL) {
+        
+          nas_ctx->m_emm_ctx.state = EMM_STATE_DEREGISTERED;
+
+          m_mme_gtpc->send_delete_session_request(nas_ctx->m_emm_ctx.imsi);
+          srsran::console("712 Sending delete session request\n");
+
+          if(nas_ctx->m_ecm_ctx.mme_ue_s1ap_id != 0) {
+              send_ue_context_release_command(nas_ctx->m_ecm_ctx.mme_ue_s1ap_id);
+              srsran::console("716 Sending UE context release command\n");
+          }
+
+          ret = delete_ue_ctx(m_s1ap_args.ue_under_test_imsi);
+
+          if (ret == false) {
+              srsran::console("ERROR in Resetting ue_ctx\n");
+          }
+      }
+
+      m_tmsi_to_imsi.clear();
+      uint8_t response[6] = "DONE\n";
+      uint8_t size = 6;
+      m_mme_statelearner->notify_response(response, size);
+
+      ret = true;
+      srsran::console("MME_STATE = RESET END\n");
+      m_mme_statelearner->reset_mme_statelearner_reset_state();
+      pthread_mutex_unlock(&s1ap_instance_mutex);
+    }
+    else {
+      Message cmd = parseMessage(msg,len);
+      ret = m_s1ap_nas_transport->handle_statelearner_query(cmd,0);
+    }
+
+  return ret;
+}
+
+bool s1ap::notify_response(uint8_t *response, uint16_t size) {
+  return m_mme_statelearner->notify_response(response, size);
+}
+
+bool s1ap::get_mme_statelearner_reset_state() {
+  return m_mme_statelearner->get_mme_statelearner_reset_state();
+}
+
 } // namespace srsepc
diff --git a/srsepc/src/mme/s1ap_ctx_mngmt_proc.cc b/srsepc/src/mme/s1ap_ctx_mngmt_proc.cc
old mode 100644
new mode 100755
index e170b30c8..30cc58393
--- a/srsepc/src/mme/s1ap_ctx_mngmt_proc.cc
+++ b/srsepc/src/mme/s1ap_ctx_mngmt_proc.cc
@@ -102,7 +102,8 @@ bool s1ap_ctx_mngmt_proc::send_initial_context_setup_request(nas* nas_ctx, uint1
   erab_ctx_req.erab_id = esm_ctx->erab_id;
 
   // Setup E-RAB QoS parameters
-  erab_ctx_req.erab_level_qos_params.qci                             = esm_ctx->qci;
+  // erab_ctx_req.erab_level_qos_params.qci                             = esm_ctx->qci;
+  erab_ctx_req.erab_level_qos_params.qci                             = 7;
   erab_ctx_req.erab_level_qos_params.alloc_retention_prio.prio_level = 15; // lowest
   erab_ctx_req.erab_level_qos_params.alloc_retention_prio.pre_emption_cap =
       asn1::s1ap::pre_emption_cap_opts::shall_not_trigger_pre_emption;
@@ -138,17 +139,17 @@ bool s1ap_ctx_mngmt_proc::send_initial_context_setup_request(nas* nas_ctx, uint1
   m_logger.info(sec_ctx->k_enb, 32, "Initial Context Setup Request -- Key eNB (k_enb)");
 
   srsran::unique_byte_buffer_t nas_buffer = srsran::make_byte_buffer();
-  if (emm_ctx->state == EMM_STATE_DEREGISTERED) {
-    // Attach procedure initiated from an attach request
-    srsran::console("Adding attach accept to Initial Context Setup Request\n");
-    m_logger.info("Adding attach accept to Initial Context Setup Request");
-    nas_ctx->pack_attach_accept(nas_buffer.get());
-
-    // Add nas message to context setup request
-    erab_ctx_req.nas_pdu_present = true;
-    erab_ctx_req.nas_pdu.resize(nas_buffer->N_bytes);
-    memcpy(erab_ctx_req.nas_pdu.data(), nas_buffer->msg, nas_buffer->N_bytes);
-  }
+  // if (emm_ctx->state == EMM_STATE_DEREGISTERED) {
+  //   // Attach procedure initiated from an attach request
+  //   srsran::console("Adding attach accept to Initial Context Setup Request\n");
+  //   m_logger.info("Adding attach accept to Initial Context Setup Request");
+  //   nas_ctx->pack_attach_accept(nas_buffer.get());
+
+  //   // Add nas message to context setup request
+  //   erab_ctx_req.nas_pdu_present = true;
+  //   erab_ctx_req.nas_pdu.resize(nas_buffer->N_bytes);
+  //   memcpy(erab_ctx_req.nas_pdu.data(), nas_buffer->msg, nas_buffer->N_bytes);
+  // }
 
   if (!m_s1ap->s1ap_tx_pdu(tx_pdu, &ecm_ctx->enb_sri)) {
     m_logger.error("Error sending Initial Context Setup Request.");
@@ -324,6 +325,8 @@ bool s1ap_ctx_mngmt_proc::send_ue_context_release_command(nas* nas_ctx)
     return false;
   }
 
+  srsran::console("328 send_ue_context_release_command");
+
   return true;
 }
 
diff --git a/srsepc/src/mme/s1ap_erab_mngmt_proc.cc b/srsepc/src/mme/s1ap_erab_mngmt_proc.cc
old mode 100644
new mode 100755
diff --git a/srsepc/src/mme/s1ap_mngmt_proc.cc b/srsepc/src/mme/s1ap_mngmt_proc.cc
old mode 100644
new mode 100755
diff --git a/srsepc/src/mme/s1ap_nas_transport.cc b/srsepc/src/mme/s1ap_nas_transport.cc
old mode 100644
new mode 100755
index dea0b2c73..d9f8a186d
--- a/srsepc/src/mme/s1ap_nas_transport.cc
+++ b/srsepc/src/mme/s1ap_nas_transport.cc
@@ -30,6 +30,8 @@
 
 namespace srsepc {
 
+int ul_nas_transport = 1;
+
 s1ap_nas_transport* s1ap_nas_transport::m_instance    = NULL;
 pthread_mutex_t     s1ap_nas_transport_instance_mutex = PTHREAD_MUTEX_INITIALIZER;
 
@@ -63,10 +65,13 @@ void s1ap_nas_transport::cleanup(void)
   pthread_mutex_unlock(&s1ap_nas_transport_instance_mutex);
 }
 
-void s1ap_nas_transport::init()
+void s1ap_nas_transport::init(mme_statelearner_interface_s1ap *mme_statelearner_)
 {
   m_s1ap = s1ap::get_instance();
 
+  // fuzzing
+  m_mme_statelearner = mme_statelearner_;
+  
   // Init NAS args
   m_nas_init.mcc            = m_s1ap->m_s1ap_args.mcc;
   m_nas_init.mnc            = m_s1ap->m_s1ap_args.mnc;
@@ -83,6 +88,9 @@ void s1ap_nas_transport::init()
   m_nas_init.request_imeisv = m_s1ap->m_s1ap_args.request_imeisv;
   m_nas_init.lac            = m_s1ap->m_s1ap_args.lac;
 
+  // fuzzing
+  m_nas_init.ue_under_test_imsi = m_s1ap->m_s1ap_args.ue_under_test_imsi;
+
   // Init NAS interface
   m_nas_if.s1ap = s1ap::get_instance();
   m_nas_if.gtpc = mme_gtpc::get_instance();
@@ -90,6 +98,24 @@ void s1ap_nas_transport::init()
   m_nas_if.mme  = mme::get_instance();
 }
 
+//================================================== Fuzzing =========================================
+bool s1ap_nas_transport:: handle_statelearner_query(Message msg, uint8_t event) {
+    // Get UE NAS context
+    nas* nas_ctx = m_s1ap->find_nas_ctx_from_imsi(m_nas_init.ue_under_test_imsi);
+    if (nas_ctx == NULL) {
+      m_logger.warning("Received query, but statelearner could not find UE NAS context for ue_under_test_imsi\n");
+      srsran::console("Received query, but statelearner could not find UE NAS context for ue_under_test_imsi\n");
+      return false;
+    }
+    if(event == FUZZING_MSG_TYPE_RESET_UL_NAS_COUNT){
+      ul_nas_transport = 1;
+      return nas_ctx->handle_statelearner_query_reset_attach_accept_setup();
+    }
+    handleMessageCmd(msg, nas_ctx);
+
+    return true;
+}
+
 bool s1ap_nas_transport::handle_initial_ue_message(const asn1::s1ap::init_ue_msg_s& init_ue,
                                                    struct sctp_sndrcvinfo*          enb_sri)
 {
@@ -144,6 +170,11 @@ bool s1ap_nas_transport::handle_initial_ue_message(const asn1::s1ap::init_ue_msg
 bool s1ap_nas_transport::handle_uplink_nas_transport(const asn1::s1ap::ul_nas_transport_s& ul_xport,
                                                      struct sctp_sndrcvinfo*               enb_sri)
 {
+  // fuzzing
+  bool MAC = false;
+  bool encrypted = false;
+  bool flag = false;
+
   uint8_t  pd, msg_type, sec_hdr_type;
   uint32_t enb_ue_s1ap_id      = ul_xport->enb_ue_s1ap_id.value.value;
   uint32_t mme_ue_s1ap_id      = ul_xport->mme_ue_s1ap_id.value.value;
@@ -202,6 +233,8 @@ bool s1ap_nas_transport::handle_uplink_nas_transport(const asn1::s1ap::ul_nas_tr
       srslog::log_channel& channel = warn_integrity_fail ? m_logger.warning : m_logger.info;
       channel("Invalid MAC message. Even if security header indicates integrity protection (Maybe: "
               "Identity Response or Authentication Response)");
+    } else {
+      MAC = true;
     }
   }
 
@@ -212,6 +245,8 @@ bool s1ap_nas_transport::handle_uplink_nas_transport(const asn1::s1ap::ul_nas_tr
     nas_ctx->cipher_decrypt(nas_msg.get());
     msg_encrypted = true;
     m_logger.debug(nas_msg->msg, nas_msg->N_bytes, "Decrypted");
+
+    encrypted = true;
   }
 
   // Now parse message header and handle message
@@ -223,6 +258,7 @@ bool s1ap_nas_transport::handle_uplink_nas_transport(const asn1::s1ap::ul_nas_tr
     if (emm_ctx->imsi == 0) {
       // No EMM context found. Perhaps a temporary context is being created?
       // This can happen with integrity protected identity reponse messages
+      flag = true;
       if (!(msg_type == LIBLTE_MME_MSG_TYPE_IDENTITY_RESPONSE &&
             sec_hdr_type == LIBLTE_MME_SECURITY_HDR_TYPE_INTEGRITY)) {
         m_logger.warning(
@@ -256,14 +292,24 @@ bool s1ap_nas_transport::handle_uplink_nas_transport(const asn1::s1ap::ul_nas_tr
       nas_ctx->handle_attach_request(nas_msg.get());
       break;
     case LIBLTE_MME_MSG_TYPE_IDENTITY_RESPONSE:
+      if (MAC && encrypted) {
+          flag = true;
+      } else {
+          flag = false;
+      }
       m_logger.info("UL NAS: Received Identity Response");
       srsran::console("UL NAS: Received Identity Response\n");
       nas_ctx->handle_identity_response(nas_msg.get());
       break;
     case LIBLTE_MME_MSG_TYPE_AUTHENTICATION_RESPONSE:
+      if (MAC && encrypted) {
+          flag = true;
+      } else {
+          flag = false;
+      }
       m_logger.info("UL NAS: Received Authentication Response");
       srsran::console("UL NAS: Received Authentication Response\n");
-      nas_ctx->handle_authentication_response(nas_msg.get());
+      nas_ctx->handle_authentication_response(nas_msg.get(), flag);
       // In case of a successful authentication response, security mode command follows.
       // Reset counter for incoming security mode complete
       sec_ctx->ul_nas_count = 0;
@@ -334,6 +380,43 @@ bool s1ap_nas_transport::handle_uplink_nas_transport(const asn1::s1ap::ul_nas_tr
       srsran::console("UL NAS: PDN Connectivity Request\n");
       nas_ctx->handle_pdn_connectivity_request(nas_msg.get());
       break;
+    //================================ Fuzzing ==============================
+    case LIBLTE_MME_MSG_TYPE_SECURITY_MODE_REJECT:
+      m_logger.info("UL NAS: Received Security Mode Reject\n");
+      srsran::console("UL NAS: Received Security Mode Reject\n");
+
+      if (sec_hdr_type == LIBLTE_MME_SECURITY_HDR_TYPE_INTEGRITY_AND_CIPHERED_WITH_NEW_EPS_SECURITY_CONTEXT && mac_valid == true) {
+        nas_ctx->handle_security_mode_complete(nas_msg.get());
+      } else {
+        // Security Mode Reject was not integrity protected
+        increase_ul_nas_cnt = false;
+      }
+      nas_ctx->handle_security_mode_reject(nas_msg.get());
+      break;
+    case LIBLTE_MME_MSG_TYPE_EMM_STATUS:
+      m_logger.info("Plain Protected UL NAS: EMM Status\n");
+      nas_ctx->handle_nas_emm_status(nas_msg.get());
+      increase_ul_nas_cnt = false;
+      break;
+    //=========================================================================
+    case LIBLTE_MME_MSG_TYPE_GUTI_REALLOCATION_COMPLETE:
+      m_logger.info("UL NAS: GUTI Reallocation Complete\n");
+      srsran::console("UL NAS: GUTI Reallocation Complete\n");
+      nas_ctx->handle_guti_reallocation_complete(nas_msg.get());
+      break;
+    case LIBLTE_MME_MSG_TYPE_TRACKING_AREA_UPDATE_COMPLETE:
+      m_logger.info("UL NAS: Received Tracking Area Update Complete\n");
+      srsran::console("UL NAS: Received Tracking Area Update Complete\n");
+      nas_ctx->handle_tracking_area_update_complete(nas_msg.get());
+      break;
+    case LIBLTE_MME_MSG_TYPE_UPLINK_NAS_TRANSPORT:
+      m_logger.info("UL NAS: Received Uplink NAS Transport\n");
+      srsran::console("UL NAS: Received Uplink NAS Transport\n");
+      ul_nas_transport++;
+      if (ul_nas_transport%2!=0){
+          nas_ctx->handle_uplink_nas_transport(nas_msg.get());
+      }
+      break;
     default:
       m_logger.warning("Unhandled NAS integrity protected message %s", liblte_nas_msg_type_to_string(msg_type));
       srsran::console("Unhandled NAS integrity protected message %s\n", liblte_nas_msg_type_to_string(msg_type));
diff --git a/srsepc/src/mme/s1ap_paging.cc b/srsepc/src/mme/s1ap_paging.cc
old mode 100644
new mode 100755
diff --git a/srsepc/src/mme/string_help.c b/srsepc/src/mme/string_help.c
new file mode 100755
index 000000000..e885dc275
--- /dev/null
+++ b/srsepc/src/mme/string_help.c
@@ -0,0 +1,138 @@
+#include <ctype.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include "srsepc/hdr/mme/string_help.h"
+
+//GeeksForGeeks: https://www.geeksforgeeks.org/implement-itoa/#
+void reverse(char str[], int length){
+    int start = 0;
+    int end = length - 1;
+    while (start < end) {
+        char temp = str[start];
+        str[start] = str[end];
+        str[end] = temp;
+        end--;
+        start++;
+    }
+}
+
+// GeeksForGeeks: https://www.geeksforgeeks.org/implement-itoa/#
+char* custom_itoa(int num, int base){
+    char* str = (char*) malloc(sizeof(char ) * 16);
+    int i = 0;
+    int isNegative = 0;
+    if (num == 0) {
+        str[i++] = '0';
+        str[i] = '\0';
+        return str;
+    }
+    if (num < 0 && base == 10) {
+        isNegative = 1;
+        num = -num;
+    }
+    // Process individual digits
+    while (num != 0) {
+        int rem = num % base;
+        str[i++] = (rem > 9) ? (rem - 10) + 'a' : rem + '0';
+        num = num / base;
+    }
+    // If number is negative, append '-'
+    if (isNegative)
+        str[i++] = '-';
+    str[i] = '\0'; // Append string terminator
+    // Reverse the string
+    reverse(str, i);
+    return str;
+}
+
+// GeeksForGeeks: https://www.geeksforgeeks.org/write-your-own-atoi/#
+int custom_atoi(const char* str){
+    int res = 0;
+    for (int i = 0; str[i] != '\0'; i++){
+        res = res * 10 + str[i] - '0';
+    }
+    return res;
+}
+
+/// StackOverflow: https://stackoverflow.com/a/26984026
+// need to clean up returned pointer
+char *string_trim_whitespace(const char *str) {
+    char *res = (char *) malloc(sizeof(char ) * strlen(str));
+    char *tmp = (char *) malloc(sizeof(char ) * strlen(str));
+    char *fixed_tmp = tmp;
+
+    strcpy(tmp, str);
+
+    while (isspace((unsigned char) *tmp)) tmp++;
+        if (*tmp) {
+            char *p = tmp;
+            while (*p) p++;
+            while (isspace((unsigned char) *(--p)));
+            p[1] = '\0';
+        }
+    strcpy(res, tmp);
+    free(fixed_tmp);
+    return res;
+}
+
+int findFirst(char *str, char target){
+    int len = strlen(str);
+    for(int i = 0; i < len && str[i]; i++){
+        if(str[i] == target){
+            return i;
+        }
+    }
+    return -1;
+}
+
+int countChar(const char *str, char target){
+    int count = 0;
+    int len = strlen(str);
+    for(int i = 0; i < len; i++){
+        if(str[i] == target){
+            count++;
+        }
+    }
+    return count;
+}
+
+// need to clean up returned pointers
+char **splitStr(char *str, char target, int *splitCount, int trim){
+    *splitCount = countChar(str, target)+1;
+
+//    printf("count = %d\n", *count);
+
+    char *tempStrPtr = str;
+
+    char **results = (char **) malloc(sizeof(char *) * (*splitCount));
+    for(int i=0; i < (*splitCount); i++){
+        char *buf = (char *) malloc(sizeof(char) * (strlen(str)+20));
+
+        int pos = findFirst(tempStrPtr, target);
+
+        if(i == (*splitCount)-1){
+            strcpy(buf, tempStrPtr);
+        }
+        else if(pos < 0){
+            printf("Error in split!!!\n");
+            exit(1);
+        }
+        else if (pos == 0){
+            strcpy(buf, "");
+        }
+        else{
+            strncpy(buf, tempStrPtr, pos);
+            buf[pos] = '\0';
+        }
+
+        if (trim){
+            char *tmp = string_trim_whitespace(buf);
+            strcpy(buf, tmp);
+            free(tmp);
+        }
+        results[i] = buf;
+        tempStrPtr = tempStrPtr + pos + 1;
+    }
+    return results;
+}
diff --git a/srsepc/src/spgw/CMakeLists.txt b/srsepc/src/spgw/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsepc/src/spgw/gtpc.cc b/srsepc/src/spgw/gtpc.cc
old mode 100644
new mode 100755
diff --git a/srsepc/src/spgw/gtpu.cc b/srsepc/src/spgw/gtpu.cc
old mode 100644
new mode 100755
diff --git a/srsepc/src/spgw/spgw.cc b/srsepc/src/spgw/spgw.cc
old mode 100644
new mode 100755
diff --git a/srsepc/user_db.csv.example b/srsepc/user_db.csv.example
old mode 100644
new mode 100755
diff --git a/srsgnb/CMakeLists.txt b/srsgnb/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/phy/phy_nr_interfaces.h b/srsgnb/hdr/phy/phy_nr_interfaces.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/common/test/dummy_nr_classes.h b/srsgnb/hdr/stack/common/test/dummy_nr_classes.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/gnb_stack_nr.h b/srsgnb/hdr/stack/gnb_stack_nr.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/mac/harq_softbuffer.h b/srsgnb/hdr/stack/mac/harq_softbuffer.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/mac/mac_nr.h b/srsgnb/hdr/stack/mac/mac_nr.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/mac/sched_nr.h b/srsgnb/hdr/stack/mac/sched_nr.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/mac/sched_nr_bwp.h b/srsgnb/hdr/stack/mac/sched_nr_bwp.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/mac/sched_nr_cfg.h b/srsgnb/hdr/stack/mac/sched_nr_cfg.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/mac/sched_nr_grant_allocator.h b/srsgnb/hdr/stack/mac/sched_nr_grant_allocator.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/mac/sched_nr_harq.h b/srsgnb/hdr/stack/mac/sched_nr_harq.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/mac/sched_nr_helpers.h b/srsgnb/hdr/stack/mac/sched_nr_helpers.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/mac/sched_nr_interface.h b/srsgnb/hdr/stack/mac/sched_nr_interface.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/mac/sched_nr_interface_utils.h b/srsgnb/hdr/stack/mac/sched_nr_interface_utils.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/mac/sched_nr_pdcch.h b/srsgnb/hdr/stack/mac/sched_nr_pdcch.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/mac/sched_nr_rb.h b/srsgnb/hdr/stack/mac/sched_nr_rb.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/mac/sched_nr_sch.h b/srsgnb/hdr/stack/mac/sched_nr_sch.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/mac/sched_nr_signalling.h b/srsgnb/hdr/stack/mac/sched_nr_signalling.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/mac/sched_nr_time_rr.h b/srsgnb/hdr/stack/mac/sched_nr_time_rr.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/mac/sched_nr_ue.h b/srsgnb/hdr/stack/mac/sched_nr_ue.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/mac/sched_nr_worker.h b/srsgnb/hdr/stack/mac/sched_nr_worker.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/mac/sched_ue/ue_cfg_manager.h b/srsgnb/hdr/stack/mac/sched_ue/ue_cfg_manager.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/mac/ue_nr.h b/srsgnb/hdr/stack/mac/ue_nr.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/ngap/ngap.h b/srsgnb/hdr/stack/ngap/ngap.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/ngap/ngap_interfaces.h b/srsgnb/hdr/stack/ngap/ngap_interfaces.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/ngap/ngap_metrics.h b/srsgnb/hdr/stack/ngap/ngap_metrics.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/ngap/ngap_ue.h b/srsgnb/hdr/stack/ngap/ngap_ue.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/ngap/ngap_ue_bearer_manager.h b/srsgnb/hdr/stack/ngap/ngap_ue_bearer_manager.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/ngap/ngap_ue_proc.h b/srsgnb/hdr/stack/ngap/ngap_ue_proc.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/ngap/ngap_ue_utils.h b/srsgnb/hdr/stack/ngap/ngap_ue_utils.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/ric/e2_agent.h b/srsgnb/hdr/stack/ric/e2_agent.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/ric/e2ap.h b/srsgnb/hdr/stack/ric/e2ap.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/ric/e2ap_ric_subscription.h b/srsgnb/hdr/stack/ric/e2ap_ric_subscription.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/ric/e2sm.h b/srsgnb/hdr/stack/ric/e2sm.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/ric/e2sm_kpm.h b/srsgnb/hdr/stack/ric/e2sm_kpm.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/ric/e2sm_kpm_common.h b/srsgnb/hdr/stack/ric/e2sm_kpm_common.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/ric/e2sm_kpm_metrics.h b/srsgnb/hdr/stack/ric/e2sm_kpm_metrics.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/ric/e2sm_kpm_report_service.h b/srsgnb/hdr/stack/ric/e2sm_kpm_report_service.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/rrc/cell_asn1_config.h b/srsgnb/hdr/stack/rrc/cell_asn1_config.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/rrc/rrc_nr.h b/srsgnb/hdr/stack/rrc/rrc_nr.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/rrc/rrc_nr_config.h b/srsgnb/hdr/stack/rrc/rrc_nr_config.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/rrc/rrc_nr_config_utils.h b/srsgnb/hdr/stack/rrc/rrc_nr_config_utils.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/rrc/rrc_nr_du_manager.h b/srsgnb/hdr/stack/rrc/rrc_nr_du_manager.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/rrc/rrc_nr_security_context.h b/srsgnb/hdr/stack/rrc/rrc_nr_security_context.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/rrc/rrc_nr_ue.h b/srsgnb/hdr/stack/rrc/rrc_nr_ue.h
old mode 100644
new mode 100755
diff --git a/srsgnb/hdr/stack/sdap/sdap.h b/srsgnb/hdr/stack/sdap/sdap.h
old mode 100644
new mode 100755
diff --git a/srsgnb/src/CMakeLists.txt b/srsgnb/src/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/CMakeLists.txt b/srsgnb/src/stack/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/gnb_stack_nr.cc b/srsgnb/src/stack/gnb_stack_nr.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/mac/CMakeLists.txt b/srsgnb/src/stack/mac/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/mac/harq_softbuffer.cc b/srsgnb/src/stack/mac/harq_softbuffer.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/mac/mac_nr.cc b/srsgnb/src/stack/mac/mac_nr.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/mac/sched_nr.cc b/srsgnb/src/stack/mac/sched_nr.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/mac/sched_nr_bwp.cc b/srsgnb/src/stack/mac/sched_nr_bwp.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/mac/sched_nr_cfg.cc b/srsgnb/src/stack/mac/sched_nr_cfg.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/mac/sched_nr_grant_allocator.cc b/srsgnb/src/stack/mac/sched_nr_grant_allocator.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/mac/sched_nr_harq.cc b/srsgnb/src/stack/mac/sched_nr_harq.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/mac/sched_nr_helpers.cc b/srsgnb/src/stack/mac/sched_nr_helpers.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/mac/sched_nr_interface_utils.cc b/srsgnb/src/stack/mac/sched_nr_interface_utils.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/mac/sched_nr_pdcch.cc b/srsgnb/src/stack/mac/sched_nr_pdcch.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/mac/sched_nr_rb.cc b/srsgnb/src/stack/mac/sched_nr_rb.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/mac/sched_nr_sch.cc b/srsgnb/src/stack/mac/sched_nr_sch.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/mac/sched_nr_signalling.cc b/srsgnb/src/stack/mac/sched_nr_signalling.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/mac/sched_nr_time_rr.cc b/srsgnb/src/stack/mac/sched_nr_time_rr.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/mac/sched_nr_ue.cc b/srsgnb/src/stack/mac/sched_nr_ue.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/mac/sched_nr_worker.cc b/srsgnb/src/stack/mac/sched_nr_worker.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/mac/sched_ue/ue_cfg_manager.cc b/srsgnb/src/stack/mac/sched_ue/ue_cfg_manager.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/mac/test/CMakeLists.txt b/srsgnb/src/stack/mac/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/mac/test/sched_nr_cfg_generators.h b/srsgnb/src/stack/mac/test/sched_nr_cfg_generators.h
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/mac/test/sched_nr_common_test.cc b/srsgnb/src/stack/mac/test/sched_nr_common_test.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/mac/test/sched_nr_common_test.h b/srsgnb/src/stack/mac/test/sched_nr_common_test.h
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/mac/test/sched_nr_dci_utilities_tests.cc b/srsgnb/src/stack/mac/test/sched_nr_dci_utilities_tests.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/mac/test/sched_nr_parallel_test.cc b/srsgnb/src/stack/mac/test/sched_nr_parallel_test.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/mac/test/sched_nr_pdcch_test.cc b/srsgnb/src/stack/mac/test/sched_nr_pdcch_test.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/mac/test/sched_nr_prb_test.cc b/srsgnb/src/stack/mac/test/sched_nr_prb_test.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/mac/test/sched_nr_rar_test.cc b/srsgnb/src/stack/mac/test/sched_nr_rar_test.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/mac/test/sched_nr_sch_test.cc b/srsgnb/src/stack/mac/test/sched_nr_sch_test.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/mac/test/sched_nr_sim_ue.cc b/srsgnb/src/stack/mac/test/sched_nr_sim_ue.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/mac/test/sched_nr_sim_ue.h b/srsgnb/src/stack/mac/test/sched_nr_sim_ue.h
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/mac/test/sched_nr_test.cc b/srsgnb/src/stack/mac/test/sched_nr_test.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/mac/test/sched_nr_ue_ded_test_suite.cc b/srsgnb/src/stack/mac/test/sched_nr_ue_ded_test_suite.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/mac/test/sched_nr_ue_ded_test_suite.h b/srsgnb/src/stack/mac/test/sched_nr_ue_ded_test_suite.h
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/mac/ue_nr.cc b/srsgnb/src/stack/mac/ue_nr.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/ngap/CMakeLists.txt b/srsgnb/src/stack/ngap/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/ngap/ngap.cc b/srsgnb/src/stack/ngap/ngap.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/ngap/ngap_ue.cc b/srsgnb/src/stack/ngap/ngap_ue.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/ngap/ngap_ue_bearer_manager.cc b/srsgnb/src/stack/ngap/ngap_ue_bearer_manager.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/ngap/ngap_ue_proc.cc b/srsgnb/src/stack/ngap/ngap_ue_proc.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/ngap/test/CMakeLists.txt b/srsgnb/src/stack/ngap/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/ngap/test/ngap_test.cc b/srsgnb/src/stack/ngap/test/ngap_test.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/ric/CMakeLists.txt b/srsgnb/src/stack/ric/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/ric/e2_agent.cc b/srsgnb/src/stack/ric/e2_agent.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/ric/e2ap.cc b/srsgnb/src/stack/ric/e2ap.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/ric/e2ap_ric_subscription.cc b/srsgnb/src/stack/ric/e2ap_ric_subscription.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/ric/e2sm_kpm.cc b/srsgnb/src/stack/ric/e2sm_kpm.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/ric/e2sm_kpm_common.cc b/srsgnb/src/stack/ric/e2sm_kpm_common.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/ric/e2sm_kpm_report_service.cc b/srsgnb/src/stack/ric/e2sm_kpm_report_service.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/ric/test/CMakeLists.txt b/srsgnb/src/stack/ric/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/ric/test/e2ap_test.cc b/srsgnb/src/stack/ric/test/e2ap_test.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/rrc/CMakeLists.txt b/srsgnb/src/stack/rrc/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/rrc/cell_asn1_config.cc b/srsgnb/src/stack/rrc/cell_asn1_config.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/rrc/rrc_nr.cc b/srsgnb/src/stack/rrc/rrc_nr.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/rrc/rrc_nr_config_utils.cc b/srsgnb/src/stack/rrc/rrc_nr_config_utils.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/rrc/rrc_nr_du_manager.cc b/srsgnb/src/stack/rrc/rrc_nr_du_manager.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/rrc/rrc_nr_security_context.cc b/srsgnb/src/stack/rrc/rrc_nr_security_context.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/rrc/rrc_nr_ue.cc b/srsgnb/src/stack/rrc/rrc_nr_ue.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/rrc/test/CMakeLists.txt b/srsgnb/src/stack/rrc/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/rrc/test/rrc_nr_core_test.cc b/srsgnb/src/stack/rrc/test/rrc_nr_core_test.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/rrc/test/rrc_nr_test.cc b/srsgnb/src/stack/rrc/test/rrc_nr_test.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/rrc/test/rrc_nr_test_helpers.cc b/srsgnb/src/stack/rrc/test/rrc_nr_test_helpers.cc
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/rrc/test/rrc_nr_test_helpers.h b/srsgnb/src/stack/rrc/test/rrc_nr_test_helpers.h
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/sdap/CMakeLists.txt b/srsgnb/src/stack/sdap/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsgnb/src/stack/sdap/sdap.cc b/srsgnb/src/stack/sdap/sdap.cc
old mode 100644
new mode 100755
diff --git a/srsue/CMakeLists.txt b/srsue/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsue/hdr/metrics_csv.h b/srsue/hdr/metrics_csv.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/metrics_json.h b/srsue/hdr/metrics_json.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/metrics_stdout.h b/srsue/hdr/metrics_stdout.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/phy/dummy_phy.h b/srsue/hdr/phy/dummy_phy.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/phy/lte/cc_worker.h b/srsue/hdr/phy/lte/cc_worker.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/phy/lte/sf_worker.h b/srsue/hdr/phy/lte/sf_worker.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/phy/lte/worker_pool.h b/srsue/hdr/phy/lte/worker_pool.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/phy/nr/cc_worker.h b/srsue/hdr/phy/nr/cc_worker.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/phy/nr/cell_search.h b/srsue/hdr/phy/nr/cell_search.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/phy/nr/sf_worker.h b/srsue/hdr/phy/nr/sf_worker.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/phy/nr/slot_sync.h b/srsue/hdr/phy/nr/slot_sync.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/phy/nr/state.h b/srsue/hdr/phy/nr/state.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/phy/nr/sync_sa.h b/srsue/hdr/phy/nr/sync_sa.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/phy/nr/worker_pool.h b/srsue/hdr/phy/nr/worker_pool.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/phy/phy.h b/srsue/hdr/phy/phy.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/phy/phy_common.h b/srsue/hdr/phy/phy_common.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/phy/phy_metrics.h b/srsue/hdr/phy/phy_metrics.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/phy/phy_nr_sa.h b/srsue/hdr/phy/phy_nr_sa.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/phy/prach.h b/srsue/hdr/phy/prach.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/phy/scell/intra_measure_base.h b/srsue/hdr/phy/scell/intra_measure_base.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/phy/scell/intra_measure_lte.h b/srsue/hdr/phy/scell/intra_measure_lte.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/phy/scell/intra_measure_nr.h b/srsue/hdr/phy/scell/intra_measure_nr.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/phy/scell/scell_recv.h b/srsue/hdr/phy/scell/scell_recv.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/phy/scell/scell_state.h b/srsue/hdr/phy/scell/scell_state.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/phy/scell/scell_sync.h b/srsue/hdr/phy/scell/scell_sync.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/phy/search.h b/srsue/hdr/phy/search.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/phy/sfn_sync.h b/srsue/hdr/phy/sfn_sync.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/phy/sync.h b/srsue/hdr/phy/sync.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/phy/sync_state.h b/srsue/hdr/phy/sync_state.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/phy/ta_control.h b/srsue/hdr/phy/ta_control.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/phy/ue_phy_base.h b/srsue/hdr/phy/ue_phy_base.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/mac/demux.h b/srsue/hdr/stack/mac/demux.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/mac/dl_harq.h b/srsue/hdr/stack/mac/dl_harq.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/mac/dl_sps.h b/srsue/hdr/stack/mac/dl_sps.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/mac/mac.h b/srsue/hdr/stack/mac/mac.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/mac/mac_metrics.h b/srsue/hdr/stack/mac/mac_metrics.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/mac/mux.h b/srsue/hdr/stack/mac/mux.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/mac/proc.h b/srsue/hdr/stack/mac/proc.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/mac/proc_bsr.h b/srsue/hdr/stack/mac/proc_bsr.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/mac/proc_phr.h b/srsue/hdr/stack/mac/proc_phr.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/mac/proc_ra.h b/srsue/hdr/stack/mac/proc_ra.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/mac/proc_sr.h b/srsue/hdr/stack/mac/proc_sr.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/mac/ul_harq.h b/srsue/hdr/stack/mac/ul_harq.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/mac/ul_sps.h b/srsue/hdr/stack/mac/ul_sps.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/mac_common/mac_common.h b/srsue/hdr/stack/mac_common/mac_common.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/mac_common/mux_base.h b/srsue/hdr/stack/mac_common/mux_base.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/mac_nr/demux_nr.h b/srsue/hdr/stack/mac_nr/demux_nr.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/mac_nr/dl_harq_nr.h b/srsue/hdr/stack/mac_nr/dl_harq_nr.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/mac_nr/mac_nr.h b/srsue/hdr/stack/mac_nr/mac_nr.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/mac_nr/mac_nr_interfaces.h b/srsue/hdr/stack/mac_nr/mac_nr_interfaces.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/mac_nr/mux_nr.h b/srsue/hdr/stack/mac_nr/mux_nr.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/mac_nr/proc_bsr_nr.h b/srsue/hdr/stack/mac_nr/proc_bsr_nr.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/mac_nr/proc_ra_nr.h b/srsue/hdr/stack/mac_nr/proc_ra_nr.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/mac_nr/proc_sr_nr.h b/srsue/hdr/stack/mac_nr/proc_sr_nr.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/mac_nr/ul_harq_nr.h b/srsue/hdr/stack/mac_nr/ul_harq_nr.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/rrc/phy_controller.h b/srsue/hdr/stack/rrc/phy_controller.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/rrc/rrc.h b/srsue/hdr/stack/rrc/rrc.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/rrc/rrc_cell.h b/srsue/hdr/stack/rrc/rrc_cell.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/rrc/rrc_config.h b/srsue/hdr/stack/rrc/rrc_config.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/rrc/rrc_meas.h b/srsue/hdr/stack/rrc/rrc_meas.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/rrc/rrc_metrics.h b/srsue/hdr/stack/rrc/rrc_metrics.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/rrc/rrc_procedures.h b/srsue/hdr/stack/rrc/rrc_procedures.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/rrc/rrc_rlf_report.h b/srsue/hdr/stack/rrc/rrc_rlf_report.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/rrc_nr/rrc_nr.h b/srsue/hdr/stack/rrc_nr/rrc_nr.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/rrc_nr/rrc_nr_config.h b/srsue/hdr/stack/rrc_nr/rrc_nr_config.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/rrc_nr/rrc_nr_metrics.h b/srsue/hdr/stack/rrc_nr/rrc_nr_metrics.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/rrc_nr/rrc_nr_procedures.h b/srsue/hdr/stack/rrc_nr/rrc_nr_procedures.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/ue_stack_base.h b/srsue/hdr/stack/ue_stack_base.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/ue_stack_lte.h b/srsue/hdr/stack/ue_stack_lte.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/ue_stack_nr.h b/srsue/hdr/stack/ue_stack_nr.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/upper/gw.h b/srsue/hdr/stack/upper/gw.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/upper/gw_metrics.h b/srsue/hdr/stack/upper/gw_metrics.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/upper/nas.h b/srsue/hdr/stack/upper/nas.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/upper/nas_5g.h b/srsue/hdr/stack/upper/nas_5g.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/upper/nas_5g_metrics.h b/srsue/hdr/stack/upper/nas_5g_metrics.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/upper/nas_5g_procedures.h b/srsue/hdr/stack/upper/nas_5g_procedures.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/upper/nas_5gmm_state.h b/srsue/hdr/stack/upper/nas_5gmm_state.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/upper/nas_base.h b/srsue/hdr/stack/upper/nas_base.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/upper/nas_config.h b/srsue/hdr/stack/upper/nas_config.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/upper/nas_emm_state.h b/srsue/hdr/stack/upper/nas_emm_state.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/upper/nas_idle_procedures.h b/srsue/hdr/stack/upper/nas_idle_procedures.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/upper/nas_metrics.h b/srsue/hdr/stack/upper/nas_metrics.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/upper/pcsc_usim.h b/srsue/hdr/stack/upper/pcsc_usim.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/upper/sdap.h b/srsue/hdr/stack/upper/sdap.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/upper/test/nas_test_common.h b/srsue/hdr/stack/upper/test/nas_test_common.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/upper/tft_packet_filter.h b/srsue/hdr/stack/upper/tft_packet_filter.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/upper/usim.h b/srsue/hdr/stack/upper/usim.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/stack/upper/usim_base.h b/srsue/hdr/stack/upper/usim_base.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/ue.h b/srsue/hdr/ue.h
old mode 100644
new mode 100755
diff --git a/srsue/hdr/ue_metrics_interface.h b/srsue/hdr/ue_metrics_interface.h
old mode 100644
new mode 100755
diff --git a/srsue/src/CMakeLists.txt b/srsue/src/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsue/src/main.cc b/srsue/src/main.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/metrics_csv.cc b/srsue/src/metrics_csv.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/metrics_json.cc b/srsue/src/metrics_json.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/metrics_stdout.cc b/srsue/src/metrics_stdout.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/phy/CMakeLists.txt b/srsue/src/phy/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsue/src/phy/lte/cc_worker.cc b/srsue/src/phy/lte/cc_worker.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/phy/lte/sf_worker.cc b/srsue/src/phy/lte/sf_worker.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/phy/lte/worker_pool.cc b/srsue/src/phy/lte/worker_pool.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/phy/nr/cc_worker.cc b/srsue/src/phy/nr/cc_worker.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/phy/nr/cell_search.cc b/srsue/src/phy/nr/cell_search.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/phy/nr/sf_worker.cc b/srsue/src/phy/nr/sf_worker.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/phy/nr/slot_sync.cc b/srsue/src/phy/nr/slot_sync.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/phy/nr/worker_pool.cc b/srsue/src/phy/nr/worker_pool.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/phy/phy.cc b/srsue/src/phy/phy.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/phy/phy_common.cc b/srsue/src/phy/phy_common.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/phy/phy_nr_sa.cc b/srsue/src/phy/phy_nr_sa.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/phy/prach.cc b/srsue/src/phy/prach.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/phy/scell/intra_measure_base.cc b/srsue/src/phy/scell/intra_measure_base.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/phy/scell/intra_measure_lte.cc b/srsue/src/phy/scell/intra_measure_lte.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/phy/scell/intra_measure_nr.cc b/srsue/src/phy/scell/intra_measure_nr.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/phy/scell/scell_recv.cc b/srsue/src/phy/scell/scell_recv.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/phy/search.cc b/srsue/src/phy/search.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/phy/sfn_sync.cc b/srsue/src/phy/sfn_sync.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/phy/sync.cc b/srsue/src/phy/sync.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/phy/sync_sa.cc b/srsue/src/phy/sync_sa.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/phy/test/CMakeLists.txt b/srsue/src/phy/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsue/src/phy/test/gnb_emulator.h b/srsue/src/phy/test/gnb_emulator.h
old mode 100644
new mode 100755
diff --git a/srsue/src/phy/test/gnb_rf_emulator.h b/srsue/src/phy/test/gnb_rf_emulator.h
old mode 100644
new mode 100755
diff --git a/srsue/src/phy/test/nr_cell_search_rf.cc b/srsue/src/phy/test/nr_cell_search_rf.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/phy/test/nr_cell_search_test.cc b/srsue/src/phy/test/nr_cell_search_test.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/phy/test/nr_sa_cell_search_test.cc b/srsue/src/phy/test/nr_sa_cell_search_test.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/phy/test/scell_search_test.cc b/srsue/src/phy/test/scell_search_test.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/phy/test/ue_phy_test.cc b/srsue/src/phy/test/ue_phy_test.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/CMakeLists.txt b/srsue/src/stack/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/mac/CMakeLists.txt b/srsue/src/stack/mac/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/mac/demux.cc b/srsue/src/stack/mac/demux.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/mac/dl_harq.cc b/srsue/src/stack/mac/dl_harq.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/mac/mac.cc b/srsue/src/stack/mac/mac.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/mac/mux.cc b/srsue/src/stack/mac/mux.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/mac/proc_bsr.cc b/srsue/src/stack/mac/proc_bsr.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/mac/proc_phr.cc b/srsue/src/stack/mac/proc_phr.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/mac/proc_ra.cc b/srsue/src/stack/mac/proc_ra.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/mac/proc_sr.cc b/srsue/src/stack/mac/proc_sr.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/mac/test/CMakeLists.txt b/srsue/src/stack/mac/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/mac/test/mac_test.cc b/srsue/src/stack/mac/test/mac_test.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/mac/ul_harq.cc b/srsue/src/stack/mac/ul_harq.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/mac_common/CMakeLists.txt b/srsue/src/stack/mac_common/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/mac_common/mac_common.cc b/srsue/src/stack/mac_common/mac_common.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/mac_nr/CMakeLists.txt b/srsue/src/stack/mac_nr/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/mac_nr/demux_nr.cc b/srsue/src/stack/mac_nr/demux_nr.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/mac_nr/dl_harq_nr.cc b/srsue/src/stack/mac_nr/dl_harq_nr.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/mac_nr/mac_nr.cc b/srsue/src/stack/mac_nr/mac_nr.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/mac_nr/mux_nr.cc b/srsue/src/stack/mac_nr/mux_nr.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/mac_nr/proc_bsr_nr.cc b/srsue/src/stack/mac_nr/proc_bsr_nr.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/mac_nr/proc_ra_nr.cc b/srsue/src/stack/mac_nr/proc_ra_nr.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/mac_nr/proc_sr_nr.cc b/srsue/src/stack/mac_nr/proc_sr_nr.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/mac_nr/test/CMakeLists.txt b/srsue/src/stack/mac_nr/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/mac_nr/test/mac_nr_test.cc b/srsue/src/stack/mac_nr/test/mac_nr_test.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/mac_nr/test/proc_bsr_nr_test.cc b/srsue/src/stack/mac_nr/test/proc_bsr_nr_test.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/mac_nr/test/proc_ra_nr_test.cc b/srsue/src/stack/mac_nr/test/proc_ra_nr_test.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/mac_nr/test/proc_sr_nr_test.cc b/srsue/src/stack/mac_nr/test/proc_sr_nr_test.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/mac_nr/ul_harq_nr.cc b/srsue/src/stack/mac_nr/ul_harq_nr.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/rrc/CMakeLists.txt b/srsue/src/stack/rrc/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/rrc/phy_controller.cc b/srsue/src/stack/rrc/phy_controller.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/rrc/rrc.cc b/srsue/src/stack/rrc/rrc.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/rrc/rrc_cell.cc b/srsue/src/stack/rrc/rrc_cell.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/rrc/rrc_meas.cc b/srsue/src/stack/rrc/rrc_meas.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/rrc/rrc_procedures.cc b/srsue/src/stack/rrc/rrc_procedures.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/rrc/rrc_rlf_report.cc b/srsue/src/stack/rrc/rrc_rlf_report.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/rrc/test/CMakeLists.txt b/srsue/src/stack/rrc/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/rrc/test/rrc_cell_test.cc b/srsue/src/stack/rrc/test/rrc_cell_test.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/rrc/test/rrc_meas_test.cc b/srsue/src/stack/rrc/test/rrc_meas_test.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/rrc/test/rrc_phy_ctrl_test.cc b/srsue/src/stack/rrc/test/rrc_phy_ctrl_test.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/rrc/test/rrc_reconfig_test.cc b/srsue/src/stack/rrc/test/rrc_reconfig_test.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/rrc/test/rrc_rlf_report_test.cc b/srsue/src/stack/rrc/test/rrc_rlf_report_test.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/rrc_nr/CMakeLists.txt b/srsue/src/stack/rrc_nr/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/rrc_nr/rrc_nr.cc b/srsue/src/stack/rrc_nr/rrc_nr.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/rrc_nr/rrc_nr_procedures.cc b/srsue/src/stack/rrc_nr/rrc_nr_procedures.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/rrc_nr/test/CMakeLists.txt b/srsue/src/stack/rrc_nr/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/rrc_nr/test/ue_rrc_nr_test.cc b/srsue/src/stack/rrc_nr/test/ue_rrc_nr_test.cc
old mode 100644
new mode 100755
index 7c83afe10..ca1f01140
--- a/srsue/src/stack/rrc_nr/test/ue_rrc_nr_test.cc
+++ b/srsue/src/stack/rrc_nr/test/ue_rrc_nr_test.cc
@@ -101,6 +101,9 @@ class dummy_pdcp : public pdcp_interface_rrc
                          srsran::srsran_direction_t direction = srsran::srsran_direction_t::DIRECTION_TXRX){};
   void send_status_report(){};
   void send_status_report(uint32_t lcid){};
+  // fuzzing
+  void disable_integrity(uint32_t lcid){};
+  void disable_encryption(uint32_t lcid){};
 };
 
 class dummy_sdap : public sdap_interface_pdcp_nr, public sdap_interface_gw_nr, public sdap_interface_rrc
diff --git a/srsue/src/stack/ue_stack_lte.cc b/srsue/src/stack/ue_stack_lte.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/ue_stack_nr.cc b/srsue/src/stack/ue_stack_nr.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/upper/CMakeLists.txt b/srsue/src/stack/upper/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/upper/gw.cc b/srsue/src/stack/upper/gw.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/upper/nas.cc b/srsue/src/stack/upper/nas.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/upper/nas_5g.cc b/srsue/src/stack/upper/nas_5g.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/upper/nas_5g_procedures.cc b/srsue/src/stack/upper/nas_5g_procedures.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/upper/nas_5gmm_state.cc b/srsue/src/stack/upper/nas_5gmm_state.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/upper/nas_base.cc b/srsue/src/stack/upper/nas_base.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/upper/nas_emm_state.cc b/srsue/src/stack/upper/nas_emm_state.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/upper/nas_idle_procedures.cc b/srsue/src/stack/upper/nas_idle_procedures.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/upper/pcsc_usim.cc b/srsue/src/stack/upper/pcsc_usim.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/upper/sdap.cc b/srsue/src/stack/upper/sdap.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/upper/test/CMakeLists.txt b/srsue/src/stack/upper/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/upper/test/gw_test.cc b/srsue/src/stack/upper/test/gw_test.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/upper/test/nas_5g_test.cc b/srsue/src/stack/upper/test/nas_5g_test.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/upper/test/nas_test.cc b/srsue/src/stack/upper/test/nas_test.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/upper/test/pcsc_usim_test.cc b/srsue/src/stack/upper/test/pcsc_usim_test.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/upper/test/tft_test.cc b/srsue/src/stack/upper/test/tft_test.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/upper/test/usim_test.cc b/srsue/src/stack/upper/test/usim_test.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/upper/tft_packet_filter.cc b/srsue/src/stack/upper/tft_packet_filter.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/upper/usim.cc b/srsue/src/stack/upper/usim.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/stack/upper/usim_base.cc b/srsue/src/stack/upper/usim_base.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/test/CMakeLists.txt b/srsue/src/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsue/src/test/metrics_test.cc b/srsue/src/test/metrics_test.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/test/ttcn3/CMakeLists.txt b/srsue/src/test/ttcn3/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsue/src/test/ttcn3/README.md b/srsue/src/test/ttcn3/README.md
old mode 100644
new mode 100755
diff --git a/srsue/src/test/ttcn3/hdr/dut_utils.h b/srsue/src/test/ttcn3/hdr/dut_utils.h
old mode 100644
new mode 100755
diff --git a/srsue/src/test/ttcn3/hdr/lte_ttcn3_phy.h b/srsue/src/test/ttcn3/hdr/lte_ttcn3_phy.h
old mode 100644
new mode 100755
diff --git a/srsue/src/test/ttcn3/hdr/swappable_sink.h b/srsue/src/test/ttcn3/hdr/swappable_sink.h
old mode 100644
new mode 100755
diff --git a/srsue/src/test/ttcn3/hdr/ttcn3_common.h b/srsue/src/test/ttcn3/hdr/ttcn3_common.h
old mode 100644
new mode 100755
diff --git a/srsue/src/test/ttcn3/hdr/ttcn3_drb_interface.h b/srsue/src/test/ttcn3/hdr/ttcn3_drb_interface.h
old mode 100644
new mode 100755
diff --git a/srsue/src/test/ttcn3/hdr/ttcn3_helpers.h b/srsue/src/test/ttcn3/hdr/ttcn3_helpers.h
old mode 100644
new mode 100755
diff --git a/srsue/src/test/ttcn3/hdr/ttcn3_interfaces.h b/srsue/src/test/ttcn3/hdr/ttcn3_interfaces.h
old mode 100644
new mode 100755
diff --git a/srsue/src/test/ttcn3/hdr/ttcn3_ip_ctrl_interface.h b/srsue/src/test/ttcn3/hdr/ttcn3_ip_ctrl_interface.h
old mode 100644
new mode 100755
diff --git a/srsue/src/test/ttcn3/hdr/ttcn3_ip_sock_interface.h b/srsue/src/test/ttcn3/hdr/ttcn3_ip_sock_interface.h
old mode 100644
new mode 100755
diff --git a/srsue/src/test/ttcn3/hdr/ttcn3_port_handler.h b/srsue/src/test/ttcn3/hdr/ttcn3_port_handler.h
old mode 100644
new mode 100755
diff --git a/srsue/src/test/ttcn3/hdr/ttcn3_srb_interface.h b/srsue/src/test/ttcn3/hdr/ttcn3_srb_interface.h
old mode 100644
new mode 100755
diff --git a/srsue/src/test/ttcn3/hdr/ttcn3_sys_interface.h b/srsue/src/test/ttcn3/hdr/ttcn3_sys_interface.h
old mode 100644
new mode 100755
diff --git a/srsue/src/test/ttcn3/hdr/ttcn3_syssim.h b/srsue/src/test/ttcn3/hdr/ttcn3_syssim.h
old mode 100644
new mode 100755
diff --git a/srsue/src/test/ttcn3/hdr/ttcn3_ue.h b/srsue/src/test/ttcn3/hdr/ttcn3_ue.h
old mode 100644
new mode 100755
diff --git a/srsue/src/test/ttcn3/hdr/ttcn3_ut_interface.h b/srsue/src/test/ttcn3/hdr/ttcn3_ut_interface.h
old mode 100644
new mode 100755
diff --git a/srsue/src/test/ttcn3/src/CMakeLists.txt b/srsue/src/test/ttcn3/src/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsue/src/test/ttcn3/src/lte_ttcn3_phy.cc b/srsue/src/test/ttcn3/src/lte_ttcn3_phy.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/test/ttcn3/src/ttcn3_dut.cc b/srsue/src/test/ttcn3/src/ttcn3_dut.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/test/ttcn3/src/ttcn3_syssim.cc b/srsue/src/test/ttcn3/src/ttcn3_syssim.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/test/ttcn3/src/ttcn3_ue.cc b/srsue/src/test/ttcn3/src/ttcn3_ue.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/test/ttcn3/test/CMakeLists.txt b/srsue/src/test/ttcn3/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/srsue/src/test/ttcn3/test/rapidjson_test.cc b/srsue/src/test/ttcn3/test/rapidjson_test.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/test/ttcn3/test/ttcn3_if_handler_test.cc b/srsue/src/test/ttcn3/test/ttcn3_if_handler_test.cc
old mode 100644
new mode 100755
diff --git a/srsue/src/ue.cc b/srsue/src/ue.cc
old mode 100644
new mode 100755
diff --git a/srsue/ue.conf.example b/srsue/ue.conf.example
old mode 100644
new mode 100755
diff --git a/test/CMakeLists.txt b/test/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/test/README.md b/test/README.md
old mode 100644
new mode 100755
diff --git a/test/phy/CMakeLists.txt b/test/phy/CMakeLists.txt
old mode 100644
new mode 100755
diff --git a/test/phy/dummy_gnb_stack.h b/test/phy/dummy_gnb_stack.h
old mode 100644
new mode 100755
diff --git a/test/phy/dummy_phy_common.h b/test/phy/dummy_phy_common.h
old mode 100644
new mode 100755
diff --git a/test/phy/dummy_rx_harq_proc.h b/test/phy/dummy_rx_harq_proc.h
old mode 100644
new mode 100755
diff --git a/test/phy/dummy_tx_harq_proc.h b/test/phy/dummy_tx_harq_proc.h
old mode 100644
new mode 100755
diff --git a/test/phy/dummy_ue_phy.h b/test/phy/dummy_ue_phy.h
old mode 100644
new mode 100755
diff --git a/test/phy/dummy_ue_stack.h b/test/phy/dummy_ue_stack.h
old mode 100644
new mode 100755
diff --git a/test/phy/nr_phy_test.cc b/test/phy/nr_phy_test.cc
old mode 100644
new mode 100755
diff --git a/test/phy/test_bench.h b/test/phy/test_bench.h
old mode 100644
new mode 100755
